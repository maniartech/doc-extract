/**
 *
 *                     _     ____                 _ _ _
 *                    | |   |  _ \               | | (_)
 *       __      _____| |__ | | | |___   ___   __| | |_ _ __   __ _
 *       \ \ /\ / / _ \ '_ \| | | / _ \ / _ \ / _` | | | '_ \ / _` |
 *        \ V  V /  __/ |_) | |/ / (_) | (_) | (_| | | | | | | (_| |
 *         \_/\_/ \___|_.__/|___/ \___/ \___/ \__,_|_|_|_| |_|\__, |
 *                                                             __/ |
 *                                                            |___/
 *
 *
 *      version: 1.0
 *      WebDoodling - An Html5 Canvas based Drawing and Animation Framework
 *      http://www.webDoodling.com
 *
 *      Twitter: @webDoodling
 *      Facebook: http://www.facebook.com/webDoodling
 *
 *      Architect and Lead Developer: Mohamed Aamir Maniar
 *      Twitter: @aamironline
 *      Facebook: http://www.facebook.com/aamironline
 *
 *      Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
 *      http://www.maniartech.com
 *      Twitter: @maniartech
 *
 *      Licensed under the Apache License, Version 2.0 (the "License");
 *      you may not use this file except in compliance with the License.
 *      You may obtain a copy of the License at
 *
 *      http://www.webDoodling.com/license
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *      Unless required by applicable law or agreed to in writing, software
 *      distributed under the License is distributed on an "AS IS" BASIS,
 *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *      See the License for the specific language governing permissions and
 *      limitations under the License.
 *
 **/

/**
 * Framework Factory
 * http://framework-factory.com/
 *
 * Copyright (c) 2013 Maniar Technologies Private Limited
 * Author Mohamed Aamir Maniar
 * Licensed under the MIT license.
 * https://framework-factory.com/LICENSE-MIT
 *
 **/


Object.create = Object.create ||
function create(o) {
    "use strict";

    function F() {}
    F.prototype = o;
    return new F();
};


Object.getPrototypeOf = Object.getPrototypeOf ||
function getPrototypeOf() {
    "use strict";

    if (typeof "test".__proto__ === "object") {
        Object.getPrototypeOf = function (o) {
            return o.__proto__;
        };
    } else {
        Object.getPrototypeOf = function (o) {
            // May break if the constructor has been tampered with
            return o.constructor.prototype;
        };
    }
};

Array.prototype.indexOf = Array.prototype.indexOf ||
function indexOf(obj, start) {
    "use strict";

    for (var i = (start || 0), j = this.length; i < j; i += 1) {
        if (this[i] === obj) {
            return i;
        }
    }
    return -1;
};


String.trim = String.trim ||
function trim(s) {
    "use strict";
    return s.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
};

(function (root, undefined) {
    "use strict";

    var FrameworkFactory,
        plugins = [],
        typeHandlers = {},
        i, iLen,
        environment; //Environement - node, requirejs or browser

    /**
     * FrameworkFactory contains members useful members for generating and managing
     * your very own modern frameworks and framework factory plugins.
     *
     * @Class FrameworkFactory
     * @example
     * var myFramework = FrameworkFactory.create({
     *     name: "myFramework",
     *     version: "1.0"
     * });
     *
     * //Create a new Class called
     * myFramework. = myFramework
     *
     * @public
     * @version 1.0
     **/
    FrameworkFactory = (function () {
        function FrameworkFactory() {}
        return new FrameworkFactory();
    })();

    /**
     * Provides the environment tests in which FrameworkFactory or associated frameworks are
     * currently running. Useful
     * for checking whether current environment is Node, Browser or RequireJS.
     *
     * @field {Object}
     *
     * @public
     * @version 1.0
     */
    FrameworkFactory.environment = environment = (function (){
        function Environement() {}
        return new Environement();
    })();

    /**
     * Returns `true` if framework factory is executing under the NodeJS environment otherwise
     * `false`.
     *
     * @field {boolean}
     *
     * @public
     * @version 1.0
     **/
    environment.node = typeof module !== "undefined" && typeof module.exports === "object";
    if (environment.node) {
        module.exports = FrameworkFactory;
    }

    //environment requirejs
    environment.requirejs = typeof define !== "undefined" && typeof define.amd === "object";
    if (environment.requirejs) {
        define(function() {
            return FrameworkFactory;
        });
    }

    //environment browser
    environment.browser = typeof window !== "undefined" && typeof window.document === "object";

    //Indentify global object
    FrameworkFactory.global = environment.node ? global : root;

    /**
     * The current version of framework factory.
     *
     * @field {string}
     * @defult 1.0.0
     *
     * @public
     * @version 1.0
     **/
    FrameworkFactory.version = '1.0.0';

    /**
     * Factory function which creates the core framework based on specified configuration
     * parameters.
     *
     * @function FrameworkFactory.create(config)
     * @param {objct} config The configuration object.
     * @returns {Object} The base framework.
     *
     * @example
     * // This example creates a new framework called `myFramework` and defines a class called `ClassA`.
     * //`ClassA` contains field called `name` which can be set through constructor `init`.
     *
     * var myFramework = FrameworkFactory.create({
     *     version: '1.2',
     *     framework: 'myFramework'
     * });
     *
     * myFramework.ClassA = myFramework.Class({
     *     name: myFramework.attribute("un-named"),
     *
     *     init: function (name) {
     *         this.name = name;
     *     }
     * });
     *
     * var a = new myFramework.ClassA("wow");
     * console.log(a.name);
     *
     * @memberOf FrameworkFactory
     * @public
     * @version 1.0
     **/
    FrameworkFactory.create = function create(c) {

        var _config = {},
            $f,
            otherVersion = null,
            plugin,
            name,
            key;

        if (typeof c === "string") {
            _config.name = c;
            _config.version = '1.0.0';
            $f = {};
        }
        else {
            c = c || {};

            _config.name = c.name || "framework";
            _config.version = c.version || '1.0.0';

            $f = _config.root || {};

            for (key in c) {
                if (c.hasOwnProperty(key) === true) {
                    if (key in _config === false) {
                        _config[key] = c[key];
                    }
                }
            }
        }

        /**
         * The current version of $f.
         * @field {string} returns
         *
         * @
         */
        $f.version = _config.version;

        //sets the framework name
        $f.name = _config.name;

        //assign the environment object to new framework.
        $f.environment = environment;

        /**
         * Returns the
         * @function config
         **/
        $f.config = function config(key, defaultValue) {
            if (_config[key] !== undefined) {
                return _config[key];
            }
            return defaultValue;
        };

        /**
         * Changes the $f configuration settings.
         * @function $f.config.set(key, value)
         * @param {string} key The name of the configuration key which needs to be changed.
         * @param {object} value The configuration value for specified key.
         * @example         *
         * $f.config.set("myOption", "new-value");
         *
         * @function $f.config.set(o)
         * @param {object} o The configuraiton object
         *
         * @example
         * $f.config.set({
         *     myOption: "new-value"
         * });
         *
         * @public
         */
        $f.config.set = function set() {
            var o = arguments[0],
                key;

            if (arguments.length === 1 && typeof(o) === "object") {
                for(key in o) {
                    if (o.hasOwnProperty(key) === true) {
                        _config[key] = o[key];
                    }
                }
            }
            else if (arguments.length === 2) {
                _config[arguments[0]] = arguments[1];
            }
        };

        //Load plugins
        for (i = 0, iLen = plugins.length; i < iLen; i += 1) {

            plugin = plugins[i];
            name = plugin.info.name;

            //Checks if plugin loaded
            if ($f[name] !== undefined) {
                throw new Error('Plugin with the name "' + name + '" already loaded.');
            }

            //If plugin is defined as function, execute it.
            if (typeof plugin === 'function') {
                plugin($f);
            }
            else if(typeof plugin === 'object') {
                plugin.load($f);
            }
        }

        return $f;
    };

    /**
     * Represents the plugins registry object.
     *
     * @field {Object}hh
     *
     * @memberOf FrameworkFactory
     * @public
     * @version 1.0
     **/
    FrameworkFactory.plugins = (function(){

        function Plugins() {};

        Plugins.prototype = {

            /**
             * Registers the new plugin for the framework. Once registered all the frameworks
             * created henceforth will have specified plugin available.
             * @param {Object} The plugin object.
             * @public
             * @version 1.0
             **/
            register: function register(plugin) {

                if (typeof plugin === 'function' || typeof plugin === 'object') {
                    if (plugin.info.name === undefined) {
                        throw new Error("Missing plugin name.");
                    }
                    plugins.push(plugin);
                    return;
                }
                throw new Error('Invalid plugin type.');
            },

            /**
             * Gets the names of all available plugins with FrameworkFactory.
             *
             * @returns {Array} The plugin names array.
             * @public
             * @version 1.0
             **/
            getNames: function getNames() {
                var names = [],
                    plugin,
                    i, iLen;
                for (i = 0, iLen = plugins.length; i < iLen; i += 1) {
                    plugin = plugins[i];
                    names.push(plugin.name);
                }
                return names;
            },

            /**
             * Gest the array of all the the registered plugins with FramewrokFactory.
             * @returns {Array} The plugings array.
             * @public
             * @version 1.0
             **/
            toArray: function toArray() {
                return plugins.slice();
            }
        };

        return new Plugins();

    })();



    /**
     * Represents the typeHandlers registry object.
     *
     * @memberOf FrameworkFactory
     * @public
     * @version 1.0
     **/
    FrameworkFactory.typeHandlers = (function(){

        function TypeHandlers() {};

        TypeHandlers.prototype = {

            /**
             * Registers the new typeHandler for the framework.
             *
             * @function
             * @param {Object} handler The typeHandler which needs to be registered.
             *
             * @namespace FrameworkFactory.typeHandlers
             * @public
             * @version 1.0
             **/
            register: function register(o) {

                if (typeof o === 'object') {
                    typeHandlers[o.type] = o;
                    return;
                }
                throw new Error('Invalid typeHandler.');
            },

            /**
             * Returns the handler function which is used to handle associated types during class creation.
             *
             * @function
             * @param {string} type The type name of typeHandler.
             * @returns {function} The handler function.
             *
             * @namespace FrameworkFactory.typeHandlers
             * @public
             * @version 1.0
             **/
            get: function get(type) {
                return typeHandlers[type];
            },

            /**
             * Gets the types of all available typeHandlers with FrameworkFactory.
             *
             * @function
             * @returns {Array} The string array which contains types of all registered type handlers.
             *
             * @namespace FrameworkFactory.typeHandlers
             * @public
             * @version 1.0
             **/
            getTypes: function getTypes() {
                var types = [],
                    type;
                for (type in typeHandlers) {
                    if (typeHandlers.hasOwnProperty(type)) {
                        types.push(type);
                    }
                }
                return types;
            }
        };

        return new TypeHandlers();

    })();

    root.FrameworkFactory = FrameworkFactory;

})(this);

(function (root, undefined) {
    "use strict";

    var FrameworkFactory = root.FrameworkFactory;

    function plugin($f) {

        var _is = {

            //Validation
            /**
             * Checks whether given value is a function or not.
             * @function
             * @param {anything} val The val to be checked for function test.
             * @returns {boolean} ``true`` if parameter val is a valid function, else ``false``.
             * @public
             * @version 1.0
             **/
            func: function func(val) {
                return typeof val === 'function' || val instanceof Function  === true;
            },

            /**
             * Checks whether given value is a string or not.
             * @function
             * @param {anything} val The val to be checked for string test.
             * @returns {boolean} ``true`` if parameter val is a valid string, else ``false``.
             * @public
             * @version 1.0
             **/
            string: function string(val) {
                return typeof val === 'string' || val instanceof String === true;
            },

            /**
             * Checks whether given value is a number or not.
             * @function
             * @param {anything} val The val to be checked for number test.
             * @returns {boolean} ``true`` if parameter val is a valid number, else ``false``.
             * @public
             * @version 1.0
             **/
            number: function number(val) {
                return typeof val === 'number' || val instanceof Number  === true;
            },

            /**
             * Checks whether given value is a primitive or not.
             * @function
             * @param {anything} val The val to be checked for primitive test.
             * @returns {boolean} ``true`` if parameter val is a valid primitive, else ``false``.
             * @public
             * @version 1.0
             **/
            primitive: function primitive(val) {
                return _is.string(val) || _is.number(val);
            },

            /**
             * Checks whether specified value is undefined or not.
             * @function undef
             * @module <future-framework>.is
             * @param {anything} val The val to be checked for undefined test.
             * @returns {boolean} ``true`` if parameter val is a valid undefined, else ``false``.
             * @public
             * @version 1.0
             **/
            undef: function undef(val) {
                return val === undefined;
            },

            nullOrUndef: function nullOrUndef(val) {
                return val === undefined || val === null;
            },

            date: function date(val) {
                return val instanceof Date === true;
            },

            plainObject: function (val) {
                if (val === undefined || val === null) { return false; }
                return ((typeof val === 'object') && (val.constructor === Object));
            },

            concreteObject: function (val) {
                return (_is.primitive(val) || _is.date(val) || _is.nullOrUndef(val) || _is.array(val)) === false;
            },

            array: function (val) {
                return val instanceof Array;
            },

            inBrowser: function browser() {
                return window !== undefined && root === window;
            }
        };

        $f.is = _is;
    }

    plugin.info = {
        name: 'is'
    };

    FrameworkFactory.plugins.register(plugin);

})(this);
(function (root, undefined) {
    "use strict";

    var FrameworkFactory = root.FrameworkFactory;

    function _initTypeHandlers(Class) {
        var types = FrameworkFactory.typeHandlers.getTypes(),
            type, typeHandler,
            i, iLen;

        for (i=0, iLen=types.length; i < iLen; i += 1) {
            type = types[i];
            typeHandler = FrameworkFactory.typeHandlers.get(type);
            if (typeHandler.init) {
                typeHandler.init(Class);
            }
        }
    }

    function _plainObject (val) {
        if (val === undefined || val === null) { return false; }
        return ((typeof val === 'object') && (val.constructor === Object));
    }

    function _copyKeys(o, newO, overrideExisting) {
        var key, val;

        overrideExisting = (overrideExisting === undefined) ? true : overrideExisting;

        for(key in o) {
            if (o.hasOwnProperty(key)) {
                val = o[key];
                if (overrideExisting) {
                    newO[key] = val;
                }
                else {
                    if(key in newO === false) {
                        newO[key] = val;
                    }
                }
            }
        }
    }

    function _updateMeta(Class) {
        var meta = Class.__meta__,
            parentMeta = {};

        if(Class.constructor.__baseMeta__) {
            _copyKeys(Class.constructor.__baseMeta__, parentMeta);
        }

        _copyKeys(parentMeta, meta, false);
    }

    function plugin($f) {

        var initializing = true,
            fnTest = /xyz/.test(function (){xyz;}) ? /\bbase\b/ : /.*/,
            defaultBaseClass = $f.config('defaultBaseClass'),
            requireNew = $f.config('requireNew', false),
            Class;

        if (defaultBaseClass !== undefined && $f[defaultBaseClass] === undefined) {
            $f['defaultBaseClass'] = defaultBaseClass;
        }

        Class = function (prop, parent) {
            var hasProp = Object.prototype.hasOwnProperty,
                proto, key, Constructor, __base__, funcString,
                create = Object.create;

            if ($f['defaultBaseClass'] !== undefined) {
                parent  = parent || $f['defaultBaseClass'];
            }
            else {
                parent = parent || Object;
            }
            prop    = prop || {};
            proto = create(parent.prototype);

            if (requireNew) {
                Constructor = function Object () {
                    if (this instanceof Constructor === false) {
                        throw new Error('Constructor used as function.');
                    }
                    // This.constructor = Constructor;
                    if (initializing === false && this.init !== undefined) {
                        this.init.apply(this, arguments);
                    }
                };
            }
            else {
                Constructor = function Object () {
                    var inst = null;

                    // Constructor is called as function,
                    // instanciate it and return instance object.
                    if(this instanceof Constructor === false) {
                        inst = create(Constructor.prototype);
                        if (inst.init !== undefined) {
                            inst.init.apply(inst, arguments);
                        }
                        return inst;
                    }
                    // This.constructor = Constructor;
                    if (this.init !== undefined) {
                        this.init.apply(this, arguments);
                    }
                };
            }

            //for each static members in parents, copy'em to child
            for (key in parent) {
                //if parent owns the key, set child item = parent item
                if (hasProp.call(parent, key)) {
                    Constructor[key] = parent[key];
                }
            }

            __base__ = parent.prototype;

            Constructor.prototype = proto;
            Constructor.prototype.constructor = Constructor;
            Constructor.__base__ = __base__;

            Constructor.attach = function attach(prop) {

                var item, type, val, processed,
                    key,
                    typeHandler;

                for(key in prop) {
                    if (hasProp.call(prop, key)) {
                        item = prop[key];
                        type = typeof item;
                        val = item;
                        processed = false;

                        if ($f.is.plainObject(item)) {
                            typeHandler = FrameworkFactory.typeHandlers.get(item.type);

                            if (typeHandler !== undefined && typeHandler.handler !== undefined) {
                                typeHandler.handler(Constructor, key, item);
                                processed = true;
                            }
                        }
                        else if (type === 'function' &&
                                typeof __base__[key] === 'function' &&
                                fnTest.test(item)) {
                            proto[key] = (function (key, fn) {
                                var baseFunc = function () {
                                        __base__[key].apply(this, arguments);
                                    },
                                    wrapper = function () {
                                        this.base =  baseFunc;
                                        var ret = fn.apply(this, arguments);
                                        this.base = null;
                                        return ret;
                                    };
                                return wrapper;
                            })(key, item);
                            processed = true;
                        }

                        if (!processed) {
                            proto[key] = val;
                        }
                        Constructor.__meta__[key] = item;
                    }
                }
                _updateMeta(Constructor);
            };

            Constructor.__meta__ = {};
            Constructor.__baseMeta__ = __base__.constructor.__meta__;
            _initTypeHandlers(Constructor);
            Constructor.attach(prop);

            //return
            return Constructor;

        };

        $f.Class = Class;

    }

    plugin.info = {
        name: "classes"
    };

    FrameworkFactory.plugins.register(plugin);

})(this);

(function (root, undefined) {
    "use strict";

    var FrameworkFactory = root.FrameworkFactory;

    function plugin($f) {

        var attribute = function (defaultValue) {
                return {
                    type: 'attribute',
                    defaultValue: defaultValue
                };
            };

        /**
         * Helper function to create attribute members for class.
         * @function
         * @param defaultValue The default value of the attribute.
         * @option [options] Additional options for attribute member.
         * @public
         * @version 1.0.0
         **/
        $f.attribute = attribute;

        /**
         * Shortcut to framework.attribute method.
         * @see Framework#attribute
         **/
        $f.attr = attribute;

        FrameworkFactory.typeHandlers.register({
            type: "attribute",
            handler: function handler(Class, key, options) {
                var proto = Class.prototype;
                proto[key] = options.defaultValue;
            }
        });

    }

    plugin.info = {
        name: 'attributes'
    };

    FrameworkFactory.plugins.register(plugin);

})(this);

(function (root, undefined) {
    "use strict";

    var FrameworkFactory = root.FrameworkFactory;

    function plugin($f) {

        $f.event = function () {
            return {
                type: 'event'
            };
        };

        FrameworkFactory.typeHandlers.register({
            type: "event",
            init: function init(Class) {
                var proto = Class.prototype,
                    subscribedEventKeys = {},
                    subscribedEvents = [];

                /**
                 * Registers the event handler for one or more plugin.
                 * This function is similar to obj.eventName except it accepts more then one plugin.
                 * @example
                 * var btn = new Button();
                 * btn.on('mousemove mouseout mouseup', function() {});
                 **/
                proto.on = function (eventNames, eventHandler) {
                    //Conver the event names to lower case.
                    var names = eventNames.toLowerCase().split(' '),
                        i, iLen, eventName,
                        privKey;

                    if (!$f.is.func(eventHandler)) {
                        throw new Error('Only functions can be registered as event handler');
                    }

                    for (i = 0, iLen = names.length; i < iLen; i += 1) {
                        eventName = String.trim(names[i]);

                        privKey = '_' + eventName;
                        if (this[privKey] === undefined) {
                            this[privKey] = [];
                        }
                        this[privKey].push(eventHandler);

                        if (subscribedEventKeys[eventName] === undefined) {
                            subscribedEvents.push(eventName);
                            subscribedEventKeys[eventName] = true;
                        }
                    }
                    return this;
                };

                /**
                 * Triggers an event causes all the hander associated with the event
                 * to be invoked.
                 * @param evantName The name of the event to be triggered.
                 * @param args arguments to be supplied to event handler. The args must be
                 * derived from an Object. This is an optional parameter if it is not supplied
                 * it will be created having a field 'eventName' which will help identify
                 * the name of the event which triggered.
                 **/
                proto.trigger = function (eventName, args) {

                    //TODO: Move to FF
                    var subscribers = this['_' + eventName.toLowerCase()],
                        self = this,
                        callback,
                        i;
                    if (subscribers === undefined || subscribers.length === 0) {
                        return this; //No need to fire event, sicne there is no subscriber.
                    }
                    args = args || {};
                    args.eventName = eventName;
                    for (i = 0; i < subscribers.length; i += 1) {
                        callback = subscribers[i];

                        //TODO: Move to FF
                        // setTimeout(function () {
                        //     callback.call(self, args);
                        // }, 0);
                        if (callback.call(this, args) === false) {
                            //no more firing, if handler returns false.
                            break;
                        }
                    }
                    return this;
                };

                /**
                 * Disassociate the handler from the trigger.
                 **/
                proto.off = function (eventName, handler) {
                    var subscribers = this['_' + eventName.toLowerCase()],
                        index;

                    //Specified event not registered so no need to put it off.
                    if (subscribers === undefined) {
                        return;
                    }

                    //If handler is not provided, remove all subscribers
                    if (handler === undefined) {
                        subscribers.length = 0;
                        return this;
                    }

                    index = subscribers.indexOf(handler);
                    if (index !== -1) {
                        subscribers.splice(index, 1);
                    }
                    return this;
                };

                /**
                 * Unsubscribe all the events from all the subscribers. Use this method to clean up
                 * or detatch event handlers from the object.
                 *
                 * @function $f.Class.unsubscribeAll()
                 * @returns {Object} The current object.
                 *
                 * @public
                 **/
                proto.unsubscribeAll = function unsubscribeAll() {
                    var events = subscribedEvents,
                        i, iLen = events.length;

                    for(i=0; i < iLen; i += 1) {
                        this.off(events[i]);
                    }
                    return this;
                };

                /**
                 *
                 */
                proto.subscribers = function subscribers(eventName) {
                    var eventSubscribers = this['_' + eventName.toLowerCase()];
                    return (eventSubscribers) ? eventSubscribers.slice() : [];
                };
            },

            handler: function handler(Class, key) {

                var proto = Class.prototype;

                /**
                 * Registers the event for particular event.
                 * @function
                 * @param {function} handler The handler function which should be invoked on event.
                 * @returns The current object.
                 * @example
                 * var btn = new Button();
                 * btn.mouseMove(function(){
                 *     console.log('mouse is moving');
                 * });
                 **/
                proto[key] = function (eventHandler) {
                    this.on(key, eventHandler);
                    return this;
                };

                proto[key].event = true;

                proto[key].importObject = function (o, k, v) {
                    o[k].call(o, v);
                };
            }
        });
    }

    plugin.info = {
        name: 'attributes'
    };

    FrameworkFactory.plugins.register(plugin);

})(this);


(function (root, undefined) {
    "use strict";

    var FrameworkFactory = root.FrameworkFactory;

    function plugin($f) {

        var readonly, property, handler;

        /**
         * Attaches the property to the given object. If setter is not specified creates reaonly property.
         * @param {Object} obj The object on which property has to be attached.
         * @param {string} key The key or name of the property.
         * @param {function} getter The getter function, this function will be called whenever get
         *        operation is required.
         * @param {function} setter The setter function, this function will be called whenever set
         *        operation is required. If this setter is missing, it will make the property readonly.
         *        And will throw an errror whenever property is set.
         * @public
         * @version 1.0
         **/
        function attachProperty(obj, key, getter, setter) {

            setter = setter || function () {
                throw new Error('Cannot assign to readonly property "' + key + '".');
            };

            if (Object.defineProperty) {
                Object.defineProperty(obj, key, {
                    enumerable: true,
                    configurable: true,
                    get: getter,
                    set: setter
                });
            }
            else if (obj.__defineGetter__ !== undefined) {
                obj.__defineGetter__(key, getter);
                obj.__defineSetter__(key, setter);
            }
            else {
                throw new Error("Properties are not supported in current environment.");
            }
        }

        function attachReadonly(obj, key, getter) {
            attachProperty(obj, key, getter);
        }

        /**
         * Attaches readonly member to associated class.
         */
        readonly = function readonly(options) {
            var get, value;

            if ($f.is.plainObject(options)) {
                value = options.value;
                if ($f.is.func(options.get)) {
                    get = options.get;
                }
            }
            else {
                value = options;
            }

            return {
                type            : 'readonly',
                value           : value,
                readonly        : true,
                get             : get,
                set             : undefined
            };
        };

        /**
         * While defining class, this function sets the member as
         * a property.
         * @param: defaultValue, the default value of property
         * @param: firePropertyChanged, if true,
         * @function
         * @public
         * @version 1.0.0
         **/
        property = function property(options) {

            var valueOf,
                value,
                get, set;

            if ($f.is.plainObject(options)) {
                value = options.value;
                get = options.get;
                set = options.set;

                //If get is provided but not set, return readonly version.
                if (get && !set) {
                    return readonly(options);
                }
            }
            else {
                value = options;
            }

            return {
                type : 'property',
                readonly : false,
                value : value,
                get : get,
                set : set
            };
        };

        handler = function (Class, key, options) {

            var proto       = Class.prototype, _get, _set,
                readonly    = options.readonly,
                getter      = options.get,
                setter      = options.set,
                privateKey     = '_' + key,
                value       = options.value;

            if (readonly) {
                if (getter !== undefined) {
                    _get = getter;
                }
                else {
                    _get = function () {
                        return this[privateKey];
                    };
                }
            }
            else {

                _get = getter || function () {
                    return this[privateKey];
                };

                _set = setter || function (v) {
                    this[privateKey] = v;
                };

            }

            if (value !== undefined) {
                proto[privateKey] = value;
            }

            attachProperty(proto, key, _get, _set);
        };

        $f.attachProperty = attachProperty;
        $f.attachReadonly = attachReadonly;
        $f.property     = property;
        $f.readonly     = readonly;

        FrameworkFactory.typeHandlers.register({
            type: "property",
            handler: handler
        });

        FrameworkFactory.typeHandlers.register({
            type: "readonly",
            handler: handler
        });

    }

    plugin.info = {
        name: 'properties'
    };

    FrameworkFactory.plugins.register(plugin);

})(this);

(function (root, undefined) {
    "use strict";

    var FrameworkFactory = root.FrameworkFactory;

    function _attachProperty(obj, key, getter, setter) {

        if (Object.defineProperty) {
            Object.defineProperty(obj, key, {
                enumerable: true,
                configurable: true,
                get: getter,
                set: setter
            });
        }
        else if (obj.__defineGetter__ !== undefined) {
            obj.__defineGetter__(key, getter);
            obj.__defineSetter__(key, setter);
        }
        else {
            throw new Error("Properties are not supported in current environment.");
        }
    }

    function observable (value) {
        return {
            type: 'observable',
            value: value
        };
    }


    function plugin($f) {

        $f.observable = observable;

        FrameworkFactory.typeHandlers.register({
            type: "observable",
            init: function (Class) {
                var proto = Class.prototype;

                proto.set = function set() {
                    var o = arguments[0],
                        key, privateKey, changed = {},
                        oldVal, newVal;

                    if (arguments.length === 1 && typeof(o) === "object") {
                        for(key in o) {
                            if (o.hasOwnProperty(key) === true && (this[key] !== o[key])) {
                                privateKey = "_" + key;
                                oldVal = this[key];
                                newVal = o[key];
                                this[privateKey] = newVal;
                                changed[key] = {
                                    oldValue: oldVal,
                                    newValue: newVal
                                };
                            }
                        }
                    }

                    else if (arguments.length === 2) {
                        key = arguments[0];
                        privateKey = "_" + key;
                        oldVal = this[key];
                        newVal = arguments[1];

                        if (oldVal !== newVal) {
                            this[privateKey] = newVal;
                            changed[key] = {
                                oldValue: oldVal,
                                newValue: newVal
                            };
                        }
                    }

                    this.onChange(changed);
                    return this;
                };

                proto.onChange = function onChange(changed) {
                    this.trigger("change", {
                        changed: changed
                    });
                    return this;
                };

                Class.attach({
                    change: $f.event()
                });

            },
            handler: function (Class, key, options) {
                var proto = Class.prototype,
                    privateKey = "_" + key,
                    get, set;

                proto[privateKey] = options.value;

                get = function get() {
                    return this[privateKey];
                };

                set = function set(v) {
                    var value = this[privateKey],
                        changed;

                    if (value !== v) {
                        this[privateKey] = v;
                        changed = {};
                        changed[key] = { oldValue: value, newValue: v };
                        this.onChange(changed);
                    }
                };
                _attachProperty(proto, key, get, set);
            }
        });

    }

    plugin.info = {
        name: 'observables'
    };

    FrameworkFactory.plugins.register(plugin);

})(this);
(function (global, undefined) {
    "use strict";

    var FrameworkFactory = global.FrameworkFactory;

    function plugin($f) {

        /**
         * Returns the cloned object created using deep copy algorithm.
         * @param o Object or anything that need to be cloned.
         * @returns The cloned object.
         * @ref: http://stackoverflow.com/questions/728360/copying-an-object-in-javascript
         * @thanks A. Levy
         * @remark:
         *  - Modified to handle circular dependencies.
         *  - May not behave as expected if object consturctor accepts various parameters.
         **/
        $f.clone = function clone(o) {
            // To improve performance, need to replace array with some sort of
            //hash map that accepts objects as key.
            var objRefs = [];

            function doCopy(obj) {

                var copy, i, iLen;

                if (objRefs.indexOf(obj) >= 0) {
                     //Object found, return the same object no need to copy it.
                    return obj;
                }
                else {
                    objRefs.push(obj);
                }
                // Handle the 3 simple types, and null or undefined
                if (null === obj || "object" !== typeof obj) {
                    return obj;
                }

                // Handle Date
                if (obj instanceof Date) {
                    copy = new Date();
                    copy.setTime(obj.getTime());
                    return copy;
                }

                // Handle Array
                if (obj instanceof Array) {
                    copy = [];
                    for (i = 0, iLen = obj.length; i < iLen; i += 1) {
                        copy[i] = doCopy(obj[i]);
                    }
                    return copy;
                }

                // Handle Object
                if (obj instanceof Object) {
                    copy = new obj.constructor();
                    for (var attr in obj) {
                        if (obj.hasOwnProperty(attr) === true) {
                            copy[attr] = doCopy(obj[attr]);
                        }
                    }
                    return copy;
                }
                throw new Error("Unable to copy obj! Its type isn't supported.");
            }
            return doCopy(o);
        };
    }

    plugin.info = {
        name: "clone",
        author: "Mohamed Aamir Maniar",
        version: "1.0"
    };

    plugin.toString = function toString() {
        return plugin.info.name;
    };

    FrameworkFactory.plugins.register(plugin);


})(this);

(function (global, undefined) {
    "use strict";

    function utils($f, config) {

        $f.utils = {

            /**
             * Checks whether both the objects are equals. Iterates through all the
             * members to check equality.
             * @function framework.utils.equals
             * @param o1 The first object
             * @param o2 The second object
             * @returns True if both the objects are equal, false if they are not.
             **/
            equals: function (o1, o2) {

                var key, v1, v2, i, iLen;

                // True if both objects references are same.
                if (o1 === o2) {
                    return true;
                }

                for (key in o1) {
                    //If key exists in o1 but not in o2, return false.
                    if (o2[key] === undefined) {
                        return false;
                    }

                    v1 = o1[key];
                    v2 = o2[key];

                    //Skip functions
                    if ($f.is.func(key)) {
                        continue;
                    }

                    if ($f.is.primitive(v1)) {
                        if (v1 instanceof Object) {
                            if (v1.toString() !== v2.toString()) {
                                return false;
                            }
                        }
                        else {
                            if (v1 !== v2) {
                                return false;
                            }
                        }
                    }
                    else if ($f.is.date(v1)) {
                        if (v1.getTime() !== v2.getTime()) {
                            return false;
                        }
                    }
                    else if ($f.is.array(v1)) {
                        for (i = 0, iLen = v1.length; i < iLen; i += 1) {
                            if ($f.utils.equals(v1[i], v2[i]) === false) {
                                return false;
                            }
                        }
                    }
                    else {
                        if ($f.utils.equals(v1, v2) === false) {
                            return false;
                        }
                    }
                }

                //If key exists in o2 but not in o1, returns false.
                for (key in o2) {
                    if (o1[key] === undefined) {
                        return false;
                    }
                }
                //Return true, becuase no differences found.
                return true;

            },


            /**
            * Returns the cloned object created using deep copy algorithm.
            * @param Object that need to be copied.
            * @returns Deep copied object. *
            * @ref: http://stackoverflow.com/questions/728360/copying-an-object-in-javascript
            * @remark:
            *  - Modified to handle circular dependencies.
            *  - May not behave as expected if object consturctor accepts various parameters.
            **/
            deepCopy: function deepCopy(o) {

                // To improve performance, need to replace array with some sort of
                //hash map that accepts objects as key.
                var objRefs = [];

                function doCopy(obj) {

                    var copy, i, iLen;

                    if (objRefs.indexOf(obj) >= 0) {
                         //Object found, return the same object no need to copy it.
                        return obj;
                    }
                    else {
                        objRefs.push(obj);
                    }
                    // Handle the 3 simple types, and null or undefined
                    if (null === obj || "object" !== typeof obj) {
                        return obj;
                    }

                    // Handle Date
                    if (obj instanceof Date) {
                        copy = new Date();
                        copy.setTime(obj.getTime());
                        return copy;
                    }

                    // Handle Array
                    if (obj instanceof Array) {
                        copy = [];
                        for (i = 0, iLen = obj.length; i < iLen; i += 1) {
                            copy[i] = doCopy(obj[i]);
                        }
                        return copy;
                    }

                    // Handle Object
                    if (obj instanceof Object) {
                        copy = new obj.constructor();
                        for (var attr in obj) {
                            if (obj.hasOwnProperty(attr) === true) {
                                copy[attr] = doCopy(obj[attr]);
                            }
                        }
                        return copy;
                    }
                    throw new Error("Unable to copy obj! Its type isn't supported.");
                }
                return doCopy(o);
            },

            importObject: function (o, json, options) {

                options = options || {};
                var key;

                for (key in json) {

                    //Check json object owns the member
                    if (json.hasOwnProperty(key) === true) {

                        //var propMemberType = typeof prop[key];
                        var oMemberType = typeof o[key];
                        var val = json[key];

                        switch (oMemberType) {
                        case 'object':
                            if (o[key] === null) {
                                o[key] = val;
                            }
                            else if (o[key].constructor.importObject !== undefined) {
                                o[key].constructor.importObject(o, key, val);
                            }
                            else if (o[key] instanceof Array) {
                                //Push the val to o[key].
                                //o[key].push.apply(o[key], val);
                                o[key] = val;
                            }
                            else {
                                $f.utils.importObject(o[key], val);
                            }
                            break;
                        case 'function':
                            if (o[key].importObject !== undefined) {
                                o[key].importObject(o, key, val);
                            }
                            else {
                                o[key] = val;
                            }
                            break;

                        default:
                            o[key] = val;
                        }
                    }
                }
            },

            //UUID
            simpleGuid: function(sep) {
                function section() {
                    return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
                }
                return (section()+section()+"-"+section()+"-"+section()+"-"+section()+"-"+section()+section()+section());
            },

            //Empty
            emptyFn: function(){},

            'undefined': undefined

        };

    }

    utils.info = {
        name: 'utils'
    };

    utils.toString = function toString() {
        return utils.info.name;
    };

    global.FrameworkFactory.plugins.register(utils);


})(this);

/*!
 * modernizr v3.0.0-alpha.3
 * Build http://v3.modernizr.com/download/#-applicationcache-audio-audioloop-audiopreload-blobconstructor-bloburls-blobworkers-canvas-canvasblending-canvastext-canvaswinding-customevent-dataworkers-draganddrop-json-localstorage-pointerlock-postmessage-proximity-queryselector-quotamanagement-sessionstorage-sharedworkers-smil-svg-svgasimg-svgclippaths-svgfilters-svgforeignobject-todataurljpeg_todataurlpng_todataurlwebp-touchevents-typedarrays-video-videoautoplay-videoloop-videopreload-webaudio-webgl-webglextensions-webworkers-xhrresponsetypearraybuffer-xhrresponsetypeblob-xhrresponsetypedocument-xhrresponsetypejson-xhrresponsetypetext-addtest-domprefixes-hasevent-mq-prefixed-prefixedcss-prefixes-testallprops-testprop-teststyles-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Alexander Farkas
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/

;(function(window, document, undefined){
  var classes = [];


  var tests = [];


  var ModernizrProto = {
    // The current version, dummy
    _version: '3.0.0-alpha.3',

    // Any settings that don't work as separate modules
    // can go in here as configuration.
    _config: {
      'classPrefix' : '',
      'enableClasses' : true,
      'enableJSClass' : true,
      'usePrefixes' : true
    },

    // Queue of tests
    _q: [],

    // Stub these for people who are listening
    on: function( test, cb ) {
      // I don't really think people should do this, but we can
      // safe guard it a bit.
      // -- NOTE:: this gets WAY overridden in src/addTest for
      // actual async tests. This is in case people listen to
      // synchronous tests. I would leave it out, but the code
      // to *disallow* sync tests in the real version of this
      // function is actually larger than this.
      var self = this;
      setTimeout(function() {
        cb(self[test]);
      }, 0);
    },

    addTest: function( name, fn, options ) {
      tests.push({name : name, fn : fn, options : options });
    },

    addAsyncTest: function (fn) {
      tests.push({name : null, fn : fn});
    }
  };



  // Fake some of Object.create
  // so we can force non test results
  // to be non "own" properties.
  var Modernizr = function(){};
  Modernizr.prototype = ModernizrProto;

  // Leak modernizr globally when you `require` it
  // rather than force it here.
  // Overwrite name so constructor name is nicer :D
  Modernizr = new Modernizr();


/*!
{
  "name": "Application Cache",
  "property": "applicationcache",
  "caniuse": "offline-apps",
  "tags": ["storage", "offline"],
  "notes": [{
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en/docs/HTML/Using_the_application_cache"
  }],
  "polyfills": ["html5gears"]
}
!*/
/* DOC
Detects support for the Application Cache, for storing data to enable web-based applications run offline.

The API has been [heavily criticized](http://alistapart.com/article/application-cache-is-a-douchebag) and discussions are underway to address this.
*/

  Modernizr.addTest('applicationcache', 'applicationCache' in window);

/*!
{
  "name": "Blob constructor",
  "property": "blobconstructor",
  "aliases": ["blob-constructor"],
  "builderAliases": ["blob_constructor"],
  "caniuse": "blobbuilder",
  "notes": [{
    "name": "W3C spec",
    "href": "http://dev.w3.org/2006/webapi/FileAPI/#constructorBlob"
  }],
  "polyfills": ["blobjs"]
}
!*/
/* DOC
Detects support for the Blob constructor, for creating file-like objects of immutable, raw data.
*/

  Modernizr.addTest('blobconstructor', function () {
    try {
      return !!new Blob();
    } catch (e) {
      return false;
    }
  }, {
    aliases: ['blob-constructor']
  });

/*!
{
  "name": "JSON",
  "property": "json",
  "caniuse": "json",
  "notes": [{
    "name": "MDN documentation",
    "href": "http://developer.mozilla.org/en/JSON"
  }],
  "polyfills": ["json2"]
}
!*/
/* DOC
Detects native support for JSON handling functions.
*/

  // this will also succeed if you've loaded the JSON2.js polyfill ahead of time
  //   ... but that should be obvious. :)

  Modernizr.addTest('json', 'JSON' in window && 'parse' in JSON && 'stringify' in JSON);

/*!
{
  "name": "CustomEvent",
  "property": "customevent",
  "tags": ["customevent"],
  "authors": ["Alberto Elias"],
  "notes": [{
    "name": "W3C DOM reference",
    "href": "http://www.w3.org/TR/DOM-Level-3-Events/#interface-CustomEvent"
  }, {
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en/docs/Web/API/CustomEvent"
  }],
  "polyfills": ["eventlistener"]
}
!*/
/* DOC

Detects support for CustomEvent.

*/

  Modernizr.addTest('customevent', 'CustomEvent' in window && typeof window.CustomEvent === 'function');

/*!
{
  "name": "postMessage",
  "property": "postmessage",
  "caniuse": "x-doc-messaging",
  "notes": [{
    "name": "W3C Spec",
    "href": "http://www.w3.org/TR/html5/comms.html#posting-messages"
  }],
  "polyfills": ["easyxdm", "postmessage-jquery"]
}
!*/
/* DOC
Detects support for the `window.postMessage` protocol for cross-document messaging.
*/

  Modernizr.addTest('postmessage', 'postMessage' in window);

/*!
{
  "name": "Local Storage",
  "property": "localstorage",
  "caniuse": "namevalue-storage",
  "tags": ["storage"],
  "knownBugs": [],
  "notes": [],
  "warnings": [],
  "polyfills": [
    "joshuabell-polyfill",
    "cupcake",
    "storagepolyfill",
    "amplifyjs",
    "yui-cacheoffline"
  ]
}
!*/

  // In FF4, if disabled, window.localStorage should === null.

  // Normally, we could not test that directly and need to do a
  //   `('localStorage' in window) && ` test first because otherwise Firefox will
  //   throw bugzil.la/365772 if cookies are disabled

  // Also in iOS5 Private Browsing mode, attempting to use localStorage.setItem
  // will throw the exception:
  //   QUOTA_EXCEEDED_ERRROR DOM Exception 22.
  // Peculiarly, getItem and removeItem calls do not throw.

  // Because we are forced to try/catch this, we'll go aggressive.

  // Just FWIW: IE8 Compat mode supports these features completely:
  //   www.quirksmode.org/dom/html5.html
  // But IE8 doesn't support either with local files

  Modernizr.addTest('localstorage', function() {
    var mod = 'modernizr';
    try {
      localStorage.setItem(mod, mod);
      localStorage.removeItem(mod);
      return true;
    } catch(e) {
      return false;
    }
  });

/*!
{
  "name": "QuerySelector",
  "property": "queryselector",
  "caniuse": "queryselector",
  "tags": ["queryselector"],
  "authors": ["Andrew Betts (@triblondon)"],
  "notes": [{
    "name" : "W3C Selectors reference",
    "href": "http://www.w3.org/TR/selectors-api/#queryselectorall"
  }],
  "polyfills": ["css-selector-engine"]
}
!*/
/* DOC
Detects support for querySelector.
*/

  Modernizr.addTest('queryselector', 'querySelector' in document && 'querySelectorAll' in document);

/*!
{
  "name": "Shared Workers",
  "property": "sharedworkers",
  "caniuse" : "sharedworkers",
  "tags": ["performance", "workers"],
  "builderAliases": ["workers_sharedworkers"],
  "notes": [{
    "name": "W3C Reference",
    "href": "http://www.w3.org/TR/workers/"
  }]
}
!*/
/* DOC
Detects support for the `SharedWorker` API from the Web Workers spec.
*/

  Modernizr.addTest('sharedworkers', 'SharedWorker' in window);

/*!
{
  "name": "SVG filters",
  "property": "svgfilters",
  "caniuse": "svg-filters",
  "tags": ["svg"],
  "builderAliases": ["svg_filters"],
  "authors": ["Erik Dahlstrom"],
  "notes": [{
    "name": "W3C Spec",
    "href": "http://www.w3.org/TR/SVG11/filters.html"
  }]
}
!*/

  // Should fail in Safari: http://stackoverflow.com/questions/9739955/feature-detecting-support-for-svg-filters.
  Modernizr.addTest('svgfilters', function() {
    var result = false;
    try {
      result = 'SVGFEColorMatrixElement' in window &&
        SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE == 2;
    }
    catch(e) {}
    return result;
  });

/*!
{
  "name": "Session Storage",
  "property": "sessionstorage",
  "tags": ["storage"],
  "polyfills": ["joshuabell-polyfill", "cupcake", "sessionstorage"]
}
!*/

  // Because we are forced to try/catch this, we'll go aggressive.

  // Just FWIW: IE8 Compat mode supports these features completely:
  //   www.quirksmode.org/dom/html5.html
  // But IE8 doesn't support either with local files
  Modernizr.addTest('sessionstorage', function() {
    var mod = 'modernizr';
    try {
      sessionStorage.setItem(mod, mod);
      sessionStorage.removeItem(mod);
      return true;
    } catch(e) {
      return false;
    }
  });

/*!
{
  "name": "SVG",
  "property": "svg",
  "caniuse": "svg",
  "tags": ["svg"],
  "authors": ["Erik Dahlstrom"],
  "polyfills": [
    "svgweb",
    "raphael",
    "amplesdk",
    "canvg",
    "svg-boilerplate",
    "sie",
    "dojogfx",
    "fabricjs"
  ]
}
!*/
/* DOC
Detects support for SVG in `<embed>` or `<object>` elements.
*/

  Modernizr.addTest('svg', !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);

/*!
{
  "name": "Web Audio API",
  "property": "webaudio",
  "caniuse": "audio-api",
  "polyfills": ["xaudiojs", "dynamicaudiojs", "audiolibjs"],
  "tags": ["audio", "media"],
  "builderAliases": ["audio_webaudio_api"],
  "authors": ["Addy Osmani"],
  "notes": [{
    "name": "W3 Specification",
    "href": "https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html"
  }]
}
!*/
/* DOC
Detects the older non standard webaudio API, (as opposed to the standards based AudioContext API)
*/

  Modernizr.addTest('webaudio', function() {
    var prefixed = 'webkitAudioContext' in window;
    var unprefixed = 'AudioContext' in window;

    if (Modernizr._config.usePrefixes) return prefixed || unprefixed;
    return unprefixed;
  });

/*!
{
  "name": "Web Workers",
  "property": "webworkers",
  "caniuse" : "webworkers",
  "tags": ["performance", "workers"],
  "notes": [{
    "name": "W3C Reference",
    "href": "http://www.w3.org/TR/workers/"
  }, {
    "name": "HTML5 Rocks article",
    "href": "http://www.html5rocks.com/en/tutorials/workers/basics/"
  }, {
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers"
  }],
  "polyfills": ["fakeworker", "html5shims"]
}
!*/
/* DOC
Detects support for the basic `Worker` API from the Web Workers spec. Web Workers provide a simple means for web content to run scripts in background threads.
*/

  Modernizr.addTest('webworkers', 'Worker' in window);

/*!
{
  "name": "Typed arrays",
  "property": "typedarrays",
  "caniuse": "typedarrays",
  "tags": ["js"],
  "authors": ["Stanley Stuart (@fivetanley)"],
  "notes": [{
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays"
  },{
    "name": "Kronos spec",
    "href": "http://www.khronos.org/registry/typedarray/specs/latest/"
  }],
  "polyfills": ["joshuabell-polyfill"]
}
!*/
/* DOC
Detects support for native binary data manipulation via Typed Arrays in JavaScript.

Does not check for DataView support; use `Modernizr.dataview` for that.
*/

  // Should fail in:
  // Internet Explorer <= 9
  // Firefox <= 3.6
  // Chrome <= 6.0
  // iOS Safari < 4.2
  // Safari < 5.1
  // Opera < 11.6
  // Opera Mini, <= 7.0
  // Android Browser < 4.0
  // Blackberry Browser < 10.0

  Modernizr.addTest('typedarrays', 'ArrayBuffer' in window );


  // List of property values to set for css tests. See ticket #21
  var prefixes = (ModernizrProto._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : []);

  // expose these for the plugin API. Look in the source for how to join() them against your input
  ModernizrProto._prefixes = prefixes;



  var docElement = document.documentElement;


  // Pass in an and array of class names, e.g.:
  //  ['no-webp', 'borderradius', ...]
  function setClasses( classes ) {
    var className = docElement.className;
    var classPrefix = Modernizr._config.classPrefix || '';

    // Change `no-js` to `js` (we do this independently of the `enableClasses`
    // option)
    // Handle classPrefix on this too
    if(Modernizr._config.enableJSClass) {
      var reJS = new RegExp('(^|\\s)'+classPrefix+'no-js(\\s|$)');
      className = className.replace(reJS, '$1'+classPrefix+'js$2');
    }

    if(Modernizr._config.enableClasses) {
      // Add the new classes
      className += ' ' + classPrefix + classes.join(' ' + classPrefix);
      docElement.className = className;
    }

  }

  ;

  // Helper function for converting camelCase to kebab-case,
  // e.g. boxSizing -> box-sizing
  function domToCSS( name ) {
    return name.replace(/([A-Z])/g, function(str, m1) {
      return '-' + m1.toLowerCase();
    }).replace(/^ms-/, '-ms-');
  }
  ;

  var createElement = function() {
    if (typeof document.createElement !== 'function') {
      // This is the case in IE7, where the type of createElement is "object".
      // For this reason, we cannot call apply() as Object is not a Function.
      return document.createElement(arguments[0]);
    } else {
      return document.createElement.apply(document, arguments);
    }
  };

/*!
{
  "name": "Audio Loop Attribute",
  "property": "audioloop",
  "tags": ["audio", "media"]
}
!*/
/* DOC
Detects if an audio element can automatically restart, once it has finished
*/

  Modernizr.addTest('audioloop', 'loop' in createElement('audio'));

/*!
{
  "name": "Canvas",
  "property": "canvas",
  "caniuse": "canvas",
  "tags": ["canvas", "graphics"],
  "polyfills": ["flashcanvas", "excanvas", "slcanvas", "fxcanvas"]
}
!*/
/* DOC
Detects support for the `<canvas>` element for 2D drawing.
*/

  // On the S60 and BB Storm, getContext exists, but always returns undefined
  // so we actually have to call getContext() to verify
  // github.com/Modernizr/Modernizr/issues/issue/97/
  Modernizr.addTest('canvas', function() {
    var elem = createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d'));
  });

/*!
{
  "name": "Audio Preload Attribute",
  "property": "audiopreload",
  "tags": ["audio", "media"]
}
!*/
/* DOC
Detects if audio can be downloaded in the background before it starts playing in the `<audio>` element
*/

  Modernizr.addTest('audiopreload', 'preload' in createElement('audio'));

/*!
{
  "name": "canvas blending support",
  "property": "canvasblending",
  "tags": ["canvas"],
  "async" : false,
  "notes": [{
      "name": "HTML5 Spec",
      "href": "https://dvcs.w3.org/hg/FXTF/rawfile/tip/compositing/index.html#blending"
    },
    {
      "name": "Article",
      "href": "http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas"
    }]
}
!*/
/* DOC
Detects if Photoshop style blending modes are available in canvas.
*/


  Modernizr.addTest('canvasblending', function() {
    if (Modernizr.canvas === false) return false;
    var ctx = createElement('canvas').getContext('2d');

    ctx.globalCompositeOperation = 'screen';
    return ctx.globalCompositeOperation === 'screen';
  });


/*!
{
  "name": "canvas winding support",
  "property": ["canvaswinding"],
  "tags": ["canvas"],
  "async" : false,
  "notes": [{
    "name": "Article",
    "href": "http://blogs.adobe.com/webplatform/2013/01/30/winding-rules-in-canvas/"
  }]
}
!*/
/* DOC
Determines if winding rules, which controls if a path can go clockwise or counterclockwise
*/


  Modernizr.addTest('canvaswinding', function() {
    if (Modernizr.canvas === false) return false;
    var ctx = createElement('canvas').getContext('2d');

    ctx.rect(0, 0, 10, 10);
    ctx.rect(2, 2, 6, 6);
    return ctx.isPointInPath(5, 5, 'evenodd') === false;
  });


/*!
{
  "name": "Canvas text",
  "property": "canvastext",
  "caniuse": "canvas-text",
  "tags": ["canvas", "graphics"],
  "polyfills": ["canvastext"]
}
!*/
/* DOC
Detects support for the text APIs for `<canvas>` elements.
*/

  Modernizr.addTest('canvastext',  function() {
    if (Modernizr.canvas  === false) return false;
    return typeof createElement('canvas').getContext('2d').fillText == 'function';
  });

/*!
{
  "name": "canvas.toDataURL type support",
  "property": ["todataurljpeg", "todataurlpng", "todataurlwebp"],
  "tags": ["canvas"],
  "builderAliases": ["canvas_todataurl_type"],
  "async" : false,
  "notes": [{
    "name": "MDN article",
    "href": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement.toDataURL"
  }]
}
!*/


  var canvas = createElement('canvas');

  Modernizr.addTest('todataurljpeg', function() {
    return !!Modernizr.canvas && canvas.toDataURL('image/jpeg').indexOf('data:image/jpeg') === 0;
  });
  Modernizr.addTest('todataurlpng', function() {
    return !!Modernizr.canvas && canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
  });
  Modernizr.addTest('todataurlwebp', function() {
    return !!Modernizr.canvas && canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
  });


/*!
{
  "name": "Drag & Drop",
  "property": "draganddrop",
  "caniuse": "dragndrop",
  "knownBugs": ["Mobile browsers like Android, iOS < 6, and Firefox OS technically support the APIs, but don't expose it to the end user, resulting in a false positive."],
  "notes": [{
    "name": "W3C spec",
    "href": "http://www.w3.org/TR/2010/WD-html5-20101019/dnd.html"
  }],
  "polyfills": ["dropfile", "moxie", "fileapi"]
}
!*/
/* DOC
Detects support for native drag & drop of elements.
*/

  Modernizr.addTest('draganddrop', function() {
    var div = createElement('div');
    return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
  });

/*!
{
  "name": "HTML5 Video",
  "property": "video",
  "caniuse": "video",
  "tags": ["html5"],
  "knownBugs": [
    "Without QuickTime, `Modernizr.video.h264` will be `undefined`; http://github.com/Modernizr/Modernizr/issues/546"
  ],
  "polyfills": [
    "html5media",
    "mediaelementjs",
    "sublimevideo",
    "videojs",
    "leanbackplayer",
    "videoforeverybody"
  ]
}
!*/
/* DOC
Detects support for the video element, as well as testing what types of content it supports.

Subproperties are provided to describe support for `ogg`, `h264` and `webm` formats, e.g.:

```javascript
Modernizr.video         // true
Modernizr.video.ogg     // 'probably'
```
*/

  // Codec values from : github.com/NielsLeenheer/html5test/blob/9106a8/index.html#L845
  //                     thx to NielsLeenheer and zcorpan

  // Note: in some older browsers, "no" was a return value instead of empty string.
  //   It was live in FF3.5.0 and 3.5.1, but fixed in 3.5.2
  //   It was also live in Safari 4.0.0 - 4.0.4, but fixed in 4.0.5

  Modernizr.addTest('video', function() {
    /* jshint -W053 */
    var elem = createElement('video');
    var bool = false;

    // IE9 Running on Windows Server SKU can cause an exception to be thrown, bug #224
    try {
      if ( bool = !!elem.canPlayType ) {
        bool = new Boolean(bool);
        bool.ogg = elem.canPlayType('video/ogg; codecs="theora"').replace(/^no$/,'');

        // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
        bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/,'');

        bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,'');

        bool.vp9 = elem.canPlayType('video/webm; codecs="vp9"').replace(/^no$/,'');

        bool.hls = elem.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/,'');
      }
    } catch(e){}

    return bool;
  });

/*!
{
  "name" : "HTML5 Audio Element",
  "property": "audio",
  "tags" : ["html5", "audio", "media"]
}
!*/
/* DOC
Detects the audio element
*/

  // This tests evaluates support of the audio element, as well as
  // testing what types of content it supports.
  //
  // We're using the Boolean constructor here, so that we can extend the value
  // e.g.  Modernizr.audio     // true
  //       Modernizr.audio.ogg // 'probably'
  //
  // Codec values from : github.com/NielsLeenheer/html5test/blob/9106a8/index.html#L845
  //                     thx to NielsLeenheer and zcorpan

  // Note: in some older browsers, "no" was a return value instead of empty string.
  //   It was live in FF3.5.0 and 3.5.1, but fixed in 3.5.2
  //   It was also live in Safari 4.0.0 - 4.0.4, but fixed in 4.0.5
  Modernizr.addTest('audio', function() {
    /* jshint -W053 */
    var elem = createElement('audio');
    var bool = false;

    try {
      if ( bool = !!elem.canPlayType ) {
        bool      = new Boolean(bool);
        bool.ogg  = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,'');
        bool.mp3  = elem.canPlayType('audio/mpeg;')               .replace(/^no$/,'');
        bool.opus  = elem.canPlayType('audio/ogg; codecs="opus"') .replace(/^no$/,'');

        // Mimetypes accepted:
        //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
        //   bit.ly/iphoneoscodecs
        bool.wav  = elem.canPlayType('audio/wav; codecs="1"')     .replace(/^no$/,'');
        bool.m4a  = ( elem.canPlayType('audio/x-m4a;')            ||
                     elem.canPlayType('audio/aac;'))             .replace(/^no$/,'');
      }
    } catch(e) { }

    return bool;
  });

/*!
{
  "name": "Video Loop Attribute",
  "property": "videoloop",
  "tags": ["video", "media"]
}
!*/

  Modernizr.addTest('videoloop', 'loop' in createElement('video'));

/*!
{
  "name": "Video Preload Attribute",
  "property": "videopreload",
  "tags": ["video", "media"]
}
!*/

  Modernizr.addTest('videopreload', 'preload' in createElement('video'));

/*!
{
  "name": "WebGL",
  "property": "webgl",
  "caniuse": "webgl",
  "tags": ["webgl", "graphics"],
  "polyfills": ["jebgl", "cwebgl", "iewebgl"]
}
!*/

  Modernizr.addTest('webgl', function() {
    var canvas = createElement('canvas');
    var supports = 'probablySupportsContext' in canvas ? 'probablySupportsContext' :  'supportsContext';
    if (supports in canvas) {
      return canvas[supports]('webgl') || canvas[supports]('experimental-webgl');
    }
    return 'WebGLRenderingContext' in window;
  });

/*!
{
  "name": "WebGL Extensions",
  "property": "webglextensions",
  "tags": ["webgl", "graphics"],
  "builderAliases": ["webgl_extensions"],
  "async" : true,
  "authors": ["Ilmari Heikkinen"],
  "knownBugs": [],
  "notes": [{
    "name": "Kronos extensions registry",
    "href": "http://www.khronos.org/registry/webgl/extensions/"
  }]
}
!*/
/* DOC
Detects support for OpenGL extensions in WebGL. It's `true` if the [WebGL extensions API](https://developer.mozilla.org/en-US/docs/Web/WebGL/Using_Extensions) is supported, then exposes the supported extensions as subproperties, e.g.:

```javascript
if (Modernizr.webglextensions) {
  // WebGL extensions API supported
}
if ('OES_vertex_array_object' in Modernizr.webglextensions) {
  // Vertex Array Objects extension supported
}
```
*/

  // based on code from ilmari heikkinen
  // code.google.com/p/graphics-detect/source/browse/js/detect.js

  // Not Async but handles it's own self
  Modernizr.addAsyncTest(function() {
    /* jshint -W053 */

    // Not a good candidate for css classes, so we avoid addTest stuff
    Modernizr.webglextensions = new Boolean(false);

    if (!Modernizr.webgl) {
      return;
    }

    var canvas;
    var ctx;
    var exts;

    try {
      canvas = createElement('canvas');
      ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      exts = ctx.getSupportedExtensions();
    }
    catch (e) {
      return;
    }

    if (ctx !== undefined) {
      Modernizr.webglextensions = new Boolean(true);
    }

    for (var i = -1, len = exts.length; ++i < len; ){
      Modernizr.webglextensions[exts[i]] = true;
    }

    canvas = undefined;
  });


  // isEventSupported determines if the given element supports the given event
  // kangax.github.com/iseventsupported/
  // github.com/Modernizr/Modernizr/pull/636
  //
  // Known incorrects:
  //   Modernizr.hasEvent("webkitTransitionEnd", elem) // false negative
  //   Modernizr.hasEvent("textInput") // in Webkit. github.com/Modernizr/Modernizr/issues/333
  var isEventSupported = (function (undefined) {

    // Detect whether event support can be detected via `in`. Test on a DOM element
    // using the "blur" event b/c it should always exist. bit.ly/event-detection
    var needsFallback = !('onblur' in document.documentElement);

    /**
     * @param  {string|*}           eventName  is the name of an event to test for (e.g. "resize")
     * @param  {(Object|string|*)=} element    is the element|document|window|tagName to test on
     * @return {boolean}
     */
    function isEventSupportedInner( eventName, element ) {

      var isSupported;
      if ( !eventName ) { return false; }
      if ( !element || typeof element === 'string' ) {
        element = createElement(element || 'div');
      }

      // Testing via the `in` operator is sufficient for modern browsers and IE.
      // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and
      // "resize", whereas `in` "catches" those.
      eventName = 'on' + eventName;
      isSupported = eventName in element;

      // Fallback technique for old Firefox - bit.ly/event-detection
      if ( !isSupported && needsFallback ) {
        if ( !element.setAttribute ) {
          // Switch to generic element if it lacks `setAttribute`.
          // It could be the `document`, `window`, or something else.
          element = createElement('div');
        }

        element.setAttribute(eventName, '');
        isSupported = typeof element[eventName] === 'function';

        if ( element[eventName] !== undefined ) {
          // If property was created, "remove it" by setting value to `undefined`.
          element[eventName] = undefined;
        }
        element.removeAttribute(eventName);
      }

      return isSupported;
    }
    return isEventSupportedInner;
  })();



  // Modernizr.hasEvent() detects support for a given event, with an optional element to test on
  // Modernizr.hasEvent('gesturestart', elem)
  var hasEvent = ModernizrProto.hasEvent = isEventSupported;


  // Helper function for converting kebab-case to camelCase,
  // e.g. box-sizing -> boxSizing
  function cssToDOM( name ) {
    return name.replace(/([a-z])-([a-z])/g, function(str, m1, m2) {
      return m1 + m2.toUpperCase();
    }).replace(/^-/, '');
  }
  ;

  // Following spec is to expose vendor-specific style properties as:
  //   elem.style.WebkitBorderRadius
  // and the following would be incorrect:
  //   elem.style.webkitBorderRadius

  // Webkit ghosts their properties in lowercase but Opera & Moz do not.
  // Microsoft uses a lowercase `ms` instead of the correct `Ms` in IE8+
  //   erik.eae.net/archives/2008/03/10/21.48.10/

  // More here: github.com/Modernizr/Modernizr/issues/issue/21
  var omPrefixes = 'Moz O ms Webkit';


  var domPrefixes = (ModernizrProto._config.usePrefixes ? omPrefixes.toLowerCase().split(' ') : []);
  ModernizrProto._domPrefixes = domPrefixes;


  var toStringFn = ({}).toString;

/*!
{
  "name": "SVG clip paths",
  "property": "svgclippaths",
  "tags": ["svg"],
  "notes": [{
    "name": "Demo",
    "href": "http://srufaculty.sru.edu/david.dailey/svg/newstuff/clipPath4.svg"
  }]
}
!*/
/* DOC
Detects support for clip paths in SVG (only, not on HTML content).

See [this discussion](http://github.com/Modernizr/Modernizr/issues/213) regarding applying SVG clip paths to HTML content.
*/

  Modernizr.addTest('svgclippaths', function() {
    return !!document.createElementNS &&
      /SVGClipPath/.test(toStringFn.call(document.createElementNS('http://www.w3.org/2000/svg', 'clipPath')));
  });

/*!
{
  "name": "SVG foreignObject",
  "property": "svgforeignobject",
  "tags": ["svg"],
  "notes": [{
    "name": "W3C Spec",
    "href": "http://www.w3.org/TR/SVG11/extend.html"
  }]
}
!*/
/* DOC
Detects support for foreignObject tag in SVG.
*/

  Modernizr.addTest('svgforeignobject', function() {
    return !!document.createElementNS &&
      /SVGForeignObject/.test(toStringFn.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));
  });

/*!
{
  "name": "SVG SMIL animation",
  "property": "smil",
  "caniuse": "svg-smil",
  "tags": ["svg"],
  "notes": [{
  "name": "W3C Synchronised Multimedia spec",
  "href": "http://www.w3.org/AudioVideo/"
  }]
}
!*/

  // SVG SMIL animation
  Modernizr.addTest('smil', function() {
    return !!document.createElementNS &&
      /SVGAnimate/.test(toStringFn.call(document.createElementNS('http://www.w3.org/2000/svg', 'animate')));
  });


  /**
   * is returns a boolean for if typeof obj is exactly type.
   */
  function is( obj, type ) {
    return typeof obj === type;
  }
  ;

  // Run through all tests and detect their support in the current UA.
  function testRunner() {
    var featureNames;
    var feature;
    var aliasIdx;
    var result;
    var nameIdx;
    var featureName;
    var featureNameSplit;

    for ( var featureIdx in tests ) {
      featureNames = [];
      feature = tests[featureIdx];
      // run the test, throw the return value into the Modernizr,
      //   then based on that boolean, define an appropriate className
      //   and push it into an array of classes we'll join later.
      //
      //   If there is no name, it's an 'async' test that is run,
      //   but not directly added to the object. That should
      //   be done with a post-run addTest call.
      if ( feature.name ) {
        featureNames.push(feature.name.toLowerCase());

        if (feature.options && feature.options.aliases && feature.options.aliases.length) {
          // Add all the aliases into the names list
          for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
            featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
          }
        }
      }

      // Run the test, or use the raw value if it's not a function
      result = is(feature.fn, 'function') ? feature.fn() : feature.fn;


      // Set each of the names on the Modernizr object
      for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
        featureName = featureNames[nameIdx];
        // Support dot properties as sub tests. We don't do checking to make sure
        // that the implied parent tests have been added. You must call them in
        // order (either in the test, or make the parent test a dependency).
        //
        // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
        // hashtag famous last words
        featureNameSplit = featureName.split('.');

        if (featureNameSplit.length === 1) {
          Modernizr[featureNameSplit[0]] = result;
        } else {
          // cast to a Boolean, if not one already
          /* jshint -W053 */
          if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
            Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
          }

          Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
        }

        classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
      }
    }
  }

  ;

  // hasOwnProperty shim by kangax needed for Safari 2.0 support
  var hasOwnProp;

  (function() {
    var _hasOwnProperty = ({}).hasOwnProperty;
    /* istanbul ignore else */
    /* we have no way of testing IE 5.5 or safari 2,
     * so just assume the else gets hit */
    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { /* yes, this can give false positives/negatives, but most of the time we don't care about those */
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }
  })();



  // As far as I can think of, we shouldn't need or
  // allow 'on' for non-async tests, and you can't do
  // async tests without this 'addTest' module.

  // Listeners for async or post-run tests
  ModernizrProto._l = {};

  // 'addTest' implies a test after the core runloop,
  // So we'll add in the events
  ModernizrProto.on = function( test, cb ) {
    // Create the list of listeners if it doesn't exist
    if (!this._l[test]) {
      this._l[test] = [];
    }

    // Push this test on to the listener list
    this._l[test].push(cb);

    // If it's already been resolved, trigger it on next tick
    if (Modernizr.hasOwnProperty(test)) {
      // Next Tick
      setTimeout(function() {
        Modernizr._trigger(test, Modernizr[test]);
      }, 0);
    }
  };

  ModernizrProto._trigger = function( test, res ) {
    if (!this._l[test]) {
      return;
    }

    var cbs = this._l[test];

    // Force async
    setTimeout(function() {
      var i, cb;
      for (i = 0; i < cbs.length; i++) {
        cb = cbs[i];
        cb(res);
      }
    },0);

    // Don't trigger these again
    delete this._l[test];
  };

  /**
   * addTest allows the user to define their own feature tests
   * the result will be added onto the Modernizr object,
   * as well as an appropriate className set on the html element
   *
   * @param feature - String naming the feature
   * @param test - Function returning true if feature is supported, false if not
   */
  function addTest( feature, test ) {
    if ( typeof feature == 'object' ) {
      for ( var key in feature ) {
        if ( hasOwnProp( feature, key ) ) {
          addTest( key, feature[ key ] );
        }
      }
    } else {

      feature = feature.toLowerCase();
      var featureNameSplit = feature.split('.');
      var last = Modernizr[featureNameSplit[0]];

      // Again, we don't check for parent test existence. Get that right, though.
      if (featureNameSplit.length == 2) {
        last = last[featureNameSplit[1]];
      }

      if ( typeof last != 'undefined' ) {
        // we're going to quit if you're trying to overwrite an existing test
        // if we were to allow it, we'd do this:
        //   var re = new RegExp("\\b(no-)?" + feature + "\\b");
        //   docElement.className = docElement.className.replace( re, '' );
        // but, no rly, stuff 'em.
        return Modernizr;
      }

      test = typeof test == 'function' ? test() : test;

      // Set the value (this is the magic, right here).
      if (featureNameSplit.length == 1) {
        Modernizr[featureNameSplit[0]] = test;
      } else {
        // cast to a Boolean, if not one already
        /* jshint -W053 */
        if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
          Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
        }

        Modernizr[featureNameSplit[0]][featureNameSplit[1]] = test;
      }

      // Set a single class (either `feature` or `no-feature`)
      /* jshint -W041 */
      setClasses([(!!test && test != false ? '' : 'no-') + featureNameSplit.join('-')]);
      /* jshint +W041 */

      // Trigger the event
      Modernizr._trigger(feature, test);
    }

    return Modernizr; // allow chaining.
  }

  // After all the tests are run, add self
  // to the Modernizr prototype
  Modernizr._q.push(function() {
    ModernizrProto.addTest = addTest;
  });


/*!
{
  "name": "SVG as an <img> tag source",
  "property": "svgasimg",
  "caniuse" : "svg-img",
  "tags": ["svg"],
  "authors": ["Chris Coyier"],
  "notes": [{
    "name": "HTML5 Spec",
    "href": "http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element"
  }]
}
!*/


  // Original Async test by Stu Cox
  // https://gist.github.com/chriscoyier/8774501

  // Now a Sync test based on good results here
  // http://codepen.io/chriscoyier/pen/bADFx

  // Note http://www.w3.org/TR/SVG11/feature#Image is *supposed* to represent
  // support for the `<image>` tag in SVG, not an SVG file linked from an `<img>`
  // tag in HTML – but it’s a heuristic which works
  Modernizr.addTest('svgasimg', document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1'));

/*!
{
  "authors": ["Cătălin Mariș"],
  "caniuse": "proximity",
  "name": "Proximity API",
  "notes": [{
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en-US/docs/Web/API/Proximity_Events"
  },{
    "name": "W3C specification",
    "href": "http://www.w3.org/TR/proximity/"
  }],
  "property": "proximity",
  "tags": ["events", "proximity"]
}
!*/
/* DOC
Detects support for an API that allows users to get proximity related information from the device's proximity sensor.
*/


  Modernizr.addAsyncTest(function () {

    var timeout;
    var timeoutTime = 300;

    function advertiseSupport() {

      // Clean up after ourselves
      clearTimeout(timeout);
      window.removeEventListener('deviceproximity', advertiseSupport);

      // Advertise support as the browser supports
      // the API and the device has a proximity sensor
      addTest('proximity', true);

    }

    // Check if the browser has support for the API
    if ( 'ondeviceproximity' in window && 'onuserproximity' in window ) {

      // Check if the device has a proximity sensor
      // ( devices without such a sensor support the events but
      //   will never fire them resulting in a false positive )
      window.addEventListener('deviceproximity', advertiseSupport);

      // If the event doesn't fire in a reasonable amount of time,
      // it means that the device doesn't have a proximity sensor,
      // thus, we can advertise the "lack" of support
      timeout = setTimeout(function() {
        window.removeEventListener('deviceproximity', advertiseSupport);
        addTest('proximity', false);
      }, timeoutTime);

    } else {
      addTest('proximity', false);
    }

  });


/*!
{
  "name": "Workers from Blob URIs",
  "property": "blobworkers",
  "tags": ["performance", "workers"],
  "builderAliases": ["workers_blobworkers"],
  "notes": [{
    "name": "W3C Reference",
    "href": "http://www.w3.org/TR/workers/"
  }],
  "knownBugs": ["This test may output garbage to console."],
  "authors": ["Jussi Kalliokoski"],
  "async": true
}
!*/
/* DOC
Detects support for creating Web Workers from Blob URIs.
*/

  Modernizr.addAsyncTest(function() {
    try {
      // we're avoiding using Modernizr._domPrefixes as the prefix capitalization on
      // these guys are notoriously peculiar.
      var BlobBuilder = window.BlobBuilder;
      var URL         = window.URL;
      if (Modernizr._config.usePrefix) {
        BlobBuilder = BlobBuilder || window.MozBlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder || window.OBlobBuilder;
        URL         = URL || window.MozURL || window.webkitURL || window.MSURL || window.OURL;
      }
      var data    = 'Modernizr',
          blob,
          bb,
          worker,
          url,
          timeout,
          scriptText = 'this.onmessage=function(e){postMessage(e.data)}';

      try {
        blob = new Blob([scriptText], {type:'text/javascript'});
      } catch(e) {
        // we'll fall back to the deprecated BlobBuilder
      }
      if (!blob) {
        bb = new BlobBuilder();
        bb.append(scriptText);
        blob = bb.getBlob();
      }

      url = URL.createObjectURL(blob);
      worker = new Worker(url);

      worker.onmessage = function(e) {
        addTest('blobworkers', data === e.data);
        cleanup();
      };

      // Just in case...
      worker.onerror = fail;
      timeout = setTimeout(fail, 200);

      worker.postMessage(data);
    } catch (e) {
      fail();
    }

    function fail() {
      addTest('blobworkers', false);
      cleanup();
    }

    function cleanup() {
      if (url) {
        URL.revokeObjectURL(url);
      }
      if (worker) {
        worker.terminate();
      }
      if (timeout) {
        clearTimeout(timeout);
      }
    }
  });

/*!
{
  "name": "Workers from Data URIs",
  "property": "dataworkers",
  "tags": ["performance", "workers"],
  "builderAliases": ["workers_dataworkers"],
  "notes": [{
    "name": "W3C Reference",
    "href": "http://www.w3.org/TR/workers/"
  }],
  "knownBugs": ["This test may output garbage to console."],
  "authors": ["Jussi Kalliokoski"],
  "async": true
}
!*/
/* DOC
Detects support for creating Web Workers from Data URIs.
*/

  Modernizr.addAsyncTest(function() {
    try {
      var data    = 'Modernizr',
      worker  = new Worker('data:text/javascript;base64,dGhpcy5vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7cG9zdE1lc3NhZ2UoZS5kYXRhKX0=');

      worker.onmessage = function(e) {
        worker.terminate();
        addTest('dataworkers', data === e.data);
        worker = null;
      };

      // Just in case...
      worker.onerror = function() {
        addTest('dataworkers', false);
        worker = null;
      };

      setTimeout(function() {
        addTest('dataworkers', false);
      }, 200);

      worker.postMessage(data);
    } catch (e) {
      setTimeout(function () {
        addTest('dataworkers', false);
      }, 0);
    }
  });

/*!
{
  "name": "Video Autoplay",
  "property": "videoautoplay",
  "tags": ["video"],
  "async" : true,
  "warnings": ["This test is very large – only include it if you absolutely need it"],
  "knownBugs": ["crashes with an alert on iOS7 when added to homescreen"]
}
!*/
/* DOC
Checks for support of the autoplay attribute of the video element.
*/


  Modernizr.addAsyncTest(function() {
    var timeout;
    var waitTime = 300;
    var elem = createElement('video');
    var elemStyle = elem.style;
    var testAutoplay = function(arg) {
      clearTimeout(timeout);
      elem.removeEventListener('playing', testAutoplay);
      addTest('videoautoplay', arg && arg.type === 'playing' || elem.currentTime !== 0);
      elem.parentNode.removeChild(elem);
    };

    //skip the test if video itself, or the autoplay
    //element on it isn't supported
    if (!Modernizr.video || !('autoplay' in elem)) {
      addTest('videoautoplay', false);
      return;
    }

    elemStyle.position = 'absolute';
    elemStyle.height = 0;
    elemStyle.width = 0;

    try {
      if (Modernizr.video.ogg) {
        elem.src = 'data:video/ogg;base64,T2dnUwACAAAAAAAAAABmnCATAAAAAHDEixYBKoB0aGVvcmEDAgEAAQABAAAQAAAQAAAAAAAFAAAAAQAAAAAAAAAAAGIAYE9nZ1MAAAAAAAAAAAAAZpwgEwEAAAACrA7TDlj///////////////+QgXRoZW9yYSsAAABYaXBoLk9yZyBsaWJ0aGVvcmEgMS4xIDIwMDkwODIyIChUaHVzbmVsZGEpAQAAABoAAABFTkNPREVSPWZmbXBlZzJ0aGVvcmEtMC4yOYJ0aGVvcmG+zSj3uc1rGLWpSUoQc5zmMYxSlKQhCDGMYhCEIQhAAAAAAAAAAAAAEW2uU2eSyPxWEvx4OVts5ir1aKtUKBMpJFoQ/nk5m41mUwl4slUpk4kkghkIfDwdjgajQYC8VioUCQRiIQh8PBwMhgLBQIg4FRba5TZ5LI/FYS/Hg5W2zmKvVoq1QoEykkWhD+eTmbjWZTCXiyVSmTiSSCGQh8PB2OBqNBgLxWKhQJBGIhCHw8HAyGAsFAiDgUCw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDAwPEhQUFQ0NDhESFRUUDg4PEhQVFRUOEBETFBUVFRARFBUVFRUVEhMUFRUVFRUUFRUVFRUVFRUVFRUVFRUVEAwLEBQZGxwNDQ4SFRwcGw4NEBQZHBwcDhATFhsdHRwRExkcHB4eHRQYGxwdHh4dGxwdHR4eHh4dHR0dHh4eHRALChAYKDM9DAwOExo6PDcODRAYKDlFOA4RFh0zV1A+EhYlOkRtZ00YIzdAUWhxXDFATldneXhlSFxfYnBkZ2MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEhIVGRoaGhoSFBYaGhoaGhUWGRoaGhoaGRoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhESFh8kJCQkEhQYIiQkJCQWGCEkJCQkJB8iJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQREhgvY2NjYxIVGkJjY2NjGBo4Y2NjY2MvQmNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRISEhUXGBkbEhIVFxgZGxwSFRcYGRscHRUXGBkbHB0dFxgZGxwdHR0YGRscHR0dHhkbHB0dHR4eGxwdHR0eHh4REREUFxocIBERFBcaHCAiERQXGhwgIiUUFxocICIlJRcaHCAiJSUlGhwgIiUlJSkcICIlJSUpKiAiJSUlKSoqEBAQFBgcICgQEBQYHCAoMBAUGBwgKDBAFBgcICgwQEAYHCAoMEBAQBwgKDBAQEBgICgwQEBAYIAoMEBAQGCAgAfF5cdH1e3Ow/L66wGmYnfIUbwdUTe3LMRbqON8B+5RJEvcGxkvrVUjTMrsXYhAnIwe0dTJfOYbWrDYyqUrz7dw/JO4hpmV2LsQQvkUeGq1BsZLx+cu5iV0e0eScJ91VIQYrmqfdVSK7GgjOU0oPaPOu5IcDK1mNvnD+K8LwS87f8Jx2mHtHnUkTGAurWZlNQa74ZLSFH9oF6FPGxzLsjQO5Qe0edcpttd7BXBSqMCL4k/4tFrHIPuEQ7m1/uIWkbDMWVoDdOSuRQ9286kvVUlQjzOE6VrNguN4oRXYGkgcnih7t13/9kxvLYKQezwLTrO44sVmMPgMqORo1E0sm1/9SludkcWHwfJwTSybR4LeAz6ugWVgRaY8mV/9SluQmtHrzsBtRF/wPY+X0JuYTs+ltgrXAmlk10xQHmTu9VSIAk1+vcvU4ml2oNzrNhEtQ3CysNP8UeR35wqpKUBdGdZMSjX4WVi8nJpdpHnbhzEIdx7mwf6W1FKAiucMXrWUWVjyRf23chNtR9mIzDoT/6ZLYailAjhFlZuvPtSeZ+2oREubDoWmT3TguY+JHPdRVSLKxfKH3vgNqJ/9emeEYikGXDFNzaLjvTeGAL61mogOoeG3y6oU4rW55ydoj0lUTSR/mmRhPmF86uwIfzp3FtiufQCmppaHDlGE0r2iTzXIw3zBq5hvaTldjG4CPb9wdxAme0SyedVKczJ9AtYbgPOzYKJvZZImsN7ecrxWZg5dR6ZLj/j4qpWsIA+vYwE+Tca9ounMIsrXMB4Stiib2SPQtZv+FVIpfEbzv8ncZoLBXc3YBqTG1HsskTTotZOYTG+oVUjLk6zhP8bg4RhMUNtfZdO7FdpBuXzhJ5Fh8IKlJG7wtD9ik8rWOJxy6iQ3NwzBpQ219mlyv+FLicYs2iJGSE0u2txzed++D61ZWCiHD/cZdQVCqkO2gJpdpNaObhnDfAPrT89RxdWFZ5hO3MseBSIlANppdZNIV/Rwe5eLTDvkfWKzFnH+QJ7m9QWV1KdwnuIwTNtZdJMoXBf74OhRnh2t+OTGL+AVUnIkyYY+QG7g9itHXyF3OIygG2s2kud679ZWKqSFa9n3IHD6MeLv1lZ0XyduRhiDRtrNnKoyiFVLcBm0ba5Yy3fQkDh4XsFE34isVpOzpa9nR8iCpS4HoxG2rJpnRhf3YboVa1PcRouh5LIJv/uQcPNd095ickTaiGBnWLKVWRc0OnYTSyex/n2FofEPnDG8y3PztHrzOLK1xo6RAml2k9owKajOC0Wr4D5x+3nA0UEhK2m198wuBHF3zlWWVKWLN1CHzLClUfuoYBcx4b1llpeBKmbayaR58njtE9onD66lUcsg0Spm2snsb+8HaJRn4dYcLbCuBuYwziB8/5U1C1DOOz2gZjSZtrLJk6vrLF3hwY4Io9xuT/ruUFRSBkNtUzTOWhjh26irLEPx4jPZL3Fo3QrReoGTTM21xYTT9oFdhTUIvjqTkfkvt0bzgVUjq/hOYY8j60IaO/0AzRBtqkTS6R5ellZd5uKdzzhb8BFlDdAcrwkE0rbXTOPB+7Y0FlZO96qFL4Ykg21StJs8qIW7h16H5hGiv8V2Cflau7QVDepTAHa6Lgt6feiEvJDM21StJsmOH/hynURrKxvUpQ8BH0JF7BiyG2qZpnL/7AOU66gt+reLEXY8pVOCQvSsBtqZTNM8bk9ohRcwD18o/WVkbvrceVKRb9I59IEKysjBeTMmmbA21xu/6iHadLRxuIzkLpi8wZYmmbbWi32RVAUjruxWlJ//iFxE38FI9hNKOoCdhwf5fDe4xZ81lgREhK2m1j78vW1CqkuMu/AjBNK210kzRUX/B+69cMMUG5bYrIeZxVSEZISmkzbXOi9yxwIfPgdsov7R71xuJ7rFcACjG/9PzApqFq7wEgzNJm2suWESPuwrQvejj7cbnQxMkxpm21lUYJL0fKmogPPqywn7e3FvB/FCNxPJ85iVUkCE9/tLKx31G4CgNtWTTPFhMvlu8G4/TrgaZttTChljfNJGgOT2X6EqpETy2tYd9cCBI4lIXJ1/3uVUllZEJz4baqGF64yxaZ+zPLYwde8Uqn1oKANtUrSaTOPHkhvuQP3bBlEJ/LFe4pqQOHUI8T8q7AXx3fLVBgSCVpMba55YxN3rv8U1Dv51bAPSOLlZWebkL8vSMGI21lJmmeVxPRwFlZF1CpqCN8uLwymaZyjbXHCRytogPN3o/n74CNykfT+qqRv5AQlHcRxYrC5KvGmbbUwmZY/29BvF6C1/93x4WVglXDLFpmbapmF89HKTogRwqqSlGbu+oiAkcWFbklC6Zhf+NtTLFpn8oWz+HsNRVSgIxZWON+yVyJlE5tq/+GWLTMutYX9ekTySEQPLVNQQ3OfycwJBM0zNtZcse7CvcKI0V/zh16Dr9OSA21MpmmcrHC+6pTAPHPwoit3LHHqs7jhFNRD6W8+EBGoSEoaZttTCZljfduH/fFisn+dRBGAZYtMzbVMwvul/T/crK1NQh8gN0SRRa9cOux6clC0/mDLFpmbarmF8/e6CopeOLCNW6S/IUUg3jJIYiAcDoMcGeRbOvuTPjXR/tyo79LK3kqqkbxkkMRAOB0GODPItnX3Jnxro/25Ud+llbyVVSN4ySGIgHA6DHBnkWzr7kz410f7cqO/Syt5KqpFVJwn6gBEvBM0zNtZcpGOEPiysW8vvRd2R0f7gtjhqUvXL+gWVwHm4XJDBiMpmmZtrLfPwd/IugP5+fKVSysH1EXreFAcEhelGmbbUmZY4Xdo1vQWVnK19P4RuEnbf0gQnR+lDCZlivNM22t1ESmopPIgfT0duOfQrsjgG4tPxli0zJmF5trdL1JDUIUT1ZXSqQDeR4B8mX3TrRro/2McGeUvLtwo6jIEKMkCUXWsLyZROd9P/rFYNtXPBli0z398iVUlVKAjFlY437JXImUTm2r/4ZYtMy61hf16RPJIU9nZ1MABAwAAAAAAAAAZpwgEwIAAABhp658BScAAAAAAADnUFBQXIDGXLhwtttNHDhw5OcpQRMETBEwRPduylKVB0HRdF0A';
      }
      else if (Modernizr.video.h264) {
        elem.src = 'data:video/mp4;base64,AAAAHGZ0eXBtcDQyAAAAAG1wNDJpc29tYXZjMQAAAz5tb292AAAAbG12aGQAAAAAzaNacc2jWnEAAV+QAAFfkAABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAGGlvZHMAAAAAEICAgAcAT////3//AAACQ3RyYWsAAABcdGtoZAAAAAHNo1pxzaNacQAAAAEAAAAAAAFfkAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAEAAAABAAAAAAAd9tZGlhAAAAIG1kaGQAAAAAzaNacc2jWnEAAV+QAAFfkFXEAAAAAAAhaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAAAAAAGWbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAABVnN0YmwAAACpc3RzZAAAAAAAAAABAAAAmWF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAEAAQAEgAAABIAAAAAAAAAAEOSlZUL0FWQyBDb2RpbmcAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAxYXZjQwH0AAr/4QAZZ/QACq609NQYBBkAAAMAAQAAAwAKjxImoAEABWjOAa8gAAAAEmNvbHJuY2xjAAYAAQAGAAAAGHN0dHMAAAAAAAAAAQAAAAUAAEZQAAAAKHN0c3oAAAAAAAAAAAAAAAUAAAIqAAAACAAAAAgAAAAIAAAACAAAAChzdHNjAAAAAAAAAAIAAAABAAAABAAAAAEAAAACAAAAAQAAAAEAAAAYc3RjbwAAAAAAAAACAAADYgAABaQAAAAUc3RzcwAAAAAAAAABAAAAAQAAABFzZHRwAAAAAAREREREAAAAb3VkdGEAAABnbWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcgAAAAAAAAAAAAAAAAAAAAA6aWxzdAAAADKpdG9vAAAAKmRhdGEAAAABAAAAAEhhbmRCcmFrZSAwLjkuOCAyMDEyMDcxODAwAAACUm1kYXQAAAHkBgX/4NxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxMjAgLSBILjI2NC9NUEVHLTQgQVZDIGNvZGVjIC0gQ29weWxlZnQgMjAwMy0yMDExIC0gaHR0cDovL3d3dy52aWRlb2xhbi5vcmcveDI2NC5odG1sIC0gb3B0aW9uczogY2FiYWM9MCByZWY9MSBkZWJsb2NrPTE6MDowIGFuYWx5c2U9MHgxOjAgbWU9ZXNhIHN1Ym1lPTkgcHN5PTAgbWl4ZWRfcmVmPTAgbWVfcmFuZ2U9NCBjaHJvbWFfbWU9MSB0cmVsbGlzPTAgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0wIGNocm9tYV9xcF9vZmZzZXQ9MCB0aHJlYWRzPTYgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTUwIGtleWludF9taW49NSBzY2VuZWN1dD00MCBpbnRyYV9yZWZyZXNoPTAgcmM9Y3FwIG1idHJlZT0wIHFwPTAAgAAAAD5liISscR8A+E4ACAACFoAAITAAAgsAAPgYCoKgoC+L4vi+KAvi+L4YfAEAACMzgABF9AAEUGUgABDJiXnf4AAAAARBmiKUAAAABEGaQpQAAAAEQZpilAAAAARBmoKU';
      }
      else {
        addTest('videoautoplay', false);
        return;
      }
    }

    catch (e) {
      addTest('videoautoplay', false);
      return;
    }

    elem.setAttribute('autoplay','');
    elem.style = 'display:none';
    docElement.appendChild(elem);
    // wait for the next tick to add the listener, otherwise the element may
    // not have time to play in high load situations (e.g. the test suite)
    setTimeout(function() {
      elem.addEventListener('playing', testAutoplay);
      timeout = setTimeout(testAutoplay, waitTime);
    }, 0);
  });


  // http://mathiasbynens.be/notes/xhr-responsetype-json#comment-4
  /* istanbul ignore next */
  var testXhrType = function(type) {
    if (typeof XMLHttpRequest == 'undefined') {
      return false;
    }
    var xhr = new XMLHttpRequest();
    xhr.open('get', '/', true);
    try {
      xhr.responseType = type;
    } catch(error) {
      return false;
    }
    return 'response' in xhr && xhr.responseType == type;
  };


/*!
{
  "name": "XHR responseType='arraybuffer'",
  "property": "xhrresponsetypearraybuffer",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "http://xhr.spec.whatwg.org/#the-responsetype-attribute"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='arraybuffer'.
*/

  Modernizr.addTest('xhrresponsetypearraybuffer', testXhrType('arraybuffer'));

/*!
{
  "name": "XHR responseType='json'",
  "property": "xhrresponsetypejson",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "http://xhr.spec.whatwg.org/#the-responsetype-attribute"
  },{
    "name": "Explanation of xhr.responseType='json'",
    "href": "http://mathiasbynens.be/notes/xhr-responsetype-json"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='json'.
*/

  Modernizr.addTest('xhrresponsetypejson', testXhrType('json'));

/*!
{
  "name": "XHR responseType='blob'",
  "property": "xhrresponsetypeblob",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "http://xhr.spec.whatwg.org/#the-responsetype-attribute"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='blob'.
*/

  Modernizr.addTest('xhrresponsetypeblob', testXhrType('blob'));

/*!
{
  "name": "XHR responseType='document'",
  "property": "xhrresponsetypedocument",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "http://xhr.spec.whatwg.org/#the-responsetype-attribute"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='document'.
*/

  Modernizr.addTest('xhrresponsetypedocument', testXhrType('document'));

/*!
{
  "name": "XHR responseType='text'",
  "property": "xhrresponsetypetext",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "http://xhr.spec.whatwg.org/#the-responsetype-attribute"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='text'.
*/

  Modernizr.addTest('xhrresponsetypetext', testXhrType('text'));


  function getBody() {
    // After page load injecting a fake body doesn't work so check if body exists
    var body = document.body;

    if(!body) {
      // Can't use the real body create a fake one.
      body = createElement('body');
      body.fake = true;
    }

    return body;
  }

  ;

  // Inject element with style element and some CSS rules
  function injectElementWithStyles( rule, callback, nodes, testnames ) {
    var mod = 'modernizr';
    var style;
    var ret;
    var node;
    var docOverflow;
    var div = createElement('div');
    var body = getBody();

    if ( parseInt(nodes, 10) ) {
      // In order not to give false positives we create a node for each test
      // This also allows the method to scale for unspecified uses
      while ( nodes-- ) {
        node = createElement('div');
        node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
        div.appendChild(node);
      }
    }

    // <style> elements in IE6-9 are considered 'NoScope' elements and therefore will be removed
    // when injected with innerHTML. To get around this you need to prepend the 'NoScope' element
    // with a 'scoped' element, in our case the soft-hyphen entity as it won't mess with our measurements.
    // msdn.microsoft.com/en-us/library/ms533897%28VS.85%29.aspx
    // Documents served as xml will throw if using &shy; so use xml friendly encoded version. See issue #277
    style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
    div.id = mod;
    // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
    // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
    (!body.fake ? div : body).innerHTML += style;
    body.appendChild(div);
    if ( body.fake ) {
      //avoid crashing IE8, if background image is used
      body.style.background = '';
      //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
      body.style.overflow = 'hidden';
      docOverflow = docElement.style.overflow;
      docElement.style.overflow = 'hidden';
      docElement.appendChild(body);
    }

    ret = callback(div, rule);
    // If this is done after page load we don't want to remove the body so check if body exists
    if ( body.fake ) {
      body.parentNode.removeChild(body);
      docElement.style.overflow = docOverflow;
      // Trigger layout so kinetic scrolling isn't disabled in iOS6+
      docElement.offsetHeight;
    } else {
      div.parentNode.removeChild(div);
    }

    return !!ret;

  }

  ;

  var testStyles = ModernizrProto.testStyles = injectElementWithStyles;

/*!
{
  "name": "Touch Events",
  "property": "touchevents",
  "caniuse" : "touch",
  "tags": ["media", "attribute"],
  "notes": [{
    "name": "Touch Events spec",
    "href": "http://www.w3.org/TR/2013/WD-touch-events-20130124/"
  }],
  "warnings": [
    "Indicates if the browser supports the Touch Events spec, and does not necessarily reflect a touchscreen device"
  ],
  "knownBugs": [
    "False-positive on some configurations of Nokia N900",
    "False-positive on some BlackBerry 6.0 builds – https://github.com/Modernizr/Modernizr/issues/372#issuecomment-3112695"
  ]
}
!*/
/* DOC
Indicates if the browser supports the W3C Touch Events API.

This *does not* necessarily reflect a touchscreen device:

* Older touchscreen devices only emulate mouse events
* Modern IE touch devices implement the Pointer Events API instead: use `Modernizr.pointerevents` to detect support for that
* Some browsers & OS setups may enable touch APIs when no touchscreen is connected
* Future browsers may implement other event models for touch interactions

See this article: [You Can't Detect A Touchscreen](http://www.stucox.com/blog/you-cant-detect-a-touchscreen/).

It's recommended to bind both mouse and touch/pointer events simultaneously – see [this HTML5 Rocks tutorial](http://www.html5rocks.com/en/mobile/touchandmouse/).

This test will also return `true` for Firefox 4 Multitouch support.
*/

  // Chrome (desktop) used to lie about its support on this, but that has since been rectified: http://crbug.com/36415
  Modernizr.addTest('touchevents', function() {
    var bool;
    if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
      bool = true;
    } else {
      var query = ['@media (',prefixes.join('touch-enabled),('),'heartz',')','{#modernizr{top:9px;position:absolute}}'].join('');
      testStyles(query, function( node ) {
        bool = node.offsetTop === 9;
      });
    }
    return bool;
  });


  // adapted from matchMedia polyfill
  // by Scott Jehl and Paul Irish
  // gist.github.com/786768
  var testMediaQuery = (function () {
    var matchMedia = window.matchMedia || window.msMatchMedia;
    if ( matchMedia ) {
      return function ( mq ) {
        var mql = matchMedia(mq);
        return mql && mql.matches || false;
      };
    }

    return function ( mq ) {
      var bool = false;

      injectElementWithStyles('@media ' + mq + ' { #modernizr { position: absolute; } }', function( node ) {
        bool = (window.getComputedStyle ?
                window.getComputedStyle(node, null) :
                node.currentStyle)['position'] == 'absolute';
      });

      return bool;
    };
  })();



  /** Modernizr.mq tests a given media query, live against the current state of the window
   * A few important notes:
        * If a browser does not support media queries at all (eg. oldIE) the mq() will always return false
        * A max-width or orientation query will be evaluated against the current state, which may change later.
        * You must specify values. Eg. If you are testing support for the min-width media query use:
              Modernizr.mq('(min-width:0)')
   * usage:
   * Modernizr.mq('only screen and (max-width:768)')
   */
  var mq = ModernizrProto.mq = testMediaQuery;


  var cssomPrefixes = (ModernizrProto._config.usePrefixes ? omPrefixes.split(' ') : []);
  ModernizrProto._cssomPrefixes = cssomPrefixes;


  /**
   * atRule returns a given CSS property at-rule (eg @keyframes), possibly in
   * some prefixed form, or false, in the case of an unsupported rule
   *
   * @param prop - String naming the property to test
   */

  var atRule = function(prop) {
    var length = prefixes.length;
    var cssrule = window.CSSRule;
    var rule;

    if (typeof cssrule === 'undefined') {
      return undefined;
    }

    if (!prop) {
      return false;
    }

    // remove literal @ from beginning of provided property
    prop = prop.replace(/^@/,'');

    // CSSRules use underscores instead of dashes
    rule = prop.replace(/-/g,'_').toUpperCase() + '_RULE';

    if (rule in cssrule) {
      return '@' + prop;
    }

    for ( var i = 0; i < length; i++ ) {
      // prefixes gives us something like -o-, and we want O_
      var prefix = prefixes[i];
      var thisRule = prefix.toUpperCase() + '_' + rule;

      if (thisRule in cssrule) {
        return '@-' + prefix.toLowerCase() + '-' + prop;
      }
    }

    return false;
  };



  /**
   * contains returns a boolean for if substr is found within str.
   */
  function contains( str, substr ) {
    return !!~('' + str).indexOf(substr);
  }

  ;

  // Function to allow us to use native feature detection functionality if available.
  // Accepts a list of property names and a single value
  // Returns `undefined` if native detection not available
  function nativeTestProps ( props, value ) {
    var i = props.length;
    // Start with the JS API: http://www.w3.org/TR/css3-conditional/#the-css-interface
    if ('CSS' in window && 'supports' in window.CSS) {
      // Try every prefixed variant of the property
      while (i--) {
        if (window.CSS.supports(domToCSS(props[i]), value)) {
          return true;
        }
      }
      return false;
    }
    // Otherwise fall back to at-rule (for Opera 12.x)
    else if ('CSSSupportsRule' in window) {
      // Build a condition string for every prefixed variant
      var conditionText = [];
      while (i--) {
        conditionText.push('(' + domToCSS(props[i]) + ':' + value + ')');
      }
      conditionText = conditionText.join(' or ');
      return injectElementWithStyles('@supports (' + conditionText + ') { #modernizr { position: absolute; } }', function( node ) {
        return getComputedStyle(node, null).position == 'absolute';
      });
    }
    return undefined;
  }
  ;

  // Change the function's scope.
  function fnBind(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  }

  ;

  /**
   * testDOMProps is a generic DOM property test; if a browser supports
   *   a certain property, it won't return undefined for it.
   */
  function testDOMProps( props, obj, elem ) {
    var item;

    for ( var i in props ) {
      if ( props[i] in obj ) {

        // return the property name as a string
        if (elem === false) return props[i];

        item = obj[props[i]];

        // let's bind a function
        if (is(item, 'function')) {
          // bind to obj unless overriden
          return fnBind(item, elem || obj);
        }

        // return the unbound function or obj or value
        return item;
      }
    }
    return false;
  }

  ;

  /**
   * Create our "modernizr" element that we do most feature tests on.
   */
  var modElem = {
    elem : createElement('modernizr')
  };

  // Clean up this element
  Modernizr._q.push(function() {
    delete modElem.elem;
  });



  var mStyle = {
    style : modElem.elem.style
  };

  // kill ref for gc, must happen before
  // mod.elem is removed, so we unshift on to
  // the front of the queue.
  Modernizr._q.unshift(function() {
    delete mStyle.style;
  });



  // testProps is a generic CSS / DOM property test.

  // In testing support for a given CSS property, it's legit to test:
  //    `elem.style[styleName] !== undefined`
  // If the property is supported it will return an empty string,
  // if unsupported it will return undefined.

  // We'll take advantage of this quick test and skip setting a style
  // on our modernizr element, but instead just testing undefined vs
  // empty string.

  // Property names can be provided in either camelCase or kebab-case.

  function testProps( props, prefixed, value, skipValueTest ) {
    skipValueTest = is(skipValueTest, 'undefined') ? false : skipValueTest;

    // Try native detect first
    if (!is(value, 'undefined')) {
      var result = nativeTestProps(props, value);
      if(!is(result, 'undefined')) {
        return result;
      }
    }

    // Otherwise do it properly
    var afterInit, i, propsLength, prop, before;

    // If we don't have a style element, that means
    // we're running async or after the core tests,
    // so we'll need to create our own elements to use
    if ( !mStyle.style ) {
      afterInit = true;
      mStyle.modElem = createElement('modernizr');
      mStyle.style = mStyle.modElem.style;
    }

    // Delete the objects if we
    // we created them.
    function cleanElems() {
      if (afterInit) {
        delete mStyle.style;
        delete mStyle.modElem;
      }
    }

    propsLength = props.length;
    for ( i = 0; i < propsLength; i++ ) {
      prop = props[i];
      before = mStyle.style[prop];

      if (contains(prop, '-')) {
        prop = cssToDOM(prop);
      }

      if ( mStyle.style[prop] !== undefined ) {

        // If value to test has been passed in, do a set-and-check test.
        // 0 (integer) is a valid property value, so check that `value` isn't
        // undefined, rather than just checking it's truthy.
        if (!skipValueTest && !is(value, 'undefined')) {

          // Needs a try catch block because of old IE. This is slow, but will
          // be avoided in most cases because `skipValueTest` will be used.
          try {
            mStyle.style[prop] = value;
          } catch (e) {}

          // If the property value has changed, we assume the value used is
          // supported. If `value` is empty string, it'll fail here (because
          // it hasn't changed), which matches how browsers have implemented
          // CSS.supports()
          if (mStyle.style[prop] != before) {
            cleanElems();
            return prefixed == 'pfx' ? prop : true;
          }
        }
        // Otherwise just return true, or the property name if this is a
        // `prefixed()` call
        else {
          cleanElems();
          return prefixed == 'pfx' ? prop : true;
        }
      }
    }
    cleanElems();
    return false;
  }

  ;

  // Modernizr.testProp() investigates whether a given style property is recognized
  // Property names can be provided in either camelCase or kebab-case.
  // Modernizr.testProp('pointerEvents')
  // Also accepts optional 2nd arg, of a value to use for native feature detection, e.g.:
  // Modernizr.testProp('pointerEvents', 'none')
  var testProp = ModernizrProto.testProp = function( prop, value, useValue ) {
    return testProps([prop], undefined, value, useValue);
  };


  /**
   * testPropsAll tests a list of DOM properties we want to check against.
   *     We specify literally ALL possible (known and/or likely) properties on
   *     the element including the non-vendor prefixed one, for forward-
   *     compatibility.
   */
  function testPropsAll( prop, prefixed, elem, value, skipValueTest ) {

    var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
    props = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

    // did they call .prefixed('boxSizing') or are we just testing a prop?
    if(is(prefixed, 'string') || is(prefixed, 'undefined')) {
      return testProps(props, prefixed, value, skipValueTest);

      // otherwise, they called .prefixed('requestAnimationFrame', window[, elem])
    } else {
      props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
      return testDOMProps(props, prefixed, elem);
    }
  }

  // Modernizr.testAllProps() investigates whether a given style property,
  //     or any of its vendor-prefixed variants, is recognized
  // Note that the property names must be provided in the camelCase variant.
  // Modernizr.testAllProps('boxSizing')
  ModernizrProto.testAllProps = testPropsAll;



  // Modernizr.prefixed() returns the prefixed or nonprefixed property name variant of your input
  // Modernizr.prefixed('boxSizing') // 'MozBoxSizing'

  // Properties can be passed as DOM-style camelCase or CSS-style kebab-case.
  // Return values will always be in camelCase; if you want kebab-case, use Modernizr.prefixedCSS().

  // If you're trying to ascertain which transition end event to bind to, you might do something like...
  //
  //     var transEndEventNames = {
  //         'WebkitTransition' : 'webkitTransitionEnd',// Saf 6, Android Browser
  //         'MozTransition'    : 'transitionend',      // only for FF < 15
  //         'transition'       : 'transitionend'       // IE10, Opera, Chrome, FF 15+, Saf 7+
  //     },
  //     transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];

  var prefixed = ModernizrProto.prefixed = function( prop, obj, elem ) {
    if (prop.indexOf('@') === 0) {
      return atRule(prop);
    }

    if (prop.indexOf('-') != -1) {
      // Convert kebab-case to camelCase
      prop = cssToDOM(prop);
    }
    if (!obj) {
      return testPropsAll(prop, 'pfx');
    } else {
      // Testing DOM property e.g. Modernizr.prefixed('requestAnimationFrame', window) // 'mozRequestAnimationFrame'
      return testPropsAll(prop, obj, elem);
    }
  };



  // Modernizr.prefixedCSS() is like Modernizr.prefixed(), but returns the result in
  // hyphenated form, e.g.:
  // Modernizr.prefixedCSS('transition') // '-moz-transition'

  // It’s only suitable for style properties.

  // Properties can be passed as DOM-style camelCase or CSS-style kebab-case.
  // Return values will always be the hyphenated variant, or `false` if not supported
  var prefixedCSS = ModernizrProto.prefixedCSS = function(prop) {
    var prefixedProp = prefixed(prop);
    return prefixedProp && domToCSS(prefixedProp);
  };

/*!
{
  "name": "Blob URLs",
  "property": "bloburls",
  "caniuse": "bloburls",
  "notes": [{
    "name": "W3C Working Draft",
    "href": "http://www.w3.org/TR/FileAPI/#creating-revoking"
  }],
  "tags": ["file", "url"],
  "authors": ["Ron Waldon (@jokeyrhyme)"]
}
!*/
/* DOC
Detects support for creating Blob URLs
*/

  var url = prefixed('URL', window, false);
  url = url && window[url];
  Modernizr.addTest('bloburls', url && 'revokeObjectURL' in url && 'createObjectURL' in url);

/*!
{
  "name": "Pointer Lock API",
  "property": "pointerlock",
  "notes": [{
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en-US/docs/API/Pointer_Lock_API"
  }],
  "builderAliases": ["pointerlock_api"]
}
!*/
/* DOC
Detects support the pointer lock API which allows you to lock the mouse cursor to the browser window.
*/

  // https://developer.mozilla.org/en-US/docs/API/Pointer_Lock_API
  Modernizr.addTest('pointerlock', !!prefixed('exitPointerLock', document));

/*!
{
  "name": "Quota Storage Management API",
  "property": "quotamanagement",
  "tags": ["storage"],
  "builderAliases": ["quota_management_api"],
  "notes": [{
    "name": "W3C Spec",
    "href": "http://www.w3.org/TR/quota-api/"
  }]
}
!*/
/* DOC
Detects the ability to request a specific amount of space for filesystem access
*/

  Modernizr.addTest('quotamanagement', function() {
    var tempStorage = prefixed('temporaryStorage', navigator);
    var persStorage = prefixed('persistentStorage', navigator);

    return !!(tempStorage && persStorage);
  });


  /**
   * testAllProps determines whether a given CSS property, in some prefixed
   * form, is supported by the browser. It can optionally be given a value; in
   * which case testAllProps will only return true if the browser supports that
   * value for the named property; this latter case will use native detection
   * (via window.CSS.supports) if available. A boolean can be passed as a 3rd
   * parameter to skip the value check when native detection isn't available,
   * to improve performance when simply testing for support of a property.
   *
   * @param prop - String naming the property to test (either camelCase or
   *               kebab-case)
   * @param value - [optional] String of the value to test
   * @param skipValueTest - [optional] Whether to skip testing that the value
   *                        is supported when using non-native detection
   *                        (default: false)
   */
  function testAllProps (prop, value, skipValueTest) {
    return testPropsAll(prop, undefined, undefined, value, skipValueTest);
  }
  ModernizrProto.testAllProps = testAllProps;


  // Run each test
  testRunner();

  // Remove the "no-js" class if it exists
  setClasses(classes);

  delete ModernizrProto.addTest;
  delete ModernizrProto.addAsyncTest;

  // Run the things that are supposed to run after the tests
  for (var i = 0; i < Modernizr._q.length; i++) {
    Modernizr._q[i]();
  }

  // Leak Modernizr namespace
  window.Modernizr = Modernizr;


;

})(window, document);
/*
 http://www.JSON.org/json2.js
 2011-10-19

 Public Domain.

 NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

 See http://www.JSON.org/js.html


 This code should be minified before deployment.
 See http://javascript.crockford.com/jsmin.html

 USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
 NOT CONTROL.


 This file creates a global JSON object containing two methods: stringify
 and parse.

 JSON.stringify(value, replacer, space)
 value       any JavaScript value, usually an object or array.

 replacer    an optional parameter that determines how object
 values are stringified for objects. It can be a
 function or an array of strings.

 space       an optional parameter that specifies the indentation
 of nested structures. If it is omitted, the text will
 be packed without extra whitespace. If it is a number,
 it will specify the number of spaces to indent at each
 level. If it is a string (such as '\t' or '&nbsp;'),
 it contains the characters used to indent at each level.

 This method produces a JSON text from a JavaScript value.

 When an object value is found, if the object contains a toJSON
 method, its toJSON method will be called and the result will be
 stringified. A toJSON method does not serialize: it returns the
 value represented by the name/value pair that should be serialized,
 or undefined if nothing should be serialized. The toJSON method
 will be passed the key associated with the value, and this will be
 bound to the value

 For example, this would serialize Dates as ISO strings.

 Date.prototype.toJSON = function (key) {
 function f(n) {
 // Format integers to have at least two digits.
 return n < 10 ? '0' + n : n;
 }

 return this.getUTCFullYear()   + '-' +
 f(this.getUTCMonth() + 1) + '-' +
 f(this.getUTCDate())      + 'T' +
 f(this.getUTCHours())     + ':' +
 f(this.getUTCMinutes())   + ':' +
 f(this.getUTCSeconds())   + 'Z';
 };

 You can provide an optional replacer method. It will be passed the
 key and value of each member, with this bound to the containing
 object. The value that is returned from your method will be
 serialized. If your method returns undefined, then the member will
 be excluded from the serialization.

 If the replacer parameter is an array of strings, then it will be
 used to select the members to be serialized. It filters the results
 such that only members with keys listed in the replacer array are
 stringified.

 Values that do not have JSON representations, such as undefined or
 functions, will not be serialized. Such values in objects will be
 dropped; in arrays they will be replaced with null. You can use
 a replacer function to replace those with JSON values.
 JSON.stringify(undefined) returns undefined.

 The optional space parameter produces a stringification of the
 value that is filled with line breaks and indentation to make it
 easier to read.

 If the space parameter is a non-empty string, then that string will
 be used for indentation. If the space parameter is a number, then
 the indentation will be that many spaces.

 Example:

 text = JSON.stringify(['e', {pluribus: 'unum'}]);
 // text is '["e",{"pluribus":"unum"}]'


 text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
 // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

 text = JSON.stringify([new Date()], function (key, value) {
 return this[key] instanceof Date ?
 'Date(' + this[key] + ')' : value;
 });
 // text is '["Date(---current time---)"]'


 JSON.parse(text, reviver)
 This method parses a JSON text to produce an object or array.
 It can throw a SyntaxError exception.

 The optional reviver parameter is a function that can filter and
 transform the results. It receives each of the keys and values,
 and its return value is used instead of the original value.
 If it returns what it received, then the structure is not modified.
 If it returns undefined then the member is deleted.

 Example:

 // Parse the text. Values that look like ISO date strings will
 // be converted to Date objects.

 myData = JSON.parse(text, function (key, value) {
 var a;
 if (typeof value === 'string') {
 a =
 /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
 if (a) {
 return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
 +a[5], +a[6]));
 }
 }
 return value;
 });

 myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
 var d;
 if (typeof value === 'string' &&
 value.slice(0, 5) === 'Date(' &&
 value.slice(-1) === ')') {
 d = new Date(value.slice(5, -1));
 if (d) {
 return d;
 }
 }
 return value;
 });


 This is a reference implementation. You are free to copy, modify, or
 redistribute.
 **/

/*jslint evil: true, regexp: true **/

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
 call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
 getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
 lastIndex, length, parse, prototype, push, replace, slice, stringify,
 test, toJSON, toString, valueOf
 **/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate()) + 'T' +
                f(this.getUTCHours()) + ':' +
                f(this.getUTCMinutes()) + ':' +
                f(this.getUTCSeconds()) + 'Z'
                : null;
        };

        String.prototype.toJSON =
            Number.prototype.toJSON =
                Boolean.prototype.toJSON = function (key) {
                    return this.valueOf();
                };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b':'\\b',
            '\t':'\\t',
            '\n':'\\n',
            '\f':'\\f',
            '\r':'\\r',
            '"':'\\"',
            '\\':'\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i, // The loop counter.
            k, // The member key.
            v, // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
            case 'string':
                return quote(value);

            case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

                return isFinite(value) ? String(value) : 'null';

            case 'boolean':
            case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

                return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

            case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

                if (!value) {
                    return 'null';
                }

// Make an array to hold the partial results of stringifying this object value.

                gap += indent;
                partial = [];

// Is the value an array?

                if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                    v = partial.length === 0
                        ? '[]'
                        : gap
                        ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                        : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }

// If the replacer is an array, use it to select the members to be stringified.

                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        if (typeof rep[i] === 'string') {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {

// Otherwise, iterate through all of the keys in the object.

                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

                v = partial.length === 0
                    ? '{}'
                    : gap
                    ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                    : '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'':value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'':j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    var str = String(input);
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next str index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      str.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    var str = String(input).replace(/=+$/, '');
    if (str.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = str.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

/*jshint browser: true*/

(function (FrameworkFactory) {
    "use strict";

    // Attaches type typeHandler to webDoodling.
    function plugin(wd) {

        /**
         * TODO Description here.
         *
         * @function type
         * @module webDoodling
         * @version 1.0
         *
         **/
        wd.type = function type(typeName, meta) {
            return {
                type: "type",
                meta: meta,
                typeName: typeName
            };
        };

        wd.typeRegistry = (function () {
            var TypeRegistry,
                _registry = {},
                _list = [];
            //TODO: Throw error when type is not registered.
            TypeRegistry = wd.Class({

                register: function register(type, constructor) {
                    if (_registry[type] !== undefined) {
                        throw new wd.Error("wd-type-already-registered", type);
                    }
                    _registry[type] = constructor;
                    _list.push(type);
                },

                unregister: function unregister(type) {
                    var index;

                    if (_registry[type] !== undefined) {
                        delete _registry[type];
                        index = _list.indexOf(type);
                        if (index !== -1) {
                            _list.splice(index, 1);
                        }

                    }
                },
                get: function get(type) {
                    return _registry[type] || null;
                },

                /**
                 * Returns the instnace of
                 *
                 *
                 *
                 * @return {[type]} [description]
                 *
                 *
                 */
                getInstance: function getInstance(/** ,variable, no, of, arguments **/) {
                    var Constructor = null,
                        args = arguments,
                        json = args[0],
                        instance = null;

                    if (args.length === 0) {
                        throw new wd.Error("wd-no-argument");
                    }

                    if (wd.is.string(args[0])) {
                        Constructor = this.get(args[0]);
                        instance = Constructor.apply(null, [].slice.call(arguments, 1)) || null;
                    }
                    else if(wd.is.plainObject(args[0])) {
                        if ("type" in json) {
                            Constructor = this.get(json.type);
                            instance = Constructor.apply(null) || null;
                            if (instance instanceof wd.Serializable) {
                                instance.deserialize(json);
                            }
                        }
                        else {
                            throw new wd.Error("wd-missing-type-in-object");
                        }
                    }

                    return instance;

                },

                getTypeNames: function getTypeNames() {
                    return _list.slice();
                }
            });
            return new TypeRegistry();

        })();

        FrameworkFactory.typeHandlers.register({
            type: "type",
            handler: function handler(Class, key, options) {
                var get, set,
                    proto = Class.prototype,
                    typeName = options.typeName;

                get = function get () {
                    return typeName;
                };

                set = function set () {
                    throw new wd.Error("wd-type-readonly");
                };

                _attachProperty(proto, key, get, set);
                wd.typeRegistry.register(typeName, Class);
            }
        });

        // Private
        function _attachProperty(obj, key, getter, setter) {

            if (Object.defineProperty) {
                Object.defineProperty(obj, key, {
                    enumerable: true,
                    configurable: true,
                    get: getter,
                    set: setter
                });
            }
            else if (obj.__defineGetter__ !== undefined) {
                obj.__defineGetter__(key, getter);
                obj.__defineSetter__(key, setter);
            }
            else {
                throw new wd.Error("wd-properties-not-supported");
            }
        }
    }

    //Optional information.

    plugin.info = {

        /**
         * The name of the plugin, mandatory.
         */
        name: "Type Field",

        /**
         * The plugin version.
         */
        version: "1.0",

        /**
         * The plugin author.
         */
        author: "Maniar Technologies Private Limited",

        /**
         * The plugin url.
         */
        url: "http://www.webdoodling.com"

    };

    //Register plugin with FrameworkFactory. Registration enables plugin"s function
    //to be invoked each time a new framework is created.
    FrameworkFactory.plugins.register(plugin);

})(window.FrameworkFactory);

/*jshint browser: true*/

(function (FrameworkFactory) {
    "use strict";


    // Attaches imageSource typeHandler to webDoodling.
    function plugin(wd) {

        /**
         * Represents a type handler which allows class developer to accept
         * image in any form such as Image, Canvas, webDoodling.ImageSource etc...
         * Attaches following members to the attached class where [member]
         * is a name of the imageSource member. For example `source` in the example below.
         *
         * - _[member]              Represents the priviate member which stores user assigned value to this imageSouce.
         * - _[member]IsReady       Sets to true when media is loaded and ready to be used, otherwise false.
         * - _[member]OnReady       Callback which is invoked when media becomes ready.
         * - _[member]Media         Contains media such as Image, Canvas, webDoodling.ImageSource etc.
         * - _[member]MediaWidth    Specifies the media width.
         * - _[member]MediaHeight   Specifies the media height.
         *
         * @example
         * var webDoodling.MyImageClass = webDoodling.Class({
         *   // Adds source to webDoodling.MyImageClass which can be
         *   // set to any image. This type hanlder adds f
         *   source: webDoodling.imageSource(),
         *
         *   init: function() {
         *   },
         *
         *   draw: function() {
         *      if (this._sourceIsReady) {
         *          //Draw this._sourceMedia here using this._sourceHeight and this._sourceWidth.
         *      }
         *   },
         *
         *   // Following function is called when `source` becomes ready to use.
         *   _sourceOnReady: function() {
         *      // Run any post processing here which is required after socouce is loaded.
         *   }
         * });
         *
         * @function imageSource
         * @module webDoodling
         * @version 1.0
         *
         **/
        wd.imageSource = function (meta) {
            return {
                type: "imageSource",
                meta: meta
            };
        };

        FrameworkFactory.typeHandlers.register({
            type: "imageSource",
            handler: function handler(Class, key) {
                var privateMember = "_" + key,
                    privateWidth = privateMember + "Width",
                    privateHeight = privateMember + "Height",
                    privateMedia = privateMember + "Media",
                    privateReady = privateMember + "IsReady",
                    privateCallback = privateMember + "OnReady",
                    privateSrc = privateMember + "Src",
                    imageSource = {};

                imageSource[key] = wd.property({
                    value: null,
                    get: function () {
                        return this[privateMember];
                    },
                    set: function (value) {
                        var self = this;

                        function ready(media) {
                            self[privateMember] = value;
                            self[privateWidth] = value.width;
                            self[privateHeight] = value.height;
                            self[privateReady] = true;

                            // In case of ImageAsset
                            if (media && media.media) {
                                self[privateMedia] = media.media;
                            }
                            else if (media) {
                                self[privateMedia] = media;
                            }
                            else {
                                self[privateMedia] = value.media;
                            }

                            if (self[privateCallback]) {
                                self[privateCallback].call(self);
                            }

                        }

                        this[privateReady] = false;
                        this[privateMedia] = null;
                        this[privateSrc] = null;

                        //url string
                        if (wd.is.string(value) === true) {
                            value = new wd.ImageAsset(value);
                            value.success(ready);
                            value.load();
                            this[privateSrc] = value.source;
                        }
                        else if (value instanceof wd.ImageAsset) {
                            if (value.state === wd.AssetStates.READY) {
                                ready();
                            } else {
                                value.success(ready);
                            }
                            this[privateSrc] = value.source; // ImageAssets stores image url in source field.
                        }
                        else if (value instanceof wd.ImageSource) {
                            ready();
                        }
                        else if (value instanceof wd.SVGSource) {
                            this[privateSrc] = value._source;
                            ready(value.image);
                        }
                        else if (value instanceof HTMLCanvasElement || value instanceof Image) {
                            ready(value);
                            if (value instanceof Image) {
                                this[privateSrc] = value.src;
                            }
                        }
                        else {
                            throw new wd.Error("wd-image-source-type-not-supported", this.type, value);
                            //throw new Error("Invalid iamge source for " + this.type + "." + value);
                        }
                    }
                });

                Class.attach(imageSource);
            }
        });
    }

    //Optional information.

    plugin.info = {

        /**
         * The name of the plugin, mandatory.
         */
        name: "ImageSource Field",

        /**
         * The plugin version.
         */
        version: "1.0",

        /**
         * The plugin author.
         */
        author: "Maniar Technologies Private Limited",

        /**
         * The plugin url.
         */
        url: "http://www.webdoodling.com"

    };


    //Register plugin with FrameworkFactory. Registration enables plugin"s function
    //to be invoked each time a new framework is created.
    FrameworkFactory.plugins.register(plugin);

})(window.FrameworkFactory);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The WebDoodling
(function (window) {
    "use strict";

    function WebDoodlingObject() {}

    window.webDoodling = window.FrameworkFactory.create({
        name: "webDoodling",
        version: "1.0.0",
        noConflict: true,
        defaultFPS: 40,
        defaultFramesCount: 20,
        defaultBaseClass: WebDoodlingObject
    }),

    window.webDoodling.WebDoodlingObject = WebDoodlingObject;

    //wd, the webDoodling alias
    window.wd = window.webDoodling;

})(this);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Collections
(function (wd, undefined) {
    "use strict";

    var Serializable;

    /**
     * Provides the base class for all the searializable classes in `webddodling`.
     *
     * @class webDoodling.Serializable
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    Serializable = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.Serializable`, always returns 'Serializable'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Serializable
         * @public
         * @version 1.0
         **/
        type: wd.type("Serializable"),

        /**
         * Gets or sets the serializableKeys of `webDoodling.Serializable`.
         *
         * @field {object} serializableKeys
         *
         * @memberOf webDoodling.Serializable
         * @public
         * @version 1.0
         **/
        serializableKeys: wd.readonly({
            get: function() {
                return this._keyList.slice();
            }
        }),

        //serializable: wd.attribute(null),

        /**
          * Initialize the serialize keys of the `webDoodling.Serializable`.
          *
          * @memberOf webDoodling.Serializable
          * @public
          * @version 1.0
          **/
        init: function() {
            //Store keys in dictionary to prevent duplicates;
            this._keys = {};
            this._keyList = [];
            this.serializables("type");
        },

        /**
          * this function serialize the scene into json format.
          *
          * @memberOf webDoodling.Serializable
          * @public
          * @version 1.0
          **/
        serializables: function () {
            var i, iLen, key, val, type;
            for(i = 0, iLen = arguments.length; i < iLen; i += 1) {
                key = arguments[i];
                if (wd.is.plainObject(key)) {
                    val = key.value;
                    key = key.key;
                    type = "object";
                }
                else {
                    val = true;
                    type = "member";
                }

                if (key in this._keys === false) {
                    this._keys[key] = {
                        value: val,
                        type: type
                    };
                    this._keyList.push(key);
                }

            }
            return this;
        },

        /**
          * this function serialize the scene into json format.
          *
          * @memberOf webDoodling.Serializable
          * @public
          * @version 1.0
          **/
        serialize: function () {
            var i, iLen,
                item, value, key,
                keys = this._keyList,
                json = {};

            //console.log(keys);
            for (i=0, iLen = keys.length; i < iLen; i += 1) {
                key = keys[i];
                item = this._keys[key];
                //console.log(this.type, key, item);

                // If key is function, execute function to get value.
                if (item.type === "object") {
                    value = item.value.call(this);
                }
                else {
                    value = this[key];
                }

                // If value is undefined, do not serialize it.
                if (value === undefined) {
                    continue;
                }
                // If value is null, keep it null.
                else if (value === null) {
                    json[key] = null;
                }
                // else if (value instanceof Array) {
                //     json[key] = _copyOrSerialize(value);
                // }
                // // If value is an object, only serialize if it is instanceof webDoodling.Serializable.
                // else if (value instanceof Object) {
                //     if (value instanceof wd.Serializable) {
                //         json[key] = value.serialize();
                //     }
                //     else {
                //         throw "Object not serializable";
                //     }
                // }
                else {
                    value = _copyOrSerialize(value);
                    if (value !== undefined) {
                        json[key] = value;
                    }
                }
            }

            return json;
        },

        /**
          * this function deserialize the json into object format.
          *
          * @memberOf webDoodling.Serializable
          * @public
          * @version 1.0
          **/
        deserialize: function (json) {
            var key, type, val;

            if (json === undefined) {
                throw new wd.Error("wd-no-argument", "json");
            }

            if (!wd.is.plainObject(json)) {
                throw new wd.Error("wd-invalid-argument");
            }

            for (key in json) {

                //Check json object owns the1 member
                if (!json.hasOwnProperty(key)) {
                    continue;
                }

                type = typeof this[key];
                val = json[key];
                //console.log(key, type, this[key], val);
                if (val instanceof Array) {
                    if (this[key] instanceof wd.Serializable) {
                        this[key].deserialize(val);
                    }
                    else {
                        this[key] = val;
                    }
                }
                else if (type === "function") {
                    //If this is an event, consider function as handler register it.
                    if (this[key].event === true) {
                        this[key].call(this, val);
                    }
                    else {

                        this[key] = val;
                    }
                }
                else if (val instanceof Object) {
                    if (wd.is.plainObject(val)) {
                        if (this[key] instanceof wd.Serializable) {
                            this[key].deserialize(val);
                        }
                        else if ("type" in val) {
                            this[key] = wd.typeRegistry.getInstance(val);
                        }
                        else {
                            this[key] = val;
                        }
                    }
                    else {
                        // Some objects does not accept blank constructor, hence
                        // better to use same value instead of
                        this[key] = val;
                    }

                }
                else {
                    if (key === "type") {
                        continue;
                    }

                    this[key] = _copyOrSerialize(val);
                }
            }
        }

    });

    // Returns a JSON compatible serialized value.
    function _copyOrSerialize(o) {
        var objRefs = [];

        function doCopy(obj) {

            var copy, i, iLen;

            if (objRefs.indexOf(obj) >= 0) {
                 //Object found, return the same object no need to copy it.
                return obj;
            }
            else {
                objRefs.push(obj);
            }

            // Handle the 3 simple types, and null or undefined
            if (null === obj || "object" !== typeof obj) {
                return obj;
            }

            // Handle Date
            if (obj instanceof Date) {
                obj.toJSON();
            }
            else if (obj instanceof RegExp) {
                obj.toString();
            }
            // Handle Array
            else if (obj instanceof Array) {
                copy = [];
                for (i = 0, iLen = obj.length; i < iLen; i += 1) {
                    copy[i] = doCopy(obj[i]);
                }
                return copy;
            }
            else if(wd.is.func(obj)) {
                return obj;
            }
            else if(obj instanceof wd.Serializable) {
                return obj.serialize();
            }
            // Handle Object
            else if (obj instanceof Object) {
                if ("type" in obj) {
                    return wd.typeRegistry.getInstance(obj);
                }
                else {
                    // This may throw an error when obj.constructor does not
                    // accept no parameters.
                    try {
                        copy = new obj.constructor();
                    }
                    catch (err) {
                        throw new wd.Error("wd-error-while-serializing", obj, err);
                    }
                    for (var attr in obj) {
                        if (obj.hasOwnProperty(attr) === true) {
                            copy[attr] = doCopy(obj[attr]);
                        }
                    }
                    return copy;
                }
            }
            throw new wd.Error("wd-error-while-serializing");
        }
        return doCopy(o);
    }


    wd.Serializable = Serializable;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Extending the `is` module.
(function (wd) {
    "use strict";


    var is = wd.is,
        Modernizr = window.Modernizr;

    /**
     * Gets whether the `canvas` is supported or not by the current browser.
     * @field
     * @returns `true` if canvas is being supported else `false`.
     *
     * @public
     * @version 1.0
     **/
    is.canvas = Modernizr.canvas;


    /**
     * Gets whether the `webAudio` is supported or not by the current browser.
     * @field
     * @returns `true` if canvas is being supported else `false`.
     *
     * @public
     * @version 1.0
     **/
    is.webAudio = Modernizr.webaudio;

    //TODO: documentation pending.
    is.audioData = Modernizr.audiodata;

    /**
     * Gets whether a `touch` is supported or not by the current browser.
     *
     * @field {bolean} is.touch
     * @returns `true` if touch is being supported else `false`.
     *
     * @public
     * @version 1.0
     **/
    is.touch = Modernizr.touchevents;

    /**
     * Gets whether the `audio` is supported or not by the current browser.
     *
     * @function wd.is.audioSupported(url).
     * @returns
     * "" - browser not support audio file format.
     * "probably" - the browser most likely supports this audio type.
     * "maybe" - the browser might support this audio type.
     *
     * @public
     * @version 1.0
     **/
    is.audioSupported = function (url) {
        var ext = url.slice(-3),
            audio = new Audio(url),
            support;
        //console.log(ext);
        switch (ext) {
        case "mp3":
            support = audio.canPlayType("audio/mpeg;");
            break;
        case "ogg":
            support = audio.canPlayType("audio/ogg;");
            break;
        case "wav":
            support = audio.canPlayType("audio/wav;");
            break;
        }
        return support;
    };

    //Check is browser currently supports canvas or not. If not, throw an error.
    if (is.canvas === false) {
        throw new wd.Error("wd-canvas-not-supported");
    }

})(window.webDoodling);


// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// Collection
(function (wd, undefined) {
    "use strict";

    var is = wd.is,
        Collection;


    /**
     * Represents a collection class which stores both indexes as well as keys.
     *
     * @class webDoodling.Collection
     *
     * @memberOf webDoodling
     * @extends webDoodling.Serializable
     * @public
     * @version 1.0
     **/
    Collection = wd.Class({

        /**
         * Returns the type of `webDoodling.Collection`, always returns'Collection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        type: wd.type("Collection"),

        /**
         * Represents the total number of items in the list.
         *
         * @readonly {number} length
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        length: wd.readonly({
            get: function () {
                return this._items.length;
            }
        }),

        /**
         * Specifies which field should be used as a mapping key the collection. This
         * field should be changed once when collection is empty.
         *
         * @field {string} keyName
         * @default 'id'
         *
         * @example collection = new wd.Collection();
         * collection.keyName = "key";
         * collection.add([{
         *     key: 'one',
         *     value: 1
         * }, {
         *     key: 'two',
         *     value: 2
         * }]);
         *
         * // The get function here looks for the object whose key is one.
         * var value = collection.get('one').value; returns 1;
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        keyName: wd.attribute("id"),

        /**
         * Returns the serializable for `webDoodling.Collection`. Use serializable
         * to serialize object to and from JSON.
         *
         * @readonly {webDoodling.Serializable} serializable
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        serializable: wd.readonly(),

        /**
         * If not null, calls this function before adding an item to the list.
         * The Item will only be added to the list only if onValidate returns undefined or null.
         * If it returns astring, it is considered as an error message and thus thrown an error.
         *
         * @callback onValidate
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        onValidate: null,

        /**
         * Triggers before an item is added to the collection.
         *
         * @event itemBeforeAdd(eventArgs)
         * @param {webDoodling.CollectionEventArgs} eventArgs
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        itemBeforeAdd: wd.event(),

        /**
         * Triggers when an item is added to the collection.
         *
         * @event itemAdd(eventArgs)
         * @param {webDoodling.CollectionEventArgs} eventArgs
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        itemAdd: wd.event(),

        /**
         * Triggers before an item is removed from the collection.
         *
         * @event itemBeforeRemove(eventArgs)
         * @param {webDoodling.CollectionEventArgs} eventArgs
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        itemBeforeRemove: wd.event(),

        /**
         * Triggers when an item is removed from the collection.
         *
         * @event itemRemoved(eventArgs)
         * @param {webDoodling.CollectionEventArgs} eventArgs
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        itemRemoved: wd.event(),

        /**
         * Initializes the new instance of `webDoodling.collections.ObservableCollection`.
         *
         * @constructor init(o)
         * @param {Array} o Initializes collection with an objects in array.
         * @example
         *     var col = new wd.Collection([{
         *         id: 1
         *     }, {
         *         id: 2
         *     }]);
         *
         * @constructor init(obj1, obj2, objn)
         * @param {obj1, obj2, objn} Initializes collection with zero or more objects supplied
         * as constructor argument.
         * @example
         *     var col = new wd.Collection({
         *         id: 1
         *     }, {
         *         id: 2
         *     });
         *
         *     //Initializes collection with no items.
         *     var col2 = new wd.Collection();
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();

            this._items = [];
            this._keys = [];
            this._map = {};

            if (arguments.length > 0) {
                this.add.apply(this, arguments);
            }
        },

        /**
         * Add one or more items into the list. Triggers `itemBeforeAdd` and `itemAdd`
         * events while adding an item.
         *
         * @function add(obj1[, obj2, obj3, objN])
         * @param {object} obj The objects to be added into current list as variable arguments.
         * @example
         *  list.add(item1); //Add single item.
         *  list.add(item1, item2); //Add multiple items by the mean of multiple arguments.
         *
         * @function add(array)
         * @param {Array} array An object array to be added into the list.
         * @example
         *  list.add([ //Add multiple items as an item array.
         *      item1,
         *      item2,
         *      item3
         *  ]);
         *
         * @returns {webDoodling.Collection} collection The list of items in collection.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        add: function add() {

            var items = this._items,
                keys = this._keys,
                map = this._map,
                keyName = this.keyName,
                item, key,
                args,
                result;

            for (var i = 0, len = arguments.length; i < len; i++) {

                item = arguments[i];
                if (item instanceof Array) {
                    this.add.apply(this, item);
                    return this;
                }

//                args = {
//                    item: item,
//                    process: true
//                };

                args = new wd.CollectionEventArgs(item, true);

                // If onValidate function is provided, send item for validation.
                // If item is not valid then invoking onValidate would raise an error.
                // If result is `null`, then the item is replaced with the result.
                if (is.func(this.onValidate)) {
                    result = this.onValidate(item);
                    if(result !== null) {
                        item = result;
                    }
                }

                this.trigger("itemBeforeAdd", args);
                if (args.process === false) {
                    continue;
                }
                //check if key available.
                if (typeof item === "object" && item[keyName] !== undefined) {

                    key = item[keyName];
                    //key identified, map it.
                    if (!is.nullOrUndef(key)) {
                        //Only string keys are supported.
                        if (!is.string(key)) {
                            throw new wd.Error("wd-not-a-string", key);
                            //throw new wd.Error("Invalid key [" + key + "], expecting a key of type string.");
                        }
                        //Check  if key already exists.
                        if (map[key] !== undefined) {
                            throw new wd.Error("wd-item-already-exists", key);
                            //throw new wd.Error("Item with this key [" + key + "] already exists.");
                        }
                        map[key] = item;
                    }
                }

                //Add item to an array.
                items.push(item);
                keys.push(key);

                this.trigger("itemAdd", new wd.CollectionEventArgs(item));

            }
            return this;
        },

        /**
         * Returns an item at given index or key.
         *
         * @function get(indexOrKey)
         * @param {number or string} index or key.
         *
         * @example
         * //TODO: Recheck Example
         * var collection = new wd.Collection(),
         *      valA, valB;
         * collection.add([{
         *      key: "A",
         *      value: 1
         *    },
         *    {
         *      key: "B",
         *      value: 2
         *    }
         * }]);
         * valA = collection.get("A"); //1
         * valB = collection.get(1); //2
         *
         * @returns {object} Returns an object found at specified index or with associated key.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        get: function get(indexOrKey) {
            if (typeof indexOrKey === "number") {
                return this._items[indexOrKey];
            }
            else if (typeof indexOrKey === "string") {
                return this._map[indexOrKey];
            }
            throw new wd.Error("wd-invalid-argument", indexOrKey);
        },

        /**
         * Removes an item from the `webDoodling.Collection`.
         * Throws an error stating 'Item not found' if the specified item is not found in the list.
         * This function is chainable.
         *
         * @function remove(item)
         * @param {object} item An item to be removed from the list.
         *
         * @example
         * //TODO: Recheck Example
         * var collection = new wd.Collection(),
         *      removeItem;
         * collection.add([{
         *      key: "A",
         *      value: 1
         *    },
         *    {
         *      key: "B",
         *      value: 2
         *    }
         * }]);
         * removeItem = collection.get("A");
         * collection.remove(removeItem);
         *
         * @returns {webDoodling.Collection} The current instance.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        remove: function remove(item) {
            var index = this.indexOf(item),
                key = this._keys[index],
                items = this._items,
                keys = this._keys;

            //If index found
            if (index >= 0) {
                this.trigger("itemBeforeRemove", new wd.CollectionEventArgs(item));
                items.splice(index, 1); //delete array item
                keys.splice(index, 1); //delete key item

                //Remove item from the map if key found
                if (key !== undefined) {
                    delete this._map[key]; //delete key mapping
                }
                this.trigger("itemRemoved", new wd.CollectionEventArgs(item));
            }
            else {
                throw new wd.Error("wd-item-not-found");
            }
            return this;
        },

        /**
         * Move the items to the next position.
         *
         * @function moveToNext(item)
         * @param {object} item An item to be moved.
         * @returns {webDoodling.Collection} Returns the current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        moveToNext: function moveNext(item) {
            var index = this.indexOf(item),
                length = this._items.length,
                index2 = index + 1;

            //If index found and less then index of last item
            if (index !== -1 && index < length - 1) {
                this._swap(index, index2);
            }
            return this;
        },

        /**
         * Move the items to the previous position.
         *
         * @function moveToPrev(item)
         * @param {object} item An item to be moved.
         * @returns {webDoodling.Collection} Returns the current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        moveToPrev: function movePrev(item) {
            var index = this.indexOf(item),
                index2 = index - 1;

            //If index found and less then index of last item
            if (index !== -1 && index > 0) {
                this._swap(index, index2);
            }
            return this;
        },

        /**
         * Move the items to the first position.
         *
         * @function moveToFirst(item)
         * @param {object} item The item to be moved.
         * @returns {webDoodling.Collection} Returns the current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        moveToFirst: function moveToFirst(item) {
            var index = this.indexOf(item),
                items = this._items,
                keys = this._keys,
                key = keys[index];

            if (index === -1) {
                throw new wd.Error("wd-item-not-found");
            }

            //Remove item from arrays
            items.splice(index, 1); //delete array item
            keys.splice(index, 1); //delete key item

            //add item to front
            items.unshift(item);
            keys.unshift(key);
            return this;
        },

        /**
         * Move the items to last position.
         *
         * @function moveToLast(item)
         * @param {object} item The item to be moved.
         * @returns {webDoodling.Collection} Returns the current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        moveToLast: function moveToLast(item) {
            var index = this.indexOf(item),
                items = this._items,
                keys = this._keys,
                key = keys[index];

            if (index === -1) {
                throw new wd.Error("wd-item-not-found");
            }

            //Remove item from arrays
            items.splice(index, 1); //delete array item
            keys.splice(index, 1); //delete key item

            items.push(item);
            keys.push(key);
            return this;
        },

        /**
         * Move the items after another item.
         *
         * @function moveAfter(afterItem, item)
         * @param {item} afterItem An item to be moved after item.
         * @param {object} item An item to be moved.
         * @returns {webDoodling.Collection} Returns The current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        moveAfter: function moveAfter(afterItem, item) {
            var index = this.indexOf(item),
                index2 = this.indexOf(afterItem),
                items = this._items,
                keys = this._keys,
                key = keys[index];

            if (index === -1 || index2 === -1) {
                throw new wd.Error("wd-items-not-found");
                //throw new Error("Item or afterItem not part of the collection");
            }

            //Remove item from arrays
            items.splice(index, 1); //delete array item
            keys.splice(index, 1); //delete key item

            //Recalculate index2
            index2 = this.indexOf(afterItem);

            items.splice(index2 + 1, 0, item);
            keys.splice(index2 + 1, 0, key);

            return this;
        },

        /**
         * Move the items before another item.
         *
         * @function moveBefore(beforeItem, item)
         * @param {item} beforeItem An item to be moved before item.
         * @param {object} item An item to be moved.
         * @returns {webDoodling.Collection} Returns the current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        moveBefore: function moveBefore(beforeItem, item) {
            var index = this.indexOf(item),
                index2 = this.indexOf(beforeItem),
                items = this._items,
                keys = this._keys,
                key = keys[index];

            if (index === -1 || index2 === -1) {
                throw new wd.Error("wd-items-not-found");
                //throw new Error("Item or beforeItem not part of the collection");
            }

            //Remove item from arrays
            items.splice(index, 1); //delete array item
            keys.splice(index, 1); //delete key item

            //Recalculate index2
            index2 = this.indexOf(beforeItem);

            items.splice(index2, 0, item);
            keys.splice(index2, 0, key);

            return this;
        },

        /**
         * Checks the items whether an item is placed in first position.
         *
         * @function checkItemFirst(item)
         * @param {object} item An item to be moved.
         * @returns {webDoodling.Collection} Returns `true` if the item is in the first
         * position else `false`.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        checkItemFirst: function checkIsFirst(item) {
            return this.indexOf(item) === 0;
        },

        /**
         * Checks the items whether an item is on last position.
         *
         * @function checkItemLast(item)
         * @param {object} item An item to be moved
         * @returns {webDoodling.Collection} Returns `true` if the item is on the last
         * position else `false`.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        checkItemLast: function checkIsLast(item) {
            return this.indexOf(item) === this.length - 1;
        },

        /**
         * Removes all the items and clears the collection.
         *
         * @function clear()
         * @returns {webDoodling.Collection} Returns the current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        clear: function clear() {
            this._items.length = 0;
            this._keys.length = 0;
            this._map = {};
            return this;
        },

        /**
         * Finds and returns the index of specified item.
         *
         * @function indexOf(item)
         * @param {Object} item An item of which index is to be found.
         * @returns {webDoodling.Collection} Returns the zero based index of specfied item.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        indexOf: function indexOf(item) {
            return this._items.indexOf(item);
        },

        /**
         * Iterate through each item in the collection and calls the callback function.
         *
         * @function each(callback, context)
         * @param {function} callback The callback function which  needs to be invoked.
         * @param {Object} context The context under which callback function needs to be executed.
         * @returns {webDoodling.Collection} Returns the current object useful for chaining.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        each: function each(callback, context) {
            var items, i, len;
            items = this._items;
            if (context === undefined) {
                context = this;
            }

            for (i = 0, len = items.length; i < len; i++) {
                callback.call(context, items[i]);
            }
            return this;
        },

        /**
         * Converts and returns the collections in the form of `toArray`.
         *
         * @function toArray()
         * @returns {Array} The array.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        toArray: function toArray() {
            return this._items.slice();
        },

        serialize: function () {
            var result = [];

            if (this.length === 0) {
                return; //No need to serialize this when length is 0
            }

            this.each(function (item) {
                if (item instanceof wd.Serializable) {
                    result.push(item.serialize());
                }


            }, this);

            return result;
        },

        deserialize: function (array) {
            var item, i, iLen,
                existingItem,
                key,
                addNew;

            if (array instanceof Array === false) {
                throw new wd.Error("wd-not-an-array");
            }

            for(i=0, iLen = array.length; i < iLen; i += 1) {
                item = array[i];
                addNew = true;

                if (wd.is.plainObject(item) && "type" in item) {
                    if (this.keyName in item) {
                        existingItem = this.get(item[this.keyName]);

                        // If item exists and if it is a serializable
                        // deserialize it.
                        if (existingItem) {
                            if (existingItem instanceof wd.Serializable === false) {
                                throw new wd.Error("wd-not-a-serializable");
                            }

                            //Delete attribute with key name, because in some of the item
                            //key once set cannot be set again.
                            key = item[this.keyName];
                            delete item[this.keyName];
                            existingItem.deserialize(item);
                            item[this.keyName] = key;
                            addNew = false;
                        }
                    }
                    if (addNew) {
                        this.add(wd.typeRegistry.getInstance(item.type, item));
                    }
                }
                else {
                    this.add(item);
                }
            }
        },

        /**
         * Return the string representation of current instances.
         *
         * @function toString()
         * @returns {string} Always[object webDoodling.Collection]
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Collection]";
        },

        //Private methods

        _swap: function (index1, index2) {
            var items = this._items,
                keys = this._keys,
                itemX = items[index1],
                keyX = keys[index1];

            items[index1] = items[index2];
            keys[index1] = keys[index2];

            items[index2] = itemX;
            keys[index2] = keyX;
        },

        _findIndexKey: function (indexOrKey) {
            var index, key;
            if (typeof indexOrKey === "number") {
                index = indexOrKey;
                key = this._keys[index];
            }
            else {
                index = this._keys.indexOf(indexOrKey);
                key = indexOrKey;
            }
            if (index < 0 || index >= this.length) {
                throw new wd.Error("wd-index-out-of-range", index.toString());
            }
            return [index, key];
        },

        _findIndexKeyByItem: function (item) {
            var index = this._items.indexOf(item);
            return this._findIndexKey(index);
        }

    }, wd.Serializable);

    wd.Collection = Collection;
    // /**
    //  * This function is internal use for `webDoodling`
    //  *
    //  * @function importObject(o, key, value)
    //  * @param {object} o An object.
    //  * @param {string} key
    //  * @param {any} value
    //  * @returns
    //  *
    //  * @static webDoodling.Collection
    //  * @internal
    //  * @version 1.0
    //  **/
    // wd.Collection.importObject = function importObject(o, key, value) {
    //     var list = o[key];
    //     if (list instanceof wd.Collection === false) {
    //         throw new wd.Error("wd-operation-not-supported", "set");
    //     }
    //     //Clear the collection
    //     list.clear();
    //     if (value instanceof Array) {
    //         list.add.apply(list, value);
    //     }
    //     else if (value.toArray !== undefined) {
    //         list.add.apply(list, value.toArray());
    //     }
    //     else {
    //         list.add(value);
    //     }
    // };

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Asset
(function (wd, undefined) {
    "use strict";

    /**
     * Represents a Error class which stores error and its error code.
     *
     * @class webDoodling.Error
     * @extends Error
     * @example
     * throw new wd.Error(numberOrMessage);
     *
     * @public
     * @version 1.0
     **/
    wd.Error = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.Error`, always returns'Error'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
        type: wd.type("Error"),

        /**
         * Returns the stack trace of the error.
         *
         * @field {string} stack
         * @default undefined
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
         // stack

        /**
         * Returns the name of the error.
         *
         * @field {string} name
         * @default undefined
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
        name: wd.attribute("Error"),

        /**
         * Returns the `number` of the `webDoodling.Error`.
         *
         * @field {number} errorCode
         * @default 0
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
        errorCode: wd.attribute(),

        /**
         * Returns the `error` of the `webDoodling.Error`.
         *
         * @field {string} error
         * @default ""
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
        message: wd.attribute(""),

        /**
         * Returns the `additionalInfo` of the `webDoodling.Error`.
         *
         * @field {string} additionalInfo
         * @default ""
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
        additionalInfo: wd.attribute(""),

        /**
         * Prevents initialization of `webDoodling.Error` object.
         *
         * @constructor init(numberOrMessage, [additionalInfo])
         * @param {number or string} numberOrMessage the error or number of the error
         * @param {[additionalInfo]} additionalInfo The additional information about the error.
         *
         * @example
         * throw new wd.Error("wd-no-argument"); // Throws "wd-no-argument" error.
         * throw new wd.Error("wd-not-a-number", key1); // Throws "wd-not-a-number" error and sets error's additionalInfo with current value of key1.
         * throw new wd.Error("wd-invalid-argument", "key", "value"); // Throws "wd-invalid-argument" error and sets additionalInfo to [key, value].
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
        init: function init(errorCode) {
            var message = wd.errors.get(errorCode),
                additionalInfo = [].slice.call(arguments, 1);

            if (message !== undefined) {
                this.errorCode = errorCode;
                this.message = message;
            }
            else {
                this.message = errorCode;
            }

            // Initialize additionalInfo
            if (additionalInfo.length === 0) {
                additionalInfo = "";
            }
            else if (additionalInfo.length === 1) {
                additionalInfo = additionalInfo[0];
            }
            this.additionalInfo = additionalInfo;

            Error.captureStackTrace(this, this.constructor);
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Error].
         *
         * @memberOf webDoodling.Error
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "webDoodling.Error: " +
                    (this.errorCode ? "(" + this.errorCode + ") " : "") +
                    (this.message || "") +
                    ((this.additionalInfo) ?
                        (" (" +
                        (wd.is.array(this.additionalInfo) ? this.additionalInfo.join(", ") : this.additionalInfo.toString()) +
                        ")") : "");
        }
    }, Error);
})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Asset
(function (wd) {
    "use strict";

    var Errors,
        _errorMessageMap;

    /**
     * Represents a Errors class which stores error codes and associated messages.
     * This is a singleton object and can be accessed using `webDoodling.errors`;
     *
     * @example
     * webDoodling.errors.register("wd-new-error-code", "This is just a test error message.");
     *
     * @class webDoodling.Errors
     * @example
     * throw new wd.Errors(numberOrMessage);
     *
     * @public
     * @version 1.0
     **/
    Errors = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.Errors`, always returns'Errors'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Errors
         * @public
         * @version 1.0
         **/
        type: wd.type("Errors"),

        /**
         * Registers the error codes and associated messages wtih
         * `webDoodling.errors` so that they can be t
         *
         * @function register(errorCodes)
         * @param {object} errorCodes The object which consists of key value pair of errorCodes and errorMessages
         * @example
         * wd.errors.register({
         *     "my-error": "This is my error.",
         *     "my-error2": "This is my second error."
         * });
         *
         * @function register(errorCode, errorMessage)
         * @param {string} errorCode The error code.
         * @param {string} errorMessage The error message for given errorCode.
         * @example
         * wd.errors.register("my-errror", "This is my error.");
         *
         * @returns {webDoodling.Errors} Returns this, usefull for chaining.
         *
         * @memberOf webDoodling.Errors
         * @public
         * @version 1.0
         **/
        register: function () {
            var arg1, arg2, errorCode;

            if (arguments.length === 1 && wd.is.plainObject(arg1)) {
                for(errorCode in arg1) {
                    if (arg1.hasOwnProperty(errorCode)) {
                        if (errorCode in _errorMessageMap) {
                            throw new wd.Error("wd-error-code-already-defined");
                        }
                        _errorMessageMap[errorCode] = arg1[errorCode];
                    }
                }
            }
            else if(arguments.length === 2) {
                if (arg1 in _errorMessageMap) {
                    throw new wd.Error("wd-error-code-already-defined");
                }
                _errorMessageMap[arg1] = arg2;
            }
            return this;
        },

        /**
         * Returns an error message if supplied code is already registered with the `wd.errors`.
         *
         * @function get(errorCodes)
         * @param {string} errorCode The error code.
         *
         * @example
         * var errorMessage = wd.errors.get("wd-not-an-array");
         *
         * @returns {string} The error message if errorCode is registered otherwise `undefined`.
         *
         * @memberOf webDoodling.Errors
         * @public
         * @version 1.0
         **/
        get: function get (errorCode) {
            return _errorMessageMap[errorCode];
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Errors].
         *
         * @memberOf webDoodling.Errors
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Errors]";
        }
    });


    _errorMessageMap = {

        // Core ////////
        "wd-error-code-already-defined"         : "Error code already defined.",
        "wd-operation-not-supported"            : "Operation not supported.",
        "wd-unknown-error"                      : "An unknown error occurred.",
        "wd-not-implemented"                    : "Not Implemented.",

        "wd-type-readonly"                      : "Can not set type, it is readonly.",
        "wd-invalid-color"                      : "Invalid color",

        // Support ////////
        "wd-canvas-not-supported"               : "WebDoodling cannot be used as HTML5 Canvas is not supported in current browser.",
        "wd-browser-not-supported"              : "Not Supported in this browser.",
        "wd-audio-not-supported"                : "Audio not supported.",
        "wd-animation-not-supported"            : "Animation not supported.",

        // Argument ////////
        "wd-not-an-array"                       : "Expecting an array.",
        "wd-not-a-string"                       : "Expecting a string.",
        "wd-not-a-number"                       : "Expecting a number.",
        "wd-not-an-object"                      : "Expecting an object.",
        "wd-not-a-tweenable"                    : "Animation not supported, expecting a tweenable.",
        "wd-not-a-serializable"                 : "Item not a serializable.",

        "wd-invalid-argument"                   : "One or more arguments passed are not valid, please see documentation.",
        "wd-no-argument"                        : "Argument not supplied. Please see documentation for more information.",

        //Collection ////////
        "wd-item-not-found"                     : "Item not found.",
        "wd-items-not-found"                    : "One or more of specified items not found.",
        "wd-item-already-exists"                : "Item already exists.",

        // DisplayObject ////////
        "wd-id-required"                        : "Missing id while calculating DisplayObject's absolute path.",
        "wd-parent-id-not-found"                : "Missing parent id while calculating DisplayObject's absolute path.",
        "wd-display-object-id-immutable"        : "DisplayObject id once set can not be changed.",
        "wd-display-object-already-associated"  : "DisplayObject already associated with this or other scene.",

        // Timeline and Animation ////////
        "wd-timeline-immutable"                 : "Timeline is an immutable object which can not be changed once active.",
        "wd-stop-greater-than-start"            : "The stop vlaue should always be greater than start.",
        "wd-tweens-cannot-be-removed"           : "Tweens can not be removed from the collection once added.",
        "wd-relative-operator-not-supported"    : "Tweenable relative operator not supported.",

        // Serialization ////////
        "wd-error-while-serializing"            : "Error occured while serializing object.",

        // Http Errors ////////
        "wd-http-404"                           : "File not found.",
        "wd-http-request-timeout"               : "Request timedout.",
        "wd-http-request-aborted"               : "Request aborted.",

        // Plugins ////////
        "wd-image-source-type-not-supported"    : "Unsupported image source type.",
        "wd-type-already-registered"            : "Type already registered.",
        "wd-missing-type-in-object"             : "Invalid object, missing 'type' in first argument.",

        // Audio ////////
        "wd-audio-playback-aborted"             : "You aborted the audio playback.",
        "wd-audio-download-failed"              : "A network error caused the audio download to fail.",
        "wd-browser-does-not-support-audio"     : "The audio playback was aborted due to a corruption problem or because the audio used features your browser did not support.",
        "wd-audio-not-loaded"                   : "The audio not be loaded, either because the server or network failed or because the format is not supported.",
        "wd-not-audio"                          : "Given file is not a audio file.",
        "wd-audio-load-network-issues"          : "There is some network issues. File not be loaded.",

        // Others ////////
        "wd-properties-not-supported"           : "Properties are not supported in the current environment.",
        "wd-index-out-of-range"                 : "Index out of range.",
        "wd-error-while-validating-argument"    : "Error while validating argument."
    };

    wd.errors = new Errors();

})(window.webDoodling);

(function (wd) {

    var logo;

    logo="";
    logo += "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
    logo += "<!-- Copyright (C) 2015-2016 Maniar Technologies Private Limited. -->";
    logo += "<!DOCTYPE svg PUBLIC \"-\/\/W3C\/\/DTD SVG 1.1\/\/EN\" \"http:\/\/www.w3.org\/Graphics\/SVG\/1.1\/DTD\/svg11.dtd\">";
    logo += "<svg version=\"1.1\" id=\"Logo\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" x=\"0px\" y=\"0px\"";
    logo += "     width=\"500px\" height=\"500px\" viewBox=\"0 0 500 500\" enable-background=\"new 0 0 500 500\" xml:space=\"preserve\">";
    logo += "<g>";
    logo += "    <!-- Red -->";
    logo += "    <radialGradient id=\"red\" cx=\"334.3496\" cy=\"195.6016\" r=\"168.8382\" gradientTransform=\"matrix(-0.9893 0 0 0.9863 496.3789 3.0942)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"0\" style=\"stop-color:#EF4546\"\/>";
    logo += "        <stop  offset=\"0.1872\" style=\"stop-color:#E54040\"\/>";
    logo += "        <stop  offset=\"0.5021\" style=\"stop-color:#D23132\"\/>";
    logo += "        <stop  offset=\"0.8\" style=\"stop-color:#BE2026\"\/>";
    logo += "    <\/radialGradient>";
    logo += "";
    logo += "    <path fill=\"url(#red)\" d=\"M86.561,291.28c14.47,8.566,30.848,14.258,46.177,14.431c20.234-0.146,44.134-11.808,53.409-38.872";
    logo += "        c4.193-12.007,5.981-34.155-10.119-53.902c-9.041-10.84-23.997-20.145-42.007-20.334c-3.511-0.041-40.485,1.222-77.478,32.949";
    logo += "        C28.162,248.852,2.299,287.171,0.015,343.142c0,0-1.55,48.129,27.189,88.949c22.391,32.835,63.134,66.075,130.111,67.9";
    logo += "        c0,0,52.193,0.269,93.188-31.484c0,0-12.855-9.733-21.621-19.758c0,0-24.479,18.688-63.749,17.369";
    logo += "        c-16.042-1.072-38.674-6.918-56.271-19.341c-3.259-2.188-40.834-28.168-45.143-77.238c-1.893-24.238,4.676-67.067,38.496-94.326";
    logo += "        c2.487-2.007,20.486-19.841,38.911-19.98c23.3,2.073,30.842,32.791-2.189,43.258C122.019,302.851,111.732,301.125,86.561,291.28z\"";
    logo += "        \/>";
    logo += "";
    logo += "    <radialGradient id=\"red-tail\" cx=\"289.1279\" cy=\"375.5273\" r=\"39.1822\" gradientTransform=\"matrix(0.9818 0 0 0.988 4.6851 1.7769)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"0\" style=\"stop-color:#EF4546\"\/>";
    logo += "        <stop  offset=\"0.1583\" style=\"stop-color:#DB3D3D\"\/>";
    logo += "        <stop  offset=\"0.7115\" style=\"stop-color:#B02527\"\/>";
    logo += "        <stop  offset=\"1\" style=\"stop-color:#A11E21\"\/>";
    logo += "    <\/radialGradient>";
    logo += "";
    logo += "    <path fill=\"url(#red-tail)\" d=\"M290.28,413.678c9.074-21.905,10.677-33.914,8.775-45.84c-3.026-18.248-13.217-24.71-13.804-25.14";
    logo += "        c-6.448-4.846-19.586-6.466-27.408,5.897c9.28-7.924,19.469-2.503,20.296-2.011c12.802,7.683,10.619,36.608-2.219,53.353";
    logo += "        c0,0,1.988,2.464,5.174,5.574C284.394,409.111,290.28,413.678,290.28,413.678z\"\/>";
    logo += "";
    logo += "    <!-- blue -->";
    logo += "    <radialGradient id=\"blue\" cx=\"286.7832\" cy=\"138.0601\" r=\"142.1644\" gradientTransform=\"matrix(0.9893 0 0 0.9863 2.062 3.0942)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"0.0299\" style=\"stop-color:#B1D3DD\"\/>";
    logo += "        <stop  offset=\"0.1605\" style=\"stop-color:#A7CFDD\"\/>";
    logo += "        <stop  offset=\"0.3793\" style=\"stop-color:#8BC3DE\"\/>";
    logo += "        <stop  offset=\"0.658\" style=\"stop-color:#58B3DF\"\/>";
    logo += "        <stop  offset=\"0.8\" style=\"stop-color:#2AAAE2\"\/>";
    logo += "    <\/radialGradient>";
    logo += "    <path fill=\"url(#blue)\" d=\"M209.615,86.301c-8.595,14.426-14.308,30.762-14.479,46.041c0.155,20.172,11.847,44,38.985,53.247";
    logo += "        c12.052,4.181,34.263,5.959,54.07-10.088c10.879-9.017,20.211-23.929,20.403-41.885c0.039-3.493-1.232-40.36-33.049-77.245";
    logo += "        C252.164,28.077,213.73,2.292,157.6,0.014c0,0-48.276-1.542-89.225,27.103C35.447,49.442,0.246,92.058,0.044,156.765";
    logo += "        c0,0-2.604,49.282,32.357,93.691c0,0,9.794-12.987,19.964-21.343c0,0-19.431-25.318-18.116-64.472";
    logo += "        c1.081-15.996,6.945-38.558,19.398-56.104c2.204-3.245,28.259-40.71,77.469-45.005c24.313-1.891,67.275,4.658,94.616,38.381";
    logo += "        c2.01,2.475,19.902,20.422,20.036,38.791c-2.076,23.237-32.885,30.752-43.39-2.178C197.899,122.063,199.742,111.403,209.615,86.301";
    logo += "        z\"\/>";
    logo += "";
    logo += "    <radialGradient id=\"blue-tail\" cx=\"129.4844\" cy=\"290.791\" r=\"30.6882\" gradientTransform=\"matrix(0.9886 0.0381 -0.0383 0.9835 12.5703 -2.1978)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"0.0299\" style=\"stop-color:#A1CFE0\"\/>";
    logo += "        <stop  offset=\"0.1013\" style=\"stop-color:#92C3D8\"\/>";
    logo += "        <stop  offset=\"0.3895\" style=\"stop-color:#5E9DC0\"\/>";
    logo += "        <stop  offset=\"0.6035\" style=\"stop-color:#3689B2\"\/>";
    logo += "        <stop  offset=\"0.7181\" style=\"stop-color:#2282AD\"\/>";
    logo += "    <\/radialGradient>";
    logo += "";
    logo += "    <path fill=\"url(#blue-tail)\" d=\"M86.466,291.28c22.282,8.91,34.094,10.786,45.945,8.539c17.474-2.277,24.834-13.166,25.261-13.756";
    logo += "        c4.768-6.617,6.368-19.667-6.053-27.438c7.985,9.26,2.614,19.503,2.125,20.331c-7.62,12.874-36.863,10.837-53.695-1.942";
    logo += "        c0,0-2.15,1.808-5.489,5.042C89.189,287.576,86.466,291.28,86.466,291.28z\"\/>";
    logo += "";
    logo += "    <!-- Green -->";
    logo += "    <radialGradient id=\"green\" cx=\"369.7178\" cy=\"283.834\" r=\"140.2626\" gradientTransform=\"matrix(0.7396 -0.655 0.6923 0.777 -102.1344 304.6773)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"0\" style=\"stop-color:#B6C1A4\"\/>";
    logo += "        <stop  offset=\"0.0072\" style=\"stop-color:#B5C1A3\"\/>";
    logo += "        <stop  offset=\"0.556\" style=\"stop-color:#99C35E\"\/>";
    logo += "        <stop  offset=\"0.8\" style=\"stop-color:#8DC641\"\/>";
    logo += "    <\/radialGradient>";
    logo += "    <path fill=\"url(#green)\" d=\"M413.52,209.089c-14.47-8.568-30.94-14.381-46.267-14.551c-20.234,0.151-44.136,11.811-53.41,38.869";
    logo += "        c-4.198,12.012-5.979,34.161,10.113,53.905c11.303,13.547,25.835,20.168,42.011,20.343c24.976,0.277,49.677-9.11,77.48-32.947";
    logo += "        c28.379-23.311,54.242-61.628,56.521-117.602c0,0,1.554-48.129-27.186-88.951c-22.389-32.832-65.131-67.93-130.031-68.124";
    logo += "        c0,0-55.451,0.356-93.078,31.598c0,0,12.812,9.75,21.578,19.775c0,0,24.327-18.589,63.604-17.275";
    logo += "        c16.04,1.077,38.676,6.923,56.271,19.341c3.256,2.194,40.83,28.169,45.135,77.236c1.899,24.243-4.671,67.066-38.489,94.333";
    logo += "        c-2.486,2.007-20.484,19.839-38.911,19.975c-23.635-2.073-30.503-33.103,2.199-43.509";
    logo += "        C377.983,197.138,388.71,199.361,413.52,209.089z\"\/>";
    logo += "";
    logo += "    <radialGradient id=\"green-tail\" cx=\"315.8555\" cy=\"134.6572\" r=\"40.6154\" gradientTransform=\"matrix(-0.0043 -0.9936 0.9959 -0.0042 80.7378 439.3086)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"0\" style=\"stop-color:#B1C491\"\/>";
    logo += "        <stop  offset=\"0.0951\" style=\"stop-color:#ADC28D\"\/>";
    logo += "        <stop  offset=\"0.2343\" style=\"stop-color:#A3BD80\"\/>";
    logo += "        <stop  offset=\"0.4006\" style=\"stop-color:#94B569\"\/>";
    logo += "        <stop  offset=\"0.5864\" style=\"stop-color:#7FAB4B\"\/>";
    logo += "        <stop  offset=\"0.6625\" style=\"stop-color:#74A741\"\/>";
    logo += "    <\/radialGradient>";
    logo += "    <path fill=\"url(#green-tail)\" d=\"M209.635,86.227c-9.253,22.036-11.141,33.882-9.197,45.868";
    logo += "        c2.756,17.805,13.489,24.854,14.087,25.287c6.71,4.823,19.975,6.5,27.945-5.944c-9.459,7.979-19.852,2.531-20.69,2.032";
    logo += "        c-13.064-7.718-10.853-36.808,2.235-53.652c0,0-2.028-2.482-5.283-5.608C215.219,90.584,209.635,86.227,209.635,86.227z\"\/>";
    logo += "";
    logo += "    <!-- Gold -->";
    logo += "    <radialGradient id=\"gold\" cx=\"375.4502\" cy=\"212.1411\" r=\"34.9279\" gradientTransform=\"matrix(0.9864 0 0 0.9879 2.4355 2.8496)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"8.522600e-04\" style=\"stop-color:#F3C28F\"\/>";
    logo += "        <stop  offset=\"0.1294\" style=\"stop-color:#EBB47C\"\/>";
    logo += "        <stop  offset=\"0.4956\" style=\"stop-color:#D8934C\"\/>";
    logo += "        <stop  offset=\"0.7647\" style=\"stop-color:#CD8131\"\/>";
    logo += "        <stop  offset=\"0.9058\" style=\"stop-color:#C97A29\"\/>";
    logo += "    <\/radialGradient>";
    logo += "    <path fill=\"url(#gold)\" d=\"M413.449,209.062c-21.837-9.281-33.955-10.915-45.87-9.04c-17.682,2.661-24.73,13.272-25.161,13.863";
    logo += "        c-4.813,6.638-6.533,19.79,5.783,27.753c-7.874-9.427-2.427-19.712-1.934-20.536c7.721-12.931,36.595-10.613,53.257,2.445";
    logo += "        c0,0,2.522-1.908,5.639-5.123C408.762,215.105,413.449,209.062,413.449,209.062z\"\/>";
    logo += "";
    logo += "    <radialGradient id=\"gold-tail\" cx=\"223.1035\" cy=\"370.3398\" r=\"89.9014\" fx=\"301.4119\" fy=\"326.1804\" gradientTransform=\"matrix(-0.9893 0 0 0.9863 496.3789 3.0942)\" gradientUnits=\"userSpaceOnUse\">";
    logo += "        <stop  offset=\"8.522600e-04\" style=\"stop-color:#F3C28F\"\/>";
    logo += "        <stop  offset=\"0.1107\" style=\"stop-color:#F4BF89\"\/>";
    logo += "        <stop  offset=\"0.286\" style=\"stop-color:#F4B777\"\/>";
    logo += "        <stop  offset=\"0.5049\" style=\"stop-color:#F5A959\"\/>";
    logo += "        <stop  offset=\"0.7567\" style=\"stop-color:#F7972A\"\/>";
    logo += "        <stop  offset=\"0.8\" style=\"stop-color:#F79421\"\/>";
    logo += "    <\/radialGradient>";
    logo += "    <path fill=\"url(#gold-tail)\" d=\"M290.389,413.705c8.592-14.432,14.307-30.764,14.477-46.05";
    logo += "        c-0.154-20.169-11.848-44.001-38.991-53.245c-12.049-4.19-34.259-5.964-54.062,10.087c-10.877,9.018-20.212,23.929-20.405,41.875";
    logo += "        c-0.037,3.502,1.233,40.371,33.048,77.252c23.38,28.3,61.818,54.079,117.947,56.361c0,0,48.274,1.541,89.226-27.113";
    logo += "        c32.926-22.312,68.125-64.932,68.323-129.638c0,0,2.707-49.162-32.259-93.569c0,0-9.861,12.606-19.914,21.348";
    logo += "        c0,0,19.29,25.193,17.969,64.344c-1.076,15.995-6.941,38.559-19.397,56.107c-2.196,3.242-28.252,40.708-77.462,45.005";
    logo += "        c-24.313,1.886-67.271-4.663-94.615-38.378c-2.015-2.479-19.904-20.423-20.044-38.798c2.082-23.235,32.895-30.752,43.396,2.178";
    logo += "        C301.413,377.696,300.261,388.599,290.389,413.705z\"\/>";
    logo += "<\/g>";
    logo += "<\/svg>";
    logo += "";

    wd.logoSVG = logo;


}) (window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The browser object
(function (wd, undefined) {
    "use strict";

        /**
         * The `webDoodling.browser` namespace contains utility functions to manage browser related
         * stuffs like events etc...
         *
         * @module webDoodling.browser
         *
         * @memberOf webDoodling
         * @public
         * @version 1.0
         **/
    wd.browser = {

        /**
         * Attach the event to the elements.
         *
         * @function on(elm, type, handler)
         * @param {HtmlElement} elm The html element for which event is to be attached.
         * @param {string} type The type or name of an event. For example "click", "mousemove" etc...
         * @param {function} handler The event handler function.
         *
         * @memberOf webDoodling.browser
         * @public
         * @version 1.0
         **/
        on: function on(elm, type, handler) {
            var el = this.$(elm);
            if (el.addEventListener) {
                el.addEventListener(type, handler, false);
            }
            else {
                el.attachEvent("on" + type, handler);
            }
        },

        /**
         * Detach the event to the elements.
         *
         * @function off(elm, type, handler)
         * @param {HtmlElement} elm The html element for which event is to be detach.
         * @param {string} type The type or name of the event.
         * @param {function} handler The event handler function.
         *
         * @memberOf webDoodling.browser
         * @public
         * @version 1.0
         **/
        off: function off(elm, type, handler) {
            var el = this.$(elm);
            if (el.addEventListener) {
                el.removeEventListener(type, handler, false);
            }
            else {
                el.detachEvent("on" + type, handler);
            }
        },

        /**
         * Returns the current element.
         *
         * @function $()
         * @param {string, HtmlElement} elm The element.
         *
         * @memberOf webDoodling.browser
         * @public
         * @version 1.0
         **/
        $: function $(elm) {
            if (typeof elm === "string") {
                return document.getElementById(elm);
            }
            return elm;
        },

        /**
         * Get the `style` of the current element.
         *
         * @function getStyle(elm, style)
         * @param {string, HtmlElement} elm Gets the computed style of html element.
         * @param {string} style The style of the element.
         *
         * @memberOf webDoodling.browser
         * @public
         * @version 1.0
         **/
        getStyle: function getStyle(elm, style) {
            elm = wd.browser.$(elm);
            var s = getComputedStyle(elm);
            if (style === undefined) {
                return s;
            }
            return s.getPropertyValue(style);
        }
    };

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Geometry
(function (wd) {
    "use strict";

    ///////////// Geometry ///////////////

    var geometry = {},
        sqrt = Math.sqrt,

        getPointDistance = function getPointDistance(x1, y1, x2, y2) {
            var dx = x2 - x1,
                dy = y2 - y1;
            return sqrt(dx * dx + dy * dy);
        },

        getPointDistance2 = function getPointDistance2(p1, p2) {
            var dx = p2.x - p1.x,
                dy = p2.y - p1.y;
            return sqrt(dx * dx + dy * dy);
        };


    //wd.Size           = Size;
    //wd.Bound          = Bound;
    geometry.getPointDistance = getPointDistance;
    geometry.getPointDistance2 = getPointDistance2;
    wd.geometry = geometry;

})(window.webDoodling);

(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Arc;

    /**
      * geometry.Arc gives arc related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Arc = (function () {
        /**
          * geometry.Arc.getBoundingBox represents the Arc bounding box.
          *
          * @example
          * box = wd.geometry.Arc.getBoundingBox(x, y, radius, startAngle, endAngle, anticlockwise);
          *
          * param {number} x the x position of arc.
          * param {number} y the y position of arc.
          * param {number} radius the radius of arc.
          * param {number} startAngle the startAngle of arc.
          * param {number} endAngle the endAngle positioof arc.
          * param {boolean} anticlockwise the direction of arc.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (x, y, radius, startAngle, endAngle, anticlockwise) {
                var start, end,
                    arc, startX, startY, endX, endY, xArr,yArr, size;

                start = startAngle * Math.PI / 180;
                end = endAngle * Math.PI / 180;
                if (anticlockwise) {
                    start = endAngle * Math.PI / 180;
                    end = startAngle * Math.PI / 180;
                }
                arc = _getArcCircle(x, y, radius, start, end);
                startX = x + radius * Math.cos(start);
                startY = y + radius * Math.sin(start);

                endX = x + radius * Math.cos(end);
                endY = y + radius * Math.sin(end);

                xArr = [startX, endX].concat(arc[0]);
                yArr = [startY, endY].concat(arc[1]);

                size = _boxSize({
                    x1: Math.max.apply(this, xArr),
                    y1: Math.max.apply(this, yArr),
                    x2: Math.min.apply(this, xArr),
                    y2: Math.min.apply(this, yArr)
                });

                return {x: size.x, y: size.y, width: size.width, height: size.height};
            },

            _getArcCircle = function (x, y, radius, start, end) {
                var fullCircle = start + 2 * Math.PI <= end || end + 2 * Math.PI <= start,
                    xLeft = x - radius,
                    xRight = x + radius,
                    yTop = y + radius,
                    yBottom = y - radius,
                    xArr = [],
                    yArr = [];

                if (fullCircle || _angleBetween(start, end, 0 * Math.PI)){
                    xArr.push(xRight);
                    yArr.push(y);
                }
                if (fullCircle || _angleBetween(start, end, 0.5 * Math.PI)){
                    xArr.push(x);
                    yArr.push(yTop);
                }
                if (fullCircle || _angleBetween(start, end, 1 * Math.PI)){
                    xArr.push(xLeft);
                    yArr.push(y);
                }
                if (fullCircle || _angleBetween(start, end, 1.5 * Math.PI)){
                    xArr.push(x);
                    yArr.push(yBottom);
                }

                return [xArr, yArr];
            },

            _angleBetween = function (start, end, angle) {
                start = (start + 2 * Math.PI) % (2 * Math.PI);
                end = (end + 2 * Math.PI) % (2 * Math.PI);

                if (start <= end) {
                    if (start <= angle && angle <= end) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                else if (start >= end){
                    if (start >= angle && angle >= end){
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            },

            _boxSize = function (params) {
                var h, w, leftX, topY;
                h  = Math.abs(params.y2 - params.y1);
                w  = Math.abs(params.x2 - params.x1);
                leftX =  ( params.x1 < params.x2) ? params.x1 : params.x2;
                topY = ( params.y1 < params.y2) ? params.y1 : params.y2;
                return {x: leftX, y: topY, height: h, width: w};
            };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Arc = Arc;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Line;

    /**
      * geometry.Line gives Line related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Line = (function () {

        var _calcSlope = function (x1, y1, x2, y2) {
                var dx = (x2 - x1),
                    dy = (y2 - y1);
                return Math.atan2(dy, dx);
            },
            _toArray = function (x1, y1, x2, y2) {
                //Ref: http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm

                var dx = Math.abs(x2 - x1),
                    dy = Math.abs(y2 - y1),
                    sx = (x1 < x2) ? 1 : -1,
                    sy = (y1 < y2) ? 1 : -1,
                    err = dx - dy,
                    loop = true,
                    points = [];

                while (loop) {
                    points.push({ x: x1, y: y1 });
                    if (x1 == x2 && y1 == y2) {
                        break;
                    }

                    var e2 = 2 * err;
                    if (e2 > -dy) {
                        err = err - dy;
                        x1 = x1 + sx;
                    }

                    if (e2 < dx) {
                        err = err + dx;
                        y1 = y1 + sy;
                    }
                }

                return points;
            },

            /**
              * geometry.Line.getBoundingBox represents the Line bounding box.
              *
              * @example
              * box = wd.geometry.Line.getBoundingBox(x1, y1, x2, y2);
              *
              * param {number} x1 the startX position of Line.
              * param {number} y1 the startY position of Line.
              * param {number} x2 the endX position of Line.
              * param {number} y2 the endY position of Line.
              *
              * @memberOf webDoodling.geometry
              * @public
              * @version 1.0
              **/
            _getBoundingBox = function (x1, y1, x2, y2) {
                var x, y, h, w;
                x = Math.min(x1, x2);
                y = Math.min(y1, y2);
                h = Math.max(y1, y2);
                w = Math.max(x1, x2);
                return {x: x, y: y, height: h - y, width: w - x};
            };

        return {
            calcSlope: _calcSlope,
            toArray: _toArray,
            getBoundingBox: _getBoundingBox
        };

    })(),

    geometry.Line = Line;

})(window.webDoodling);

(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Circle;

    /**
      * geometry.Circle gives Circle related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/

    Circle = (function () {
        /**
          * geometry.Circle.getBoundingBox represents the Circle bounding box.
          *
          * @example
          * box = wd.geometry.Circle.getBoundingBox(x, y, radius);
          *
          * param {number} x the x position of circle.
          * param {number} y the y position of circle.
          * param {number} radius the radius of circle.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (x, y, radius) {
            return {x: x - radius, y: y - radius, width: radius * 2, height: radius * 2};
        };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Circle = Circle;

})(window.webDoodling);
(function (wd, undefined) {
    "use strict";

    var geometry = wd.geometry,
        min = Math.min,
        max = Math.max,
        QuadraticCurve;

    /**
     * Represent the `QuadraticCurve` object.
     *
     * @event QuadraticCurve(e)
     * +-----------+------------------------------------------------+
     * | name      | description                                    |
     * +===========+================================================+
     * | eventName | The name of the event always `QuadraticCurve`. |
     * +-----------+------------------------------------------------+
     *
     * @memberOf webDoodling.Bound
     * @public
     * @version 1.0
     **/
    QuadraticCurve = (function () {

        var _calcBaseValue = function (t, a, b, c) {
                var mt = 1 - t;
                return mt * mt * a + 2 * mt * t * b + t * t * c;
            },

            _calcFirstDerivativeRoot = function (a, b, c) {
                var t = -1,
                    denominator = a - 2 * b + c;

                if (denominator !== 0) {
                    t = (a - b) / denominator;
                }
                return t;
            },

            _getPointAt = function getPointAt(t, x1, y1, cpx, cpy, x2, y2) {
                var x = _calcBaseValue(t, x1, cpx, x2),
                    y = _calcBaseValue(t, y1, cpy, y2);
                return {
                    x: x,
                    y: y
                };
            },

            _getBoundingBox = function getBoundingBox(x1, y1, cpx, cpy, x2, y2) {

                var minx = 9999,
                    miny = 9999,
                    maxx = -9999,
                    maxy = -9999,
                    t;

                minx = min(minx, x1);
                maxx = max(maxx, x1);
                minx = min(minx, x2);
                maxx = max(maxx, x2);

                t = _calcFirstDerivativeRoot(x1, cpx, x2);
                if (t >= 0 && t <= 1) {
                    var x = _calcBaseValue(t, x1, cpx, x2);
                    minx = min(minx, x);
                    maxx = max(maxx, x);
                }

                miny = min(miny, y1);
                maxy = max(maxy, y1);
                miny = min(miny, y2);
                maxy = max(maxy, y2);

                t = _calcFirstDerivativeRoot(y1, cpy, y2);
                if (t >= 0 && t <= 1) {
                    var y = _calcBaseValue(t, y1, cpy, y2);
                    miny = min(miny, y);
                    maxy = max(maxy, y);
                }

                return {
                    x: minx,
                    y: miny,
                    width: maxx - minx,
                    height: maxy - miny
                };
            },

        // Toooo Slow, need to be improved.
            _toArray = function (x1, y1, cpx, cpy, x2, y2) {

                var ts = [],
                    points = {},
                    ret = [],
                    addPoint = function (t, p) {
                        if (points[t] === undefined) {
                            ts.push(t);
                            points[t] = p;
                        }
                    },
                    isFinal = function (p1, p2) {
                        if (geometry.getPointDistance2(p1, p2) < 3) {
                            return true;
                        }
                        return false;
                    },
                    loop = function (t1, t2, p1, p2) {

                        var mt = (t2 + t1) / 2;
                        if (mt <= 0 || mt >= 1) {
                            return;
                        }

                        var midPoint = _getPointAt(mt, x1, y1, cpx, cpy, x2, y2);
                        //console.log(isFinal(mt, midPoint));
                        addPoint(mt, midPoint);
                        if (isFinal(p1, midPoint) === false) {
                            loop(t1, mt, p1, midPoint);
                        }
                        if (isFinal(midPoint, p2) === false) {
                            loop(mt, t2, midPoint, p2);
                        }
                    };

                addPoint(0, { x: x1, y: y1 });
                addPoint(1, { x: x2, y: y2 });
                loop(0, 1, { x: x1, y: y1 }, { x: x2, y: y2 });

                ts.sort();
                for (var i = 0, iLen = ts.length; i < iLen; i++) {
                    var t = ts[i],
                        p = points[t];
                    ret.push(p);
                }
                return ret;
            };

        return {

            /**
             * Gets the bounding box of Quadratic Curve.
             **/
            getBoundingBox: _getBoundingBox,

            /**
             * Gets the point at particular
             **/
            getPointAt: _getPointAt,

            toArray: _toArray
        };


    })();

    geometry.QuadraticCurve = QuadraticCurve;

})(window.webDoodling);
(function (wd, undefined) {
    "use strict";

    var geometry = wd.geometry,
        min = Math.min,
        max = Math.max,
        sqrt = Math.sqrt,
        BezierCurve;

    /**
     * Represent the `BezierCurve` object.
     *
     * @event BezierCurve(e)
     * +-----------+------------------------------------------------+
     * | name      | description                                    |
     * +===========+================================================+
     * | eventName | The name of the event always `BezierCurve`.    |
     * +-----------+------------------------------------------------+
     *
     * @memberOf webDoodling.Bound
     * @public
     * @version 1.0
     **/
    BezierCurve = (function () {

        var _calcBaseValue = function (t, a, b, c, d) {
                var mt = 1 - t;
                return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;
            },

            _calcFirstDerivativeRoots = function (a, b, c, d) {
                var ret = [-1, -1],
                    tl = -a + 2 * b - c,
                    tr = -sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),
                    dn = -a + 3 * b - 3 * c + d;

                if (dn !== 0) {
                    ret[0] = (tl + tr) / dn;
                    ret[1] = (tl - tr) / dn;
                }
                return ret;
            },

            _getPointAt = function (t, x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2) {

                var x = _calcBaseValue(t, x1, cp1x, cp2x, x2),
                    y = _calcBaseValue(t, y1, cp1y, cp2y, y2);

                return {
                    x: x,
                    y: y
                };
            },

            _getBoundingBox = function getBoundingBox(x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2) {
                var minx = 9999,
                    miny = 9999,
                    maxx = -9999,
                    maxy = -9999,
                    t, ts,
                    x, y,
                    i, iLen;

                minx = min(minx, x1);
                maxx = max(maxx, x1);
                minx = min(minx, x2);
                maxx = max(maxx, x2);

                ts = _calcFirstDerivativeRoots(x1, cp1x, cp2x, x2);

                for (i = 0, iLen = ts.length; i < iLen; i++) {
                    t = ts[i];
                    if (t >= 0 && t <= 1) {
                        x = _calcBaseValue(t, x1, cp1x, cp2x, x2);
                        minx = min(minx, x);
                        maxx = max(maxx, x);
                    }
                }


                miny = min(miny, y1);
                maxy = max(maxy, y1);
                miny = min(miny, y2);
                maxy = max(maxy, y2);

                ts = _calcFirstDerivativeRoots(y1, cp1y, cp2y, y2);
                for (i = 0, iLen = ts.length; i < iLen; i++) {
                    t = ts[i];
                    if (t >= 0 && t <= 1) {
                        y = _calcBaseValue(t, y1, cp1y, cp2y, y2);
                        miny = min(miny, y);
                        maxy = max(maxy, y);
                    }
                }

                return {
                    x: minx,
                    y: miny,
                    width: maxx - minx,
                    height: maxy - miny
                };
            },

            _toArray = function (x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2) {

                var ts = [],
                    points = {},
                    ret = [],
                    addPoint = function (t, p) {
                        if (points[t] === undefined) {
                            ts.push(t);
                            points[t] = p;
                        }
                    },
                    isFinal = function (p1, p2) {
                        if (geometry.getPointDistance2(p1, p2) < 3) {
                            return true;
                        }
                        return false;
                    },
                    loop = function (t1, t2, p1, p2) {

                        var mt = (t2 + t1) / 2;
                        if (mt <= 0 || mt >= 1) {
                            return;
                        }

                        var midPoint = _getPointAt(mt, x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2);
                        //console.log(isFinal(mt, midPoint));
                        addPoint(mt, midPoint);
                        if (isFinal(p1, midPoint) === false) {
                            loop(t1, mt, p1, midPoint);
                        }
                        if (isFinal(midPoint, p2) === false) {
                            loop(mt, t2, midPoint, p2);
                        }
                    };

                addPoint(0, { x: x1, y: y1 });
                addPoint(1, { x: x2, y: y2 });
                loop(0, 1, { x: x1, y: y1 }, { x: x2, y: y2 });

                ts.sort();
                for (var i = 0, iLen = ts.length; i < iLen; i++) {
                    var t = ts[i],
                        p = points[t];
                    ret.push(p);
                }
                return ret;
            };

        return {
            getPointAt: _getPointAt,
            getBoundingBox: _getBoundingBox,
            toArray: _toArray
        };

    })();

    geometry.BezierCurve = BezierCurve;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Path;

    /**
      * geometry.Path gives path related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Path = (function () {
        /**
          * geometry.Path.getBoundingBox represents the Path bounding box.
          *
          * @example
          * box = wd.geometry.Arc.getBoundingBox(segments);
          *
          * param {object} segments the segments of path.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (segments) {
            var rect = [],
                box, lastX, lastY;

            segments.each(function (seg) {
                var x = seg.x,
                    y = seg.y,
                    points = null;

                if (seg instanceof wd.MoveTo) {
                    lastX = x;
                    lastY = y;
                    rect.push({x: lastX, y: lastY, width: 0, height: 0});
                }
                else if (seg instanceof wd.LineTo) {
                    points = geometry.Line.getBoundingBox(lastX, lastY, seg.x, seg.y);
                    rect.push({x: points.x, y: points.y, width: points.width, height: points.height});
                    lastX = x;
                    lastY = y;
                }
                else if (seg instanceof wd.QuadraticCurveTo) {
                    points = geometry.QuadraticCurve.getBoundingBox(lastX, lastY, seg.cpx, seg.cpy, seg.x, seg.y);
                    rect.push({x: points.x, y: points.y, width: points.width, height: points.height});
                    lastX = x;
                    lastY = y;
                }
                else if (seg instanceof wd.BezierCurveTo) {
                    points = geometry.BezierCurve.getBoundingBox(lastX, lastY, seg.cp1x, seg.cp1y,
                        seg.cp2x, seg.cp2y, seg.x, seg.y);
                    rect.push({x: points.x, y: points.y, width: points.width, height: points.height});
                    lastX = x;
                    lastY = y;
                }
            });
            if (rect.length === 1) {
                return {x: rect[0].x, y: rect[0].y, width: rect[0].width, height: rect[0].height};
            }
            else {
                box = geometry.Rectangle.getCompundBoundingBox(rect);
                //box = _getBox(rect);
                return {x: box.x, y: box.y, width: box.width, height: box.height};
            }
        };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Path = Path;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Pie;

    /**
      * geometry.Pie gives pie related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Pie = (function () {
        /**
          * geometry.Pie.getBoundingBox represents the Pie bounding box.
          *
          * @example
          * box = wd.geometry.Pie.getBoundingBox(x, y, radius, startAngle, endAngle, anticlockwise);
          *
          * param {number} x the x position of pie.
          * param {number} y the y position of pie.
          * param {number} radius the radius of pie.
          * param {number} startAngle the startAngle of pie.
          * param {number} endAngle the endAngle positioof pie.
          * param {boolean} anticlockwise the direction of pie.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (x, y, radius, startAngle, endAngle, anticlockwise) {
                return _getBox(x, y, radius, startAngle, endAngle, anticlockwise);
            },
            _getBox = function (x, y, radius, startAngle, endAngle, anticlockwise) {
                var rectArr = [],
                    startCenter, endCenter;
                rectArr.push(geometry.Arc.getBoundingBox(x, y, radius, startAngle, endAngle, anticlockwise));
                startCenter = {x: x, y: y, width: Math.cos(startAngle), height: Math.sin(startAngle)};
                endCenter = {x: x, y: y, width: Math.cos(endAngle), height: Math.sin(endAngle)};
                rectArr.push(startCenter, endCenter);
                return geometry.Rectangle.getCompundBoundingBox(rectArr);
            };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Pie = Pie;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Polygon;

    /**
      * geometry.Polygon gives polygon related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Polygon = (function () {
        /**
          * geometry.Polygon.getBoundingBox represents the Polygon bounding box.
          *
          * @example
          * box = wd.geometry.Polygon.getBoundingBox(x, y, radius, sides);
          *
          * param {number} x the x position of polygon.
          * param {number} y the y position of polygon.
          * param {number} radius the radius of polygon.
          * param {number} sides the sides of polygon.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (x, y, radius, totalSides) {
            var sides = Math.round(totalSides),
                x2, y2, i, offsetX, offsetY, delta_theta, theta,
                pointsX = [], pointsY = [], minX, minY, maxX, maxY;

            delta_theta = 2.0 * Math.PI / sides;
            theta = 0;

            for (i = 0; i < sides; i++) {
                x2 = (radius * Math.cos(theta));
                y2 = (radius * Math.sin(theta));
                offsetX = x + x2;
                offsetY = y + y2;
                pointsX.push(offsetX);
                pointsY.push(offsetY);
                theta += delta_theta;
            }

            minX = Math.min.apply(this, pointsX);
            minY = Math.min.apply(this, pointsY);
            maxX = Math.max.apply(this, pointsX);
            maxY = Math.max.apply(this, pointsY);
            return {x: minX, y: minY, height: maxY - minY, width: maxX - minX};
        };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Polygon = Polygon;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Spline;

    /**
      * geometry.Spline gives spline related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Spline = (function () {
        /**
          * geometry.Spline.getBoundingBox represents the Spline bounding box.
          *
          * @example
          * box = wd.geometry.Spline.getBoundingBox(points, tension, x, y);
          *
          * param {number} x the x position of spline.
          * param {number} y the y position of spline.
          * param {array} points the points of spline.
          * param {number} tension the sharpness of spline.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (points, tension, x, y) {
                var box = _getBox(points, tension, x, y);
                return {x: box.x, y: box.y, width: box.width, height: box.height};
            },

            _distance = function (p, i, j) {
                return Math.sqrt(Math.pow(p[2 * i] - p[2 * j], 2) + Math.pow(p[2 * i + 1] - p[2 * j + 1], 2));
            },

            _vector = function (p, i, j) {
                return [p[2 * j] - p[2 * i], p[2 * j + 1] - p[2 * i + 1]];
            },

            _controlPoints = function (x1, y1, x2, y2, x3, y3, t) {
                var v = _vector(arguments, 0, 2),
                    d01 = _distance(arguments, 0, 1),
                    d12 = _distance(arguments, 1, 2),
                    d012 = d01 + d12;
                return [x2 - v[0] * t * d01 / d012, y2 - v[1] * t * d01 / d012,
                        x2 + v[0] * t * d12 / d012, y2 + v[1] * t * d12 / d012];
            },

            _getBox = function (points, tension, x, y) {
                var i, iLen, cpx, cpy, cpx1, cpy1, cpx2, cpy2,
                    previousX, previousY, nextX, nextY, currentX, currentY, startX, startY, positionX, positionY,
                    minX, maxX, minY, maxY,
                    controls = [],
                    finalPointsX = [],
                    finalPointsY = [];

                x = x || 0;
                y = y || 0;

                if (points instanceof wd.PointCollection) {
                    points = points._items;
                }

                if (points.length === 0) {
                    return;
                }

                if (points.length === 1) {
                    return;
                }

                if (points.length === 2) {
                    finalPointsX.push(points[0].x, points[1].x);
                    finalPointsY.push(points[0].y, points[1].y);
                    minX = Math.min.apply(this, finalPointsX);
                    maxX = Math.max.apply(this, finalPointsX);
                    minY = Math.min.apply(this, finalPointsY);
                    maxY = Math.max.apply(this, finalPointsY);
                    return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
                }

                startX = points[0].x;
                startY = points[0].y;

                positionX = points[1].x;
                positionY = points[1].y;

                finalPointsX.push(startX);
                finalPointsY.push(startY);

                for (i = 1, iLen = points.length - 1; i < iLen; i += 1) {
                    previousX = points[i - 1].x;
                    previousY = points[i - 1].y;
                    currentX = points[i].x;
                    currentY = points[i].y;
                    nextX = points[i + 1].x;
                    nextY = points[i + 1].y;

                    controls = controls.concat(
                        _controlPoints(previousX, previousY,
                                       currentX, currentY,
                                       nextX, nextY, tension));
                }
                cpx = controls[0];
                cpy = controls[1];
                finalPointsX.push(cpx, positionX);
                finalPointsY.push(cpy, positionY);
                for (i = 2, iLen = points.length - 1; i < iLen; i += 1) {
                    cpx1 = controls[(2 * (i - 1) - 1) * 2];
                    cpy1 = controls[(2 * (i - 1) - 1) * 2 + 1];
                    cpx2 = controls[(2 * (i - 1)) * 2];
                    cpy2 = controls[(2 * (i - 1)) * 2 + 1];
                    positionX = points[i].x;
                    positionY = points[i].y;
                    finalPointsX.push(cpx1, cpx2, positionX);
                    finalPointsY.push(cpy1, cpy2, positionY);
                }
                cpx = controls[(2 * (i - 1) - 1) * 2];
                cpy = controls[(2 * (i - 1) - 1) * 2 + 1];
                positionX = points[i].x;
                positionY = points[i].y;
                finalPointsX.push(cpx, positionX);
                finalPointsY.push(cpy, positionY);
                minX = Math.min.apply(this, finalPointsX);
                maxX = Math.max.apply(this, finalPointsX);
                minY = Math.min.apply(this, finalPointsY);
                maxY = Math.max.apply(this, finalPointsY);
                return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
            };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Spline = Spline;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Star;

    /**
      * geometry.Star gives star related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Star = (function () {
        /**
          * geometry.Star.getBoundingBox represents the Star bounding box.
          *
          * @example
          * box = wd.geometry.Star.getBoundingBox(x, y, radius, sides);
          *
          * param {number} x the x position of star.
          * param {number} y the y position of star.
          * param {number} radius the radius of star.
          * param {number} sides the sides of star.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (x, y, radius, sides) {
                return _getBox(x, y, radius, sides);
            },

            _getBox = function (x, y, radius, sides) {
                var i,
                    delta_theta = 2.0 * Math.PI / sides,
                    theta = 2.0 * Math.PI / 8,
                    x2, y2, offsetX, offsetY,
                    pointsX = [],
                    pointsY = [],
                    minX, maxX, minY, maxY;

                for (i = 0; i < sides; i++) {

                    x2 = (radius * Math.cos(theta));
                    y2 = (radius * Math.sin(theta));
                    offsetX = x + x2;
                    offsetY = y + y2;
                    pointsX.push(offsetX);
                    pointsY.push(offsetY);
                    theta += delta_theta;
                }

                minX = Math.min.apply(this, pointsX);
                maxX = Math.max.apply(this, pointsX);
                minY = Math.min.apply(this, pointsY);
                maxY = Math.max.apply(this, pointsY);

                return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
            };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Star = Star;

})(window.webDoodling);
(function (wd, undefined) {
    "use strict";

    var geometry = wd.geometry,
        Text;

    /**
      * geometry.Text gives text related calculation.
      *
      * @memberOf webDoodling.geometry
      * @public
      * @version 1.0
      **/
    Text = (function () {
        /**
          * geometry.Text.getBoundingBox represents the Text bounding box.
          *
          * @example
          * box = wd.geometry.Text.getBoundingBox(ctx, x, y, font, textAlign, textBaseline, text);
          *
          * param {context} ctx the extra context for text measure.
          * param {number} x the x position of text.
          * param {number} y the y position of text.
          * param {number} font the font of text.
          * param {number} textAlign the textAlign of text.
          * param {number} textBaseline the textBaseline of text.
          * param {boolean} text the text.
          *
          * @memberOf webDoodling.geometry
          * @public
          * @version 1.0
          **/
        var _getBoundingBox = function (ctx, x, y, font, textAlign, textBaseline, text) {
                var size;
                ctx.font = font;
                ctx.textAlign = textAlign;
                ctx.textBaseline = textBaseline;
                size = _measureText(ctx, text, font);
                ctx.save();
                //center, right, left, end, start
                if (textAlign === "center") {
                    x = x - (size.width / 2);
                }
                else if (textAlign === "right" || textAlign === "end") {
                    x = x - size.width;
                }
                //top, bottom, alphabetic, ideographic, hanging, middle
                if (textBaseline === "middle") {
                    y = y - (size.height / 2);
                }
                else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
                    y = y - size.height;
                }
                ctx.restore();

                return {x: x, y: y, width: size.width, height: size.height};
            },

            _measureText = function (ctx, text, font) {
                var w, h, div;
                w = ctx.measureText(text).width;
                div = document.createElement("div");
                div.innerHTML = text;
                div.style.margin = "0px";
                div.style.border = "0px";
                div.style.padding = "0px";
                div.style.position = "absolute";
                div.style.font = font;
                div.style.color = "transparent";
                document.body.appendChild(div);
                if (div.offsetHeight !== undefined) {
                    h = div.offsetHeight;
                }
                else {
                    h = ctx.measureText("M").width;
                }
                document.body.removeChild(div);
                return {
                    width: w,
                    height: h
                };
            };

        return {
            getBoundingBox: _getBoundingBox,
            measureText: _measureText
        };
    })();

    geometry.Text = Text;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Point;

    Point = (function () {
        var _getBoundingBox = function (pointArr) {
            var minX, minY, maxX, maxY,
                x, y, i, iLen;
            for (i = 0, iLen = pointArr.length; i < iLen; i++) {
                x.push(pointArr[i].x);
                y.push(pointArr[i].y);
            }
            minX = Math.min.apply(this, x);
            minY = Math.min.apply(this, y);
            maxX = Math.max.apply(this, x);
            maxY = Math.max.apply(this, y);
            return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
        };
        return {
            getBoundingBox: _getBoundingBox
        };
    })();

    geometry.Point = Point;

})(window.webDoodling);
(function (wd) {
    "use strict";

    var geometry = wd.geometry,
        Rectangle;

    Rectangle = (function () {
        var _getCompundBoundingBox = function (rect) {
                var i, maxX, maxY, minX, minY, iLen,
                    x = [],
                    y = [];

                for (i = 0, iLen = rect.length; i < iLen; i++) {
                    x.push(rect[i].x, rect[i].x + rect[i].width);
                    y.push(rect[i].y, rect[i].y + rect[i].height);
                }

                minX = Math.min.apply(this, x);
                maxX = Math.max.apply(this, x);
                minY = Math.min.apply(this, y);
                maxY = Math.max.apply(this, y);

                return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
            },
            _intersect = function (xPos, yPos, width, height, baseWidth, baseHeight)  {
                var x, y, w, h, region, baseRegion, topRegion;

                baseRegion = {
                    x: 0,
                    y: 0,
                    height: baseHeight,
                    width: baseWidth
                };

                topRegion = {
                    x: xPos,
                    y: yPos,
                    height: height,
                    width: width
                };
                if (topRegion.x + topRegion.width < 0 ||
                    topRegion.y + topRegion.height < 0 ||
                    topRegion.x > baseRegion.width ||
                    topRegion.y > baseRegion.height) {
                    return null;
                }

                x = Math.min(topRegion.x, Math.max((topRegion.x + topRegion.width),0));
                y = Math.min(topRegion.y, Math.max((topRegion.y + topRegion.height),0));

                w = Math.min(topRegion.width, Math.max((baseRegion.width - topRegion.x),0)); //600
                h = Math.min(topRegion.height, Math.max((baseRegion.height - topRegion.y),0)); //500

                w = Math.min(Math.max(w, 0), topRegion.width);
                h = Math.min(Math.max(h, 0), topRegion.height);

                region = {
                    x: x,
                    y: y,
                    width: w,
                    height: h
                };
                return region;
            };
        return {
            getCompundBoundingBox: _getCompundBoundingBox,
            intersect: _intersect
        };
    })();

    geometry.Rectangle = Rectangle;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Transformation Matrix
//Reference:
// Specification: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#transformations
// Wikipedia Article : http://en.wikipedia.org/wiki/Transformation_matrix
// SVGMatrix : https://developer.mozilla.org/en/DOM/SVGMatrix
(function (wd, undefined) {
    "use strict";

    var cos = Math.cos,
        sin = Math.sin,
        tan = Math.tan,
        atan = Math.atan,

        /**
         * Represents the  `webDoodlingTransformationMatrix` class.
         * ::
         *
         *   [a c e]
         *   [b d f]
         *   [0 0 1]
         *
         *
         * @class webDoodling.TransformationMatrix
         *
         * @public
         * @version 1.0
         **/
        TransformationMatrix = wd.Class({

            /**
             * Returns the `type` of `webDoodling.TransformationMatrix`,
             * always returns "TransformationMatrix".
             *
             * @field {string} type
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            type: wd.type("TransformationMatrix"),

            /**
             * Gets or sets the value `a` in this matrix. Also respresents position 0, 0
             * in a 3x3 affine `TransformationMatrix`.
             *
             * @field {number} a
             * @returns
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            a: wd.property({
                value: 1,
                get: function () {
                    return this._matrix[0];
                },
                set: function (val) {
                    this._matrix[0] = val;
                }
            }),

            /**
             * Gets or sets the value `b` in this matrix. Also respresents position 1, 0
             * in a 3x3 affine `TransformationMatrix`.
             *
             * @field {number} b
             * @returns
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            b: wd.property({
                value: 1,
                get: function () {
                    return this._matrix[1];
                },
                set: function (val) {
                    this._matrix[1] = val;
                }
            }),

            /**
             * Gets or sets the value `c` in this matrix. Also respresents position 0, 1
             * in a 3x3 affine `TransformationMatrix`.
             *
             * @readonly {number} c
             * @returns
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            c: wd.property({
                value: 1,
                get: function () {
                    return this._matrix[2];
                },
                set: function (val) {
                    this._matrix[2] = val;
                }
            }),

            /**
             * Gets or sets the value `d` in this matrix. Also respresents position 1, 1
             * in a 3x3 affine `TransformationMatrix`.
             *
             * @readonly {number} d
             * @returns
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            d: wd.property({
                value: 1,
                get: function () {
                    return this._matrix[3];
                },
                set: function (val) {
                    this._matrix[3] = val;
                }
            }),

            /**
             * Gets or sets the value `e` in this matrix. Also respresents position 0, 2
             * in a 3x3 affine `TransformationMatrix`.
             *
             * @field {number} e
             * @returns
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            e: wd.property({
                value: 1,
                get: function () {
                    return this._matrix[4];
                },
                set: function (val) {
                    this._matrix[4] = val;
                }
            }),

            /**
             * Gets or sets the value `f` in this matrix. Also respresent position 1, 2
             * in a 3x3 affine `TransformationMatrix`.
             *
             * @field {number} f
             * @returns
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            f: wd.property({
                value: 1,
                get: function () {
                    return this._matrix[5];
                },
                set: function (val) {
                    this._matrix[5] = val;
                }
            }),

            /**
             * Checks whether the current matrix is an identity matrix or not.
             *
             * @readonly {boolean} isIdentity
             * @returns Return true if current matrix is an identiy matrix else false.
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            isIdentity: wd.readonly({
                get: function () {
                    var m = this._matrix;
                    return  m[0] === 1 &&
                        m[1] === 0 &&
                        m[2] === 0 &&
                        m[3] === 1 &&
                        m[4] === 0 &&
                        m[5] === 0;
                }
            }),

            // TODO: Need to add description
            /**
             * Initializes the new instance of `webDoodling.TransformationMatrix`.
             *
             * @constructor init(a, b, c, d, e, f)
             * @param {number} a
             * @param {number} b
             * @param {number} c
             * @param {number} d
             * @param {number} e
             * @param {number} f
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            init: function init(a, b, c, d, e, f) {
                var m = [1, 0, 0, 1, 0, 0], matrix = a;
                if (arguments.length === 6) {
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = e;
                    m[5] = f;
                }
                else if (matrix instanceof TransformationMatrix) {
                    m[0] = matrix[0];
                    m[1] = matrix[1];
                    m[2] = matrix[2];
                    m[3] = matrix[3];
                    m[4] = matrix[4];
                    m[5] = matrix[5];
                }
                this._matrix = m;
            },

            /**
             * Applies the scale transformation to the matrix.
             *
             * @function scale(x, y)
             * @param {number} x The x scale.
             * @param {number} y The y scale. If optional, function will perform uniform scale.
             * @returns {webDoodling.math.TransformationMatrix} The current instance.
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            scale: function scale(x, y) {
                var m = this._matrix;
                if (y === undefined) {
                    y = x;
                }
                m[0] *= x;
                m[1] *= x;
                m[2] *= y;
                m[3] *= y;
                return this;
            },

            /**
             * Applies the translate transform to the current instance of the matrix.
             *
             * @function translate(x, y)
             * @param {number} x The x transform value.
             * @param {number} y The y transform value.
             * @returns {webDoodling.math.TransformationMatrix} The current instance.
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            translate: function translate(x, y) {
                var m = this._matrix;
                m[4] += m[0] * x + m[2] * y;
                m[5] += m[1] * x + m[3] * y;
                return this;
            },

            /**
             * Applies the `rotate` transform to the current instance of the matrix.
             *
             * @function rotate(rad)
             * @param {number} rad The rotation in radian.
             * @returns {webDoodling.math.TransformationMatrix} The current instance.
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            rotate: function rotate(rad) {

                var m = this._matrix,
                    cosa = cos(rad),
                    sina = sin(rad),
                    msina = -sina,
                    a = m[0] * cosa + m[2] * sina,
                    b = m[1] * cosa + m[3] * sina,
                    c = m[0] * msina + m[2] * cosa,
                    d = m[1] * msina + m[3] * cosa;

                this._matrix = [a, b, c, d, m[4], m[5]];
                return this;
            },

            /**
             * Applies the `rotateFromVector` to the current instance of the matrix.
             *
             * @function rotateFromVector(x, y)
             * @param {number} x The rotation in radian.
             * @param {number} y The rotation in radian.
             * @returns {webDoodling.math.TransformationMatrix} The current instance.
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            rotateFromVector: function rotateFromVector(x, y) {
                var angle = atan(y / x),
                    sina, msina, cosa,
                    a, b, c, d,
                    m = this._matrix;

                if (y < 0) { angle = -angle; }
                sina = sin(angle);
                msina = -sina;
                cosa = cos(angle);

                a = m[0] * cosa + m[2] * sina;
                b = m[1] * cosa + m[3] * sina;
                c = m[0] * msina + m[2] * cosa;
                d = m[1] * msina + m[3] * cosa;

                this._matrix = [a, b, c, d, m[4], m[5]];
                return this;
            },

            // TODO: Need to add description
            /**
             * TODO: Implementation Pending
             * @function skew( angleX, angleY)
             * @param {number} angleX
             * @param {number} angleY
             *
             * @public
             * @version 1.0
             **/
            skew: function skew(/** angleX, angleY **/) {
                throw new wd.Error("wd-not-implemented");
            },

            /**
             * Applies skewX transformation.
             *
             * @function skewX(angle)
             * @param {number} angle
             *
             * @public
             * @version 1.0
             **/
            skewX: function skewX(angle) {
                var tana = tan(angle),
                    m = this._matrix;

                m[2] += m[0] * tana;
                m[3] += m[1] * tana;
                return this;
            },

            /**
             * Applies skewY transformation.
             *
             * @function skewY(angle)
             * @param {number} angle
             *
             * @public
             * @version 1.0
             **/
            skewY: function skewY(angle) {
                var tana = tan(angle),
                    m = this._matrix;

                m[0] += m[2] * tana;
                m[1] += m[3] * tana;
                return this;
            },

            /**
             * Applies flipX transformation.
             *
             * @function flipX()
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            flipX: function flipX() {
                var m = this._matrix;
                m[0] = -m[0];
                m[1] = -m[1];
                return this;
            },

            /**
             * Applies flipY transformation.
             *
             * @function flipX()
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            flipY: function flipY() {
                var m = this._matrix;
                m[2] = -m[2];
                m[3] = -m[3];
                return this;
            },

            // TODO
            /**
             * Multiplies current matrix with supplied matrix.
             *
             * @function multiply(matrix)
             * @param  {Array} matrix
             * @returns {[type]}        [description]
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            multiply: function multiply(matrix) {

                var m = this._matrix,
                    m2 = matrix._matrix,
                    a = m[0] * m2[0] + m[2] * m2[1],
                    b = m[1] * m2[0] + m[3] * m2[1],
                    c = m[0] * m2[2] + m[2] * m2[3],
                    d = m[1] * m2[2] + m[3] * m2[3],
                    e = m[0] * m2[4] + m[2] * m2[5] + m[4],
                    f = m[1] * m2[4] + m[3] * m2[5] + m[5];

                this._matrix = [a, b, c, d, e, f];
                return this;
            },

            // TODO: Need to provide description for commeting
            /**
             *
             * @function inverse()
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            inverse: function inverse() {

                var m = this._matrix,
                    det = 1 / (m[0] * m[3] - m[1] * m[2]);

                var a = m[3] * det,
                    b = -m[1] * det,
                    c = -m[2] * det,
                    d = m[0] * det,
                    e = det * (m[2] * m[5] - m[3] * m[4]),
                    f = det * (m[1] * m[4] - m[0] * m[5]);

                this._matrix = [a, b, c, d, e, f];
                return this;
            },

            // TODO: Need to provide description for commeting
            /**
             *
             * @function transformPoint(x, y)
             * @param {number} x
             * @param {number} y
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            transformPoint: function transformPoint(x, y) {
                var xx = x,
                    yy = y,
                    m = this._matrix;

                x = xx * m[0] + yy * m[2] + m[4];
                y = xx * m[1] + yy * m[3] + m[5];

                return {
                    x: x,
                    y: y
                };
            },

            // TODO: Need to provide description for commeting
            /**
             *
             * @function setTransform(a, b, c, d, e, f)
             * @param {number} a
             * @param {number} b
             * @param {number} c
             * @param {number} d
             * @param {number} e
             * @param {number} f
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            setTransform: function setTransform(a, b, c, d, e, f) {
                this._matrix = [a, b, c, d, e, f];
            },

            // TODO: Need to add Description
            /**
             *
             * @function reset()
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            reset: function reset() {
                this._matrix = [1, 0, 0, 1, 0, 0];
            },

            // TODO: Need to add description
            /**
             *
             * @function updateContext(ctx)
             * @param {2dcontext} ctx
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            updateContext: function updateContext(ctx) {
                var m = this._matrix;
                ctx.setTransformm(m[0], m[1], m[2], m[3], m[4], m[5]);
            },

            /**
             * Returns the string representation of current instance.
             *
             * @function toString()
             * @returns {string} Always returns [object TransformationMatrix]
             *
             * @memberOf webDoodling.TransformationMatrix
             * @public
             * @version 1.0
             **/
            toString: function toString() {
                return "[object wd.TransformationMatrix]";
            }
        });

    TransformationMatrix.identity = function identity() {
        return new TransformationMatrix();
    };

    wd.TransformationMatrix = TransformationMatrix;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Services
(function (wd, undefined) {
    "use strict";

    var utils = wd.utils,
        ColorService;

    /**
     * Represents the service class which provides the next color in sequence.
     *
     * @class webDoodling.ColorService
     *
     * @public
     * @version 1.0
     **/
    ColorService = wd.Class({

        /**
         * Returns the `type` of `webDoodling.ColorService`, always "ColorService".
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ColorService
         * @public
         * @version 1.0
         **/
        type: wd.type("ColorService"),

        /**
         * Increments the number which produces next color.
         *
         * @readonly {number} increment
         * @default 10
         *
         * @memberOf webDoodling.ColorService
         * @public
         * @version 1.0
         **/
        increment: wd.readonly(10),

        /**
         * Initializes the new instance of `webDoodling.ColorService`.
         *
         * @constructor init(increment)
         * @param {number} increment The next step in color.
         *
         * @memberOf webDoodling.ColorService
         * @public
         * @version 1.0
         **/
        init: function init(increment) {
            if (increment !== undefined) {
                this._increment = increment;
            }
            this._color = 0;
        },

        /**
         * Increments the color in sequence and returns the next color.
         *
         * @function next()
         * @returns {string} The next color hex format.
         *
         * @memberOf webDoodling.ColorService
         * @public
         * @version 1.0
         */
        next: function next() {

            var color = this._color + this._increment,
                r, g, b;

            this._color = color;

            r = color >> 16;
            g = color >> 8 & 0xFF;
            b = color & 0xFF;

            return "#" + toHex(r) + toHex(g) + toHex(b);
        },

        /**
         * Return the string representation of current instances.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ColorService]
         *
         * @memberOf webDoodling.ColorService
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ColorService]";
        }
    });

    utils.ColorService = ColorService;

    function toHex(num) {
        var v = num.toString(16);
        if (v.length === 1) {
            return "0" + v;
        }
        return v;
    }

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Services
(function (wd) {
    "use strict";

    var utils = wd.utils,
        NameService;

    /**
     * Represents the service class which provides the name in the sequence.
     *
     * @class webDoodling.NameService
     *
     * @public
     * @version 1.0
     **/
    NameService = wd.Class({

        /**
         * Returns the `type` of `webDoodling.NameService`,
         * always returns "NameService".
         *
         * @field {string} type
         *
         * @memberOf webDoodling.NameService
         * @public
         * @version 1.0
         **/
        type: wd.type("NameService"),

         /**
          * Initializes the new instance of `webDoodling.NameService`.
          *
          * @constructor init()
          *
          * @memberOf webDoodling.NameService
          * @public
          * @version 1.0
          **/
        init: function init(prefix) {
            this._counter = 0;
            this._prefix = prefix;
        },

        /**
         * Returns the next name in the sequence.
         *
         * @function next(key)
         * @param {string} key The sequence identifier.
         * @returns {string} The next name in sequence.
         *
         * @memberOf webDoodling.NameService
         * @public
         * @version 1.0
         **/
        next: function next() {
            this._counter += 1;
            return this._prefix + this._counter;
        },

         /**
          * Return the string representation of current instances.
          *
          * @function toString()
          * @returns {string} Always returns [object webDoodling.NameService]
          *
          * @memberOf webDoodling.NameService
          * @public
          * @version 1.0
          **/
        toString: function toString() {
            return "[object webDoodling.NameService]";
        }
    });

    utils.NameService = NameService;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Services
(function (wd) {
    "use strict";

    var utils = wd.utils,
        NumberService;

    /**
     * Represents the service class which provides the numbers in sequence.
     *
     * @class webDoodling.NumberService
     *
     * @public
     * @version 1.0
     **/
    NumberService = wd.Class({

        /**
         * Returns the `type` of `webDoodling.NumberService`,
         * always returns "NumberService".
         *
         * @field {string} type
         *
         * @memberOf webDoodling.NumberService
         * @public
         * @version 1.0
         **/
        type: wd.type("NumberService"),

        /**
         * Initializes the new instance of `webDoodling.NumberService`.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.NumberService
         * @public
         * @version 1.0
         **/
        init: function init() {
            this._counter = 0;
        },

        /**
         * Returns the next number in sequence for given key.
         *
         * @function next(key)
         * @param {string} key The sequence identifier.
         * @returns {number} The next number in sequence.
         *
         * @memberOf webDoodling.NumberService
         * @public
         * @version 1.0
         **/
        next: function next() {
            this._counter += 1;
            return this._counter;
        },

        /**
         * Return the string representation of current instances.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.NumberService]
         *
         * @memberOf webDoodling.NumberService
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.NumberService]";
        }
    });

    utils.NumberService = NumberService;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Webdoodling color management
(function (wd, undefined) {
    "use strict";

    var _hexToColor = {},
        _nameToColor = {},
        _hexToName = {},
        _nameToHex = {},
        _parser, _nameHexList,
        Color;

    //CSS color parser
    _parser = {
        rgb: {
            re: /^rgb\s*\(\s*(\d+),\s*(\d+)\s*\,\s*(\d+)\s*\)$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr.replace(/\s/g, ""));
                return [
                    parseInt(bits[1], 10),
                    parseInt(bits[2], 10),
                    parseInt(bits[3], 10),
                    1.0
                ];
            }
        },
        rgba: {
            re: /^rgba\s*\(\s*(\d+),\s*(\d+)\s*\,\s*(\d+)\s*\,\s*(\d+\.?\d*)\)$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr.replace(/\s/g, ""));

                return [
                    parseInt(bits[1], 10),
                    parseInt(bits[2], 10),
                    parseInt(bits[3], 10),
                    parseFloat(bits[4])
                ];
            }
        },
        // FFFFFF, ffffff
        hex6: {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr);
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16),
                    1.0
                ];
            }
        },
        // #FFFFFF, #ffffff
        hex7: {
            re: /^#(\w{2})(\w{2})(\w{2})$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr);
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16),
                    1.0
                ];
            }
        },
        // FFF, fff
        hex3: {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr);
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16),
                    1.0
                ];
            }
        },
        // #FFF, #fff
        hex4: {
            re: /^#(\w{1})(\w{1})(\w{1})$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr);
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16),
                    1
                ];
            }
        },

        // hsl(190, 30%, 94%)
        hsl: {
            re: /^hsl\s*\(\s*(\d+),\s*(\d+\.?\d*)\%\s*\,\s*(\d+\.?\d*)\%\s*\)$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr.replace(/\s/g, ""));
                return [
                    parseInt(bits[1], 10),
                    parseFloat(bits[2]),
                    parseFloat(bits[3]),
                    1.0
                ];
            }
        },

        // hsla(190, 30%, 94%, 1)
        hsla: {
            re: /^hsla\s*\(\s*(\d+),\s*(\d+\.?\d*)\%\s*\,\s*(\d+\.?\d*)\%\s*\,\s*\d+\)$/,
            parse: function (colorStr) {
                var bits = this.re.exec(colorStr.replace(/\s/g,""));
                return [
                    parseInt(bits[1], 10),
                    parseInt(bits[2]),
                    parseInt(bits[3]),
                    parseFloat(bits[4])
                ];
            }
        }
    };

    //Reference: http://www.w3schools.com/html/html_colornames.asp
    _nameHexList = [
        ["aliceblue", "#f0f8ff"],
        ["antiquewhite", "#faebd7"],
        ["aqua", "#00ffff"],
        ["aquamarine", "#7fffd4"],
        ["azure", "#f0ffff"],
        ["beige", "#f5f5dc"],
        ["bisque", "#ffe4c4"],
        ["black", "#000000"],
        ["blanchedalmond", "#ffebcd"],
        ["blue", "#0000ff"],
        ["blueviolet", "#8a2be2"],
        ["brown", "#a52a2a"],
        ["burlywood", "#deb887"],
        ["cadetblue", "#5f9ea0"],
        ["chartreuse", "#7fff00"],
        ["chocolate", "#d2691e"],
        ["coral", "#ff7f50"],
        ["cornflowerblue", "#6495ed"],
        ["cornsilk", "#fff8dc"],
        ["crimson", "#dc143c"],
        ["cyan", "#00ffff"],
        ["darkblue", "#00008b"],
        ["darkcyan", "#008b8b"],
        ["darkgoldenrod", "#b8860b"],
        ["darkgray", "#a9a9a9"],
        ["darkgreen", "#006400"],
        ["darkkhaki", "#bdb76b"],
        ["darkmagenta", "#8b008b"],
        ["darkolivegreen", "#556b2f"],
        ["darkorange", "#ff8c00"],
        ["darkorchid", "#9932cc"],
        ["darkred", "#8b0000"],
        ["darksalmon", "#e9967a"],
        ["darkseagreen", "#8fbc8f"],
        ["darkslateblue", "#483d8b"],
        ["darkslategray", "#2f4f4f"],
        ["darkturquoise", "#00ced1"],
        ["darkviolet", "#9400d3"],
        ["deeppink", "#ff1493"],
        ["deepskyblue", "#00bfff"],
        ["dimgray", "#696969"],
        ["dodgerblue", "#1e90ff"],
        ["feldspar", "#d19275"],
        ["firebrick", "#b22222"],
        ["floralwhite", "#fffaf0"],
        ["forestgreen", "#228b22"],
        ["fuchsia", "#ff00ff"],
        ["gainsboro", "#dcdcdc"],
        ["ghostwhite", "#f8f8ff"],
        ["gold", "#ffd700"],
        ["goldenrod", "#daa520"],
        ["gray", "#808080"],
        ["green", "#008000"],
        ["greenyellow", "#adff2f"],
        ["honeydew", "#f0fff0"],
        ["hotpink", "#ff69b4"],
        ["indianred", "#cd5c5c"],
        ["indigo", "#4b0082"],
        ["ivory", "#fffff0"],
        ["khaki", "#f0e68c"],
        ["lavender", "#e6e6fa"],
        ["lavenderblush", "#fff0f5"],
        ["lawngreen", "#7cfc00"],
        ["lemonchiffon", "#fffacd"],
        ["lightblue", "#add8e6"],
        ["lightcoral", "#f08080"],
        ["lightcyan", "#e0ffff"],
        ["lightgoldenrodyellow", "#fafad2"],
        ["lightgrey", "#d3d3d3"],
        ["lightgreen", "#90ee90"],
        ["lightpink", "#ffb6c1"],
        ["lightsalmon", "#ffa07a"],
        ["lightseagreen", "#20b2aa"],
        ["lightskyblue", "#87cefa"],
        ["lightslateblue", "#8470ff"],
        ["lightslategray", "#778899"],
        ["lightsteelblue", "#b0c4de"],
        ["lightyellow", "#ffffe0"],
        ["lime", "#00ff00"],
        ["limegreen", "#32cd32"],
        ["linen", "#faf0e6"],
        ["magenta", "#ff00ff"],
        ["maroon", "#800000"],
        ["mediumaquamarine", "#66cdaa"],
        ["mediumblue", "#0000cd"],
        ["mediumorchid", "#ba55d3"],
        ["mediumpurple", "#9370d8"],
        ["mediumseagreen", "#3cb371"],
        ["mediumslateblue", "#7b68ee"],
        ["mediumspringgreen", "#00fa9a"],
        ["mediumturquoise", "#48d1cc"],
        ["mediumvioletred", "#c71585"],
        ["midnightblue", "#191970"],
        ["mintcream", "#f5fffa"],
        ["mistyrose", "#ffe4e1"],
        ["moccasin", "#ffe4b5"],
        ["navajowhite", "#ffdead"],
        ["navy", "#000080"],
        ["oldlace", "#fdf5e6"],
        ["olive", "#808000"],
        ["olivedrab", "#6b8e23"],
        ["orange", "#ffa500"],
        ["orangered", "#ff4500"],
        ["orchid", "#da70d6"],
        ["palegoldenrod", "#eee8aa"],
        ["palegreen", "#98fb98"],
        ["paleturquoise", "#afeeee"],
        ["palevioletred", "#d87093"],
        ["papayawhip", "#ffefd5"],
        ["peachpuff", "#ffdab9"],
        ["peru", "#cd853f"],
        ["pink", "#ffc0cb"],
        ["plum", "#dda0dd"],
        ["powderblue", "#b0e0e6"],
        ["purple", "#800080"],
        ["red", "#ff0000"],
        ["rosybrown", "#bc8f8f"],
        ["royalblue", "#4169e1"],
        ["saddlebrown", "#8b4513"],
        ["salmon", "#fa8072"],
        ["sandybrown", "#f4a460"],
        ["seagreen", "#2e8b57"],
        ["seashell", "#fff5ee"],
        ["sienna", "#a0522d"],
        ["silver", "#c0c0c0"],
        ["skyblue", "#87ceeb"],
        ["slateblue", "#6a5acd"],
        ["slategray", "#708090"],
        ["snow", "#fffafa"],
        ["springgreen", "#00ff7f"],
        ["steelblue", "#4682b4"],
        ["tan", "#d2b48c"],
        ["teal", "#008080"],
        ["thistle", "#d8bfd8"],
        ["tomato", "#ff6347"],
        ["turquoise", "#40e0d0"],
        ["violet", "#ee82ee"],
        ["violetred", "#d02090"],
        ["wheat", "#f5deb3"],
        ["white", "#ffffff"],
        ["whitesmoke", "#f5f5f5"],
        ["yellow", "#ffff00"],
        ["yellowgreen", "#9acd32"]
    ],

    /**
     * Represents the `webDoodling.Color` object, which provides color parsing,
     * conversion and other color utilities.
     *
     * @class webDoodling.Color
     * @example
     * // Initialize color by name
     * var color = new webDoodling.Color("red");
     *
     * // Initialize color css value
     * var color = new webDoodling.Color("#FF0099");
     * var color = new webDoodling.Color("rgba(200, 0, 0)");
     *
     * @public
     * @version 1.0
     **/
    Color = wd.Class({
        /**
         * Returns the `type` of `webDoodling.Color`, always returns`Color`.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        type: wd.type("Color"),
        /**
         * Gets or sets the `r` component of the `webDoodling.Color`.
         *
         * @field  {number} r
         * @default 0
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        r: wd.attribute(0),

        /**
         * Gets or sets the `g` component of the `webDoodling.Color`.
         *
         * @field  {number} g
         * @default 0
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        g: wd.attribute(0),

        /**
         * Gets or sets the `b` component of the `webDoodling.Color`.
         *
         * @field  {number} b
         * @default 0
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        b: wd.attribute(0),

        /**
         * Gets or sets the `a` component of the `webDoodling.Color`.
         *
         * @field  {number} a
         * @default 1
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        a: wd.attribute(1),

        /**
         * Initializes the new instance of `webDoodling.Color` object.
         *
         * @constructor init(r, g, b, a)
         * @param {string} r Initializes the `red` value.
         * @param {string} g Initializes the `green` value.
         * @param {string} b Initializes the `blue` value.
         * @param {string} a Initializes the `alpha` value.
         * @param {string} CSS based color value which can be in the form of
         * name, hex, rgb(0,0,0) or rgba(0,0,0,0). It does not currently handles
         * hsl, hsv color string.
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        init: function init (r, g, b, a) {
            if (arguments.length === 0) {
                r = g = b = 0;
                a = 1;
            }

            if (arguments.length === 1 && wd.is.number(r) === false) {
                var c = _colorParse(arguments[0], true);
                this.r = c.r;
                this.g = c.g;
                this.b = c.b;
                this.a = c.a;
            }
            else {
                this.r = _normalize(r, 0, 255, 0);
                this.g = _normalize(g, 0, 255, 0);
                this.b = _normalize(b, 0, 255, 0);
                this.a = _normalize(a, 0, 1, 1);
            }
        },

        /**
         * // TODO: Add description
         * @function darker(level)
         * @param {} level
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/

        darker: function darker (level) {
            var hsl = _toHSL(this.r, this.g, this.b);

            if (level === undefined) {
                level = 5;
            }
            hsl.l = Math.min(Math.max(hsl.l - level, 0), 100);
            var rgb = _fromHSL(hsl.h, hsl.s, hsl.l);
            this.r = Math.round(rgb.r);
            this.g = Math.round(rgb.g);
            this.b = Math.round(rgb.b);
        },

        /**
         * // TODO: Add description
         * @function lighter(level)
         * @param {} level
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        lighter: function lighter (level) {
            var hsl = _toHSL(this.r, this.g, this.b);

            if (level === undefined) {
                level = 5;
            }
            hsl.l = Math.min(Math.max(hsl.l + level, 0), 100);
            var rgb = _fromHSL(hsl.h, hsl.s, hsl.l);
            this.r = Math.round(rgb.r);
            this.g = Math.round(rgb.g);
            this.b = Math.round(rgb.b);
        },

        /**
         * // TODO: Add description
         * @function duller(level)
         * @param {} level
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        duller: function duller (level) {
            var hsl = _toHSL(this.r, this.g, this.b);

            if (level === undefined) {
                level = 5;
            }
            hsl.s = Math.min(Math.max(hsl.s - level, 0), 100);
            var rgb = _fromHSL(hsl.h, hsl.s, hsl.l);
            this.r = Math.round(rgb.r);
            this.g = Math.round(rgb.g);
            this.b = Math.round(rgb.b);
        },

        /**
         * // TODO: Add description
         * @function brighter(level)
         * @param {} level
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        brighter: function brighter (level) {
            var hsl = _toHSL(this.r, this.g, this.b);

            if (level === undefined) {
                level = 5;
            }
            hsl.s = Math.min(Math.max(hsl.s + level, 0), 100);
            var rgb = _fromHSL(hsl.h, hsl.s, hsl.l);
            this.r = Math.round(rgb.r);
            this.g = Math.round(rgb.g);
            this.b = Math.round(rgb.b);
        },

        /**
         * Returns an english name for the current color if available.
         *
         * @function toName()
         * @returns {string} If the color name is available it returns the name otherwise returns `null`.
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        toName: function toName () {
            var hex = this.toHex();
            return _hexToName[hex] || null;
        },

        /**
         * Returns the hex representation of the `webDoodling.Color`.
         *
         * @function toHex()
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        toHex: function toHex () {
            var r = _toHex(this.r);
            var g = _toHex(this.g);
            var b = _toHex(this.b);
            return "#" + r + g + b;
        },

        /**
         * Returns the HSL representation of the `webDoodling.Color`.
         *
         * @function toHSL()
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        toHSL: function toHSL() {
            var hsl = _toHSL(this.r, this.g, this.b);
            return "hsl("+ Math.round(hsl.h) + "," + hsl.s.toFixed(1) + "%," + hsl.l.toFixed(1) + "%" + ")";
        },

        /**
         * Returns the HSLA representation of the `webDoodling.Color`.
         *
         * @function toHSLA()
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        toHSLA: function toHSLA () {
            var hsl = _toHSL(this.r, this.g, this.b);
            return "hsla("+ Math.round(hsl.h) + "," + hsl.s.toFixed(1) + "%," + hsl.l.toFixed(1) + "%," + this.a +")";
        },

        /**
         * Return the rgba representation of the `webDoodling.Color`.
         *
         * @function toRGBA()
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        toRGBA: function toRGBA () {
            return "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")";
        },

        /**
         * Return the rgb representation component of the `webDoodling.Color`.
         *
         * @function toRGB()
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        toRGB: function toRGB () {
            return "rgb(" + [this.r, this.g, this.b].join(",") + ")";
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Color].
         *
         * @memberOf webDoodling.Color
         * @public
         * @version 1.0
         **/
        toString: function toString () {
            return "[object webDoodling.Color]";
        }

    });
    // parse CSS color String.
    function _colorParse(colorStr) {
        var colorBits = null, rgb;
        //rgba(155, 155, 155, 0.5)
        if (colorStr.substring(0, 4) === "rgba") {
            colorBits = _parser.rgba.parse(colorStr);
        }
        //rgb(255, 255, 255)
        else if (colorStr.substring(0, 3) === "rgb") {
            colorBits = _parser.rgb.parse(colorStr);
        }
        //hsla(190, 30%, 94%, 1)
        else if (colorStr.substring(0, 4) === "hsla") {
            colorBits = _parser.hsla.parse(colorStr);
            rgb = _fromHSL(colorBits[0], colorBits[1], colorBits[2], colorBits[3]);
            return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
        }
        //hsl(190, 30%, 94%)
        else if (colorStr.substring(0, 3) === "hsl") {
            colorBits = _parser.hsl.parse(colorStr);
            rgb = _fromHSL(colorBits[0], colorBits[1], colorBits[2]);
            return new Color(Math.round(rgb.r), Math.round(rgb.g), Math.round(rgb.b));
        }
        else {
            //color starting with # like #ff0000, #fff
            if (colorStr[0] === "#") {
                //#ff0000, #ffffff, #00ff00
                if (colorStr.length === 7) {
                    if (colorStr in _hexToColor) {
                        return _hexToColor[colorStr];
                    }
                    colorBits = _parser.hex7.parse(colorStr);
                }
                //#eef, #fff, #123
                if (colorStr.length === 4) {
                    colorBits = _parser.hex4.parse(colorStr);
                }
            }
            else if (colorStr in _nameToColor) {
                return _nameToColor[colorStr];
            }
            else if (colorStr.length === 6) {
                colorBits = _parser.hex6.parse(colorStr);
            }
            else if (colorStr.length === 3) {
                colorBits = _parser.hex3.parse(colorStr);
            }
        }

        if (colorBits === null) {
            throw new wd.Error("wd-invalid-color");
        }

        var r = colorBits[0];
        var g = colorBits[1];
        var b = colorBits[2];
        var a = colorBits[3];
        var c = new Color(r, g, b, a);
        return c;

    }

    /**
     * Returns the color in CSS string hex format.
     *
     * @function hex(r, g, b)
     * @param {number} r
     * @param {number} g
     * @param {number} b
     *
     * @memberOf webDoodling.Color
     * @public
     * @version 1.0
     **/
    Color.hex = function hex(r, g, b) {
        return "#" + _toHex(r) + _toHex(g) + _toHex(b);
    };
        //alert(_nameHexList.length);
    //
    //
    function _normalize(val, min, max, defaultVal) {
        if (isNaN(val)) {
            return defaultVal;
        }
        return Math.max(min, Math.min(max, val));
    }

    function _toHex(val) {
        var v = val.toString(16);
        if (v.length === 1) {
            return "0" + v;
        }
        return v;
    }

    //http://www.rapidtables.com/convert/color/rgb-to-hsl.htm
    // converts rgb to hsl
    function _toHSL(r, g, b) {
        var h = 0,
            s = 0,
            l = 0,
            Cmax = 0,
            Cmin = 0,
            D = 0;
        r /= 255;
        g /= 255;
        b /= 255;
        Cmax = Math.max(r, g, b);
        Cmin = Math.min(r, g, b);
        D = Cmax - Cmin;
        if (Cmax === Cmin) {
            h = s = 0;
        }
        else if (Cmax === r) {
            h = (60 * (((g - b) / D) + ((g < b) ? 6 : 0)));
        }
        else if (Cmax === g) {
            h = (60 * (((b - r) / D) + 2));
        }
        else if (Cmax === b) {
            h = (60 * (((r - g) / D) + 4));
        }
        l = (Cmax + Cmin) / 2;
        if (D === 0) {
            s = 0;
        }
        else if (D !== 0) {
            s = (D / (1 - (Math.abs(2 * l - 1))));
        }
        //h = Math.round(h);
        return {
            h: h,
            s: s * 100,
            l: l * 100
        };
    }

    // converts hsl to rgb
    //http://www.rapidtables.com/convert/color/hsl-to-rgb.htm
    function _fromHSL(h, s, l) {
        var c, x, m, hue,
            r, g, b;

        s /= 100;
        l /= 100;

        c = (1 - Math.abs((2 * l) - 1)) * s;
        x = c * (1 - Math.abs((h / 60) % 2 - 1));
        m = l - (c / 2);
        hue = _hueToRGB(h, c, x);
        r = (hue.redval + m) * 255;
        g = (hue.greenval + m) * 255;
        b = (hue.blueval + m) * 255;
        return {
            r: r,
            g: g,
            b: b
        };
    }

     //converts hue value to rgb
    function _hueToRGB(h, c, x) {
        var redval = 0,
            greenval = 0,
            blueval = 0;
        h = h / 60;
        if (h < 1) {
            redval = c;
            greenval = x;
            blueval = 0;
        }
        else if (h < 2) {
            redval = x;
            greenval = c;
            blueval = 0;
        }
        else if (h < 3) {
            redval = 0;
            greenval = c;
            blueval = x;
        }
        else if (h < 4) {
            redval = 0;
            greenval = x;
            blueval = c;
        }
        else if (h < 5) {
            redval = x;
            greenval = 0;
            blueval = c;
        }
        else {
            redval = c;
            greenval = 0;
            blueval = x;
        }
        return {
            redval: redval,
            greenval: greenval,
            blueval: blueval
        };
    }

    for (var i = 0, len = _nameHexList.length; i < len; i++) {

        var item = _nameHexList[i];
        var name = item[0];
        var hex = item[1];
        var v = _parser.hex7.parse(hex);
        var c = new Color(v[0], v[1], v[2], v[3]);

        //Dictionary building
        _hexToColor[hex] = c;
        _nameToColor[name] = c;
        _hexToName[hex] = name;
        _nameToHex[name] = hex;
    }

    wd.Color = Color;

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The EventManager
(function (wd, undefined) {
    "use strict";

    var emptyFn = function () {},
        is = wd.is, EventManager;

    /**
     * Represents the `weboodling.EventManager` manager class,
     * which is responsible for managing events and user
     * interaction for `webDoodling.Scene`.
     *
     * @class webDoodling.EventManager
     *
     * @public
     * @version 1.0
     * @note This class is meant for internal event handling and should not be directly used
     *
     **/
    EventManager = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.EventManager`, always returns "EventManager".
         *
         * @field {string} type
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @version 1.0
         **/
        type: wd.type("EventManager"),

        /**
         * Gets the `HtmlElement` for which an events need to be handled.
         *
         * @readonly {HtmlElement} htmlElement
         * @default null
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @version 1.0
         **/
        htmlElement: wd.readonly(null),

        /**
         * Gets or sets the callback function on `onPointerOver` event.
         *
         * @event onPointerOver(e)
         * +-----------+--------------------------------------------------+
         * | name      | description                                      |
         * +===========+==================================================+
         * | eventName | The name of the event always `onPointerOver`.  |
         * +-----------+--------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerOver: emptyFn,

        /**
         * Gets or sets the callback function on `onPointerEnter` event.
         *
         * @event onPointerEnter(e)
         * +-----------+--------------------------------------------------+
         * | name      | description                                      |
         * +===========+==================================================+
         * | eventName | The name of the event always `onPointerEnter`.  |
         * +-----------+--------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerEnter: emptyFn,

        /**
         * Gets or sets the callback function on `onPointerMove` event.
         *
         * @event onPointerMove(e)
         * +-----------+------------------------------------------------+
         * | name      | description                                    |
         * +===========+================================================+
         * | eventName | The name of the event always `onPointerMove`.|
         * +-----------+------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerMove: emptyFn,

        /**
         * Gets or sets the callback function on `onPointerDown` event.
         *
         * @event onPointerDown(e)
         * +-----------+------------------------------------------------+
         * | name      | description                                    |
         * +===========+================================================+
         * | eventName | The name of the event always `onPointerDown`.|
         * +-----------+------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerDown: emptyFn,

        /**
         * Gets or sets the callback function on `onPointerUp` event.
         *
         * @event onPointerUp(e)
         * +-----------+------------------------------------------------+
         * | name      | description                                    |
         * +===========+================================================+
         * | eventName | The name of the event always `onPointerUp`.  |
         * +-----------+------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerUp: emptyFn,

        /**
         * Gets or sets the callback function on `onPointerOut` event.
         *
         * @event onPointerOut(e)
         * +-----------+------------------------------------------------+
         * | name      | description                                    |
         * +===========+================================================+
         * | eventName | The name of the event always `onPointerOut`. |
         * +-----------+------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerOut: emptyFn,

        /**
         * Gets or sets the callback function on `onPointerLeave` event.
         *
         * @event onPointerLeave(e)
         * +-----------+--------------------------------------------------+
         * | name      | description                                      |
         * +===========+==================================================+
         * | eventName | The name of the event always `onPointerLeave`.  |
         * +-----------+--------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerLeave: emptyFn,

        /**
         * Gets or sets the callback function on `onPointerCancel` event.
         *
         * @event onPointerCancel(e)
         * +-----------+--------------------------------------------------+
         * | name      | description                                      |
         * +===========+==================================================+
         * | eventName | The name of the event always `onPointerCancel`.|
         * +-----------+--------------------------------------------------+
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @verson 1.0
         **/
        onPointerCancel: emptyFn,

        /**
         * Gets or sets whether an event handling is enabled, `true` if events are enabled else `false`.
         *
         * @field {boolean} enabled
         * @default `false`
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @version 1.0
         **/
        enabled: wd.property({
            value: false,
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled !== value) {
                    this._enabled = value;
                    this._enablePointers(value);
                }
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.EventManager`.
         *
         * @constructor init(htmlElement)
         * @param {HtmlElement} htmlElement The htmlElement for an events to be bound.
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @version 1.0
         **/
        init: function init(htmlElement, handler) {
            this._htmlElement = htmlElement;
            this._handler = handler;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.EventManager].
         *
         * @memberOf webDoodling.EventManager
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.EventManager]";
        },

        /** Private members **/
        _enablePointers: function (value) {
            var element = this._htmlElement,
                enabled = value,
                self = this,
                browser = wd.browser,
                lastAccess = new Date(),
                pointers = {},
                mouseMaps;

            mouseMaps = {
                mouseover: this.onPointerOver,
                mouseenter: this.onPointerEnter,
                mousemove: this.onPointerMove,
                mousedown: this.onPointerDown,
                mouseup: this.onPointerUp,
                mouseleave: this.onPointerLeave,
                mouseout: this.onPointerOut
            };

            /**
             * Throttle event to check whether there is sufficient time gap between events.
             **/
            function _isReady() {
                var curTime = new Date(),
                    diff = curTime - lastAccess;
                if (diff > 16) {
                    lastAccess = curTime;
                    return true;
                }
                return false;
            }

            function _getPointer(identifier) {
                var pointer = pointers[identifier];
                if (pointer) {
                    return pointer;
                }
                pointer = {
                    object: null,
                    capturedObject: null
                };
                pointers[identifier] = pointer;
                return pointer;
            }

            function _handleMouse (event) {
                var e = event || window.event,
                    pointer = _getPointer(0),
                    //pos = pointer.pos,
                    callback,
                    args;

                switch (event.type) {
                case "mousemove":
                    if (_isReady() === false) {
                        return;
                    }
                    break;
                case "mousedown":
                    //browser.on(document, "mouseup", self._handleMouse);
                    pointer.down = true;
                    pointer.capturedObject = pointer.object;
                    break;
                case "mouseup":
                    //browser.off(document, "mouseup", self._handleMouse);
                    pointer.down = false;
                    break;

                }

                callback = mouseMaps[event.type];

                if (callback !== undefined) {
                    args = new wd.PointerEventArgs(element, e, e, 0, "mouse", true, e.cancelable, e.bubbles);
                    callback.call(self._handler, args, pointer);
                }
            }

            this._handleMouse = this._handleMouse || _handleMouse;

            function _handleTouch(e) {
                var touches = e.changedTouches,
                    i, touch, args, pointer, callback,
                    index, isPrimary,
                    deletePrimaryPointer = false,
                    iLen = touches.length,
                    cancelable = true,
                    bubbles = true;

                for (i = 0; i < iLen; i++) {

                    touch = touches[i];
                    pointer = _getPointer(touch.identifier);
                    pointer.down = true;

                    switch (event.type) {
                    case "touchmove":
                        if (_isReady() === false) {
                            return;
                        }
                        pointer.down = true;
                        pointer.capturedObject = pointer.object;
                        callback = self.onPointerMove;
                        break;
                    case "touchstart":
                        callback = self.onPointerDown;
                        if (self.touches === undefined) {
                            self.touches = [];
                        }
                        self.touches.push(touch.identifier);
                        break;
                    case "touchend":
                        pointer.down = false;
                        delete pointer[0];
                        deletePrimaryPointer = true;
                        callback = self.onPointerUp;
                        break;
                    case "touchcancel":
                        callback = self.onPointerCancel;
                        deletePrimaryPointer = true;
                        cancelable = false;
                        break;
                    }

                    if (callback !== undefined && self.touches) {
                        // Prevent default so that mouse emulation handling does not occur.
                        e.preventDefault();

                        isPrimary = self.touches.length > 0 && touch.identifier === self.touches[0];
                        args = new wd.PointerEventArgs(element, e, touch, touch.identifier, "touch", isPrimary, cancelable, bubbles);
                        callback.call(self._handler, args, pointer);

                        // Delete primary pointer after touchend and touchcancel.
                        if (deletePrimaryPointer) {
                            index = self.touches.indexOf(touch.identifier);
                            if (index != -1) {
                                self.touches.splice(index, 1);
                            }
                        }
                    }
                }
            }
            this._handleTouch = this._handleTouch || _handleTouch;

            function _handlePointer(e) {
                var pointer, callback, args;
                pointer = _getPointer(e.pointerId);

                //pointer.down = true;
                switch (e.type) {
                case "pointermove":
                case "MSPointerMove":
                    if (_isReady() === false) {
                        return;
                    }
                    pointer.down = true;
                    //pointer.capturedObject = pointer.object;
                    callback = self.onPointerMove;
                    break;
                case "pointerover":
                case "MSPointerOver":
                    callback = self.onPointerOver;
                    break;
                case "pointerenter":
                case "MSPointerHover":
                    callback = self.onPointerEnter;
                    break;
                case "pointerdown":
                case "MSPointerDown":
                    pointer.down = true;
                    pointer.capturedObject = pointer.object;
                    callback = self.onPointerDown;
                    break;
                case "pointerup":
                case "MSPointerUp":
                    pointer.down = false;
                    // No need to delete pointer on mouseup as mouse is
                    // always an active pointer.
                    if (pointer.type !== "mouse") {
                        delete pointer[0];
                    }
                    callback = self.onPointerUp;
                    break;
                case "pointerleave":
                case "MSPointerCancel":
                    callback = self.onPointerLeave;
                    break;
                case "pointerout":
                case "MSPointerOut":
                    callback = self.onPointerOut;
                    break;
                }

                args = new wd.PointerEventArgs(element, e, e, e.pointerId, e.pointerType, e.isPrimary, e.cancelable, e.bubbles);

                //console.log("Pointers");
                if (callback !== undefined) {
                    callback.call(self._handler, args, pointer);
                }
            }

            this._handlePointer = this._handlePointer || _handlePointer;

            /***** PointerEvents *****/


            if (enabled === true) {

                //Attach event handlers
                if (navigator.pointerEnabled === undefined) {

                    if (is.touch) {
                        browser.on(element, "touchstart", this._handleTouch);
                        browser.on(document, "touchmove", this._handleTouch);
                        browser.on(document, "touchend", this._handleTouch);
                        browser.on(document, "touchcancel", this._handleTouch);
                    }

                    //Mouse events
                    browser.on(element, "mouseover", this._handleMouse);
                    browser.on(element, "mouseenter", this._handleMouse);
                    browser.on(document, "mousemove", this._handleMouse);
                    browser.on(element, "mousedown", this._handleMouse);
                    browser.on(document, "mouseup", this._handleMouse);
                    browser.on(element, "mouseleave", this._handleMouse);
                    browser.on(element, "mouseout", this._handleMouse);
                }
                else {

                    if (navigator.msPointerEnabled) {
                        browser.on(element, "MSPointerDown", this._handlePointer);
                        browser.on(document, "MSPointerMove", this._handlePointer);
                        browser.on(document, "MSPointerUp", this._handlePointer);
                        browser.on(element, "MSPointerOver", this._handlePointer);
                        browser.on(element, "MSPointerOut", this._handlePointer);
                        browser.on(element, "MSPointerHover", this._handlePointer);
                        browser.on(document, "MSPointerCancel", this._handlePointer);
                    }
                    else {
                        browser.on(element, "pointerover", this._handlePointer);
                        browser.on(element, "pointerenter", this._handlePointer);
                        browser.on(document, "pointermove", this._handlePointer);
                        browser.on(element, "pointerdown", this._handlePointer);
                        browser.on(document, "pointerup", this._handlePointer);
                        browser.on(element, "pointerleave", this._handlePointer);
                        browser.on(element, "pointerout", this._handlePointer);
                        browser.on(document, "pointercancel", this._handlePointer);
                    }
                }
            }
            else if (enabled === false) {
               //Detach event handlers
                if (window.navigator.PointerEnabled) {
                    if (window.navigator.msPointerEnabled) {
                        browser.off(element, "MSPointerDown", this._handlePointer);
                        browser.off(document, "MSPointerMove", this._handlePointer);
                        browser.off(document, "MSPointerUp", this._handlePointer);
                        browser.off(element, "MSPointerOver", this._handlePointer);
                        browser.off(element, "MSPointerOut", this._handlePointer);
                        browser.off(element, "MSPointerHover", this._handlePointer);
                        browser.off(document, "MSPointerCancel", this._handlePointer);
                    }
                    else {
                        browser.off(element, "pointerover", this._handlePointer);
                        browser.off(element, "pointerenter", this._handlePointer);
                        browser.off(document, "pointermove", this._handlePointer);
                        browser.off(element, "pointerdown", this._handlePointer);
                        browser.off(document, "pointerup", this._handlePointer);
                        browser.off(element, "pointerleave", this._handlePointer);
                        browser.off(element, "pointerout", this._handlePointer);
                        browser.off(document, "pointercancel", this._handlePointer);
                    }
                }
                else {
                    // Touch events
                    if (is.touch) {
                        browser.off(element, "touchstart", this._handleTouch);
                        browser.off(document, "touchmove", this._handleTouch);
                        browser.off(document, "touchend", this._handleTouch);
                        browser.off(document, "touchcancel", this._handleTouch);
                    }
                    //Mouse events
                    browser.off(element, "mouseover", this._handleMouse);
                    browser.off(element, "mouseenter", this._handleMouse);
                    browser.off(document, "mousemove", this._handleMouse);
                    browser.off(element, "mousedown", this._handleMouse);
                    browser.off(document, "mouseup", this._handleMouse);
                    browser.off(element, "mouseleave", this._handleMouse);
                    browser.off(element, "mouseout", this._handleMouse);
                }
            }
        }
    });


    wd.EventManager = EventManager;

})(window.webDoodling);

// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd, undefined) {
    "use strict";

    var EventArgs;

    /**
     * Represents the base class that represent event object in `webDoodling` framework.
     *
     * @example
     * var tapEventArgs  = new wd.EventArgs('tap');
     * this.trigger("tap", tapEventArgs);
     *
     * @memberOf webDoodling.EventArgs
     * @public
     * @version 1.0
     **/
    EventArgs = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.EventArgs`, always returns 'EventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.EventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("EventArgs"),

        /**
         * Returns the triggered event name for the current event object.
         *
         * @field {string} eventName
         * @default event
         *
         * @memberOf webDoodling.EventArgs
         * @public
         * @version 1.0
        **/
        eventName: wd.attribute("Event"),

        /**
         * Initializes the new instance of `webDoodling.EventArgs`.
         *
         * @constructor init(eventName);
         * @param {string} eventName The name of the event.
         *
         * @memberOf webDoodling.EventArgs
         * @public
         * @version 1.0
         **/
        init: function init(eventName) {
            if (eventName !== undefined) {
                this.eventName = eventName;
            }
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.EventArgs].
         *
         * @memberOf webDoodling.EventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.EventArgs]";
        }
    });

    wd.EventArgs = EventArgs;


})(window.webDoodling);

// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd, undefined) {
    "use strict";

    var PointerEventArgs;

    /**
     * Represents the pointer event attributes and other pointerevent functions
     *
     * @example
     * var pointerEvent  = new wd.PointerEventArgs(x, y, mouseEvent, touchEvent, pointerId, cancelable, pointerType);
     *
     * @memberOf webDoodling.PointerEventArgs
     * @public
     * @version 1.0
     **/
    PointerEventArgs = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.PointerEventArgs`, always returns 'PointerEventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("PointerEventArgs"),

        /**
         * A unique identifier for the pointer causing the event.This identifier must be unique from all other active pointers at the time.                * A user agent may recycle previously retired values for pointerId from previous active pointers, if necessary.
         *
         * @field {number} pointerId
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        pointerId: wd.readonly(0),

        /**
         * The x position of pointer within scene.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        x: wd.readonly({
            get: function () {
                if (this._x === undefined) {
                    this._setMousePosition();
                }
                return this._x;
            }
        }),

        /**
         * The y position of pointer within scene.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        y: wd.readonly({
            get: function () {
                if (this._y === undefined) {
                    this._setMousePosition();
                }
                return this._y;
            }
        }),

        /**
         * The screenX position of screen.
         *
         * @field {number} screenX
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        screenX: wd.readonly(0),

        /**
         * The screenY position of screen.
         *
         * @field {number} screenY
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        screenY: wd.readonly(0),

        /**
         * The clientX position of the scene canvas.
         *
         * @field {number} clientX
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        clientX: wd.readonly(0),

        /**
         * The clientY position of the scene canvas.
         *
         * @field {number} clientY
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        clientY: wd.readonly(0),

        /**
         * The pageX position of the document.
         *
         * @field {number} pageX
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        pageX: wd.readonly(0),

        /**
         * The pageY position of the document.
         *
         * @field {number} pageY
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        pageY: wd.readonly(0),

        /**
         * Indicates the device type that caused the event. Based of the device
         * which is being used as pointer, the value of pointerType
         * is one of the following.
         *
         * - mouse
         * - touch
         * - pointer
         *
         * @field {string} pointerType
         * @default mouse
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        pointerType: wd.readonly("unknown"),

        /**
         * The ctrlKey of keyboard
         *
         * @field {boolean} ctrlKey
         * @default false
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        ctrlKey: wd.readonly(false),

        /**
         * The shiftKey of keyboard
         *
         * @field {boolean} shiftKey
         * @default false
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        shiftKey: wd.readonly(false),

        /**
         * The altKey of keyboard
         *
         * @field {boolean} altKey
         * @default false
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        altKey: wd.readonly(false),

        /**
         * The metaKey of keyboard
         *
         * @field {boolean} metaKey
         * @default false
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        metaKey: wd.readonly(false),

        /**
         * Gets the cancelable attribute of event. The browser's default action can be stopped using
         * `EventArgs.preventDefault` function if this attribute is set to `true`;
         *
         * @field {boolean} cancelable
         * @default false
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        cancelable: wd.readonly(false),

        /**
         * Gets the bubbles attribute of event. Event can be stopped for propagation using
         * `EventArgs.stopPropagation` function if this attribute is set to `true`;
         *
         * @field {boolean} bubbles
         * @default false
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        bubbles: wd.readonly(false),

        /**
         * The buttons attribute of mouse event
         *
         * @field {boolean} buttons
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        buttons: wd.readonly(0),

        /**
         * The width of the contact geometry of the pointer.
         * This value may be updated on each event for a given pointer.
         * The value must be 0.
         *
         * @field {number} width
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        width: wd.readonly(0),

        /**
         * The height of the contact geometry of the pointer.
         * This value may be updated on each event for a given pointer.
         * The value must be 0.
         *
         * @field {number} height
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        height: wd.readonly(0),

        /**
         * The normalized pressure of the pointer input in the range of [0,1].
         * Where 0 and 1 represent the minimum and maximum pressure.
         * The hardware is capable of detecting, respectively.
         *
         * @field {number} pressure
         * @default 0.5
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        pressure: wd.readonly(0.5),

        /**
         * The plane angle (in degrees, in the range of [-90,90])
         * between the Y-Z plane and the plane containing both
         * the transducer (e.g. pen stylus) axis and the Y axis.
         * A positive tiltX is to the right.
         * tiltX can be used along with tiltY to represent the tilt
         * away from the normal of a transducer with the digitizer.
         * For devices that do not report tilt.
         * the value must be 0.
         *
         * @field {number} tiltX
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        tiltX: wd.readonly(0),

        /**
         * The plane angle (in degrees, in the range of [-90,90])
         * between the X-Z plane and the plane containing both
         * the transducer (e.g. pen stylus) axis and the X axis.
         * A positive tiltY is towards the user.
         * tiltY can be used along with tiltX to represent the tilt
         * away from the normal of a transducer with the digitizer.
         * For devices that do not report tilt.
         * the value must be 0.
         *
         * @field {number} tiltX
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        tiltY: wd.readonly(0),

        /**
         * Indicates if the pointer represents the primary pointer of this pointer type.
         *
         * @field {boolean} isPrimary
         * @default 0
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        isPrimary: wd.readonly(false),

        /**
         * The orignal event arguments.
         *
         * @field {event} sourceEvent
         * @default null
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        sourceEvent: wd.readonly(null),

        /**
         * The orignal touch event.
         *
         * @field {touch} sourceTouch
         * @default null
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
        **/
        sourceTouch: wd.readonly(null),

        /**
         * Initializes the new instance of `webDoodling.PointerEventArgs`.
         *
         * @constructor init(x, y, event, touce, pointerId, cancelable, pointerType);
         * @param {number} x The x position of pointer.
         * @param {number} y The y position of pointer.
         * @param {event} event The event.
         * @param {event} touch The touch event.
         * @param {number} pointerId The unique identifier of pointer.
         * @param {boolean} cancelable The cancelable attribute of event.
         * @param {string} pointerType The type of the pointer.
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
         **/
        init: function init(element, event, touch,  pointerId, pointerType, isPrimary, cancelable, bubbles) {
            var buttonMap = {"-1": 0, 0: 1, 1: 4, 2: 2, 3: 8, 4: 16, 5: 32};

            this._element = element;
            this._stopPropagation = false;

            if (event !== undefined) {

                this._sourceEvent   = event;

                // MouseEvent members
                this._screenX       = touch.screenX;
                this._screenY       = touch.screenY;

                this._clientX       = touch.clientX;
                this._clientY       = touch.clientY;

                this._ctrlKey       = event.ctrlKey || false;
                this._shiftKey      = event.shiftKey || false;
                this._altKey        = event.altKey || false;
                this._metaKey       = event.metaKey || false;

                //touch members
                this._sourceTouch   = (event === touch) ? null  : touch;
                this._pageX         = touch.pageX;
                this._pageY         = touch.pageY;

                // PointerEventArgss members
                this._pointerId     = pointerId;
                this._pointerType   = pointerType;

                this._tiltX         = touch.tiltX || 0;
                this._tiltY         = touch.tiltY || 0;

                this._width         = ((event === touch) ? event.width : touch.radiusX) || 0;
                this._height        = ((event === touch) ? event.height : touch.radiusY) || 0;

                this._pressure      = ((event === touch) ? event.pressure : touch.force) || 0;

                this._isPrimary     = isPrimary;

                this._cancelable    = cancelable || false;
                this._bubbles       = bubbles || false;

                //TODO = Add buttons
                if (event.buttons !== undefined) {
                    this._buttons = event.buttons;
                }
                else {
                    this._buttons = buttonMap[event.button];
                }
            }
        },

        /**
         * Returns the `true` or `false` if event is set to default.
         *
         * The preventDefault() method cancels the event if it is cancelable.
         * meaning that the default action that belongs to the event will not occur.
         *
         * @function preventDefault()
         * @returns false
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
         **/
        preventDefault: function () {
            if (this.cancelable && this._sourceEvent.preventDefault) {
                this._sourceEvent.preventDefault();
            }
            return false;
        },

        /**
         * sets stopPropagation to true.
         *
         * @function stopPropagation()
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
         **/
        stopPropagation: function () {
            this._sourceEvent.stopPropagation();
            this._stopPropagation = true;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.PointerEventArgs].
         *
         * @memberOf webDoodling.PointerEventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.PointerEventArgs]";
        },

        // Private Zone

        _getNumStyle: function _getNumStyle(style, key) {
            return parseInt(style.getPropertyValue(key), 10);
        },

        _setMousePosition: function _setMousePosition() {
            var x = 0, y = 0,
                elm = this._element,
                inner = true,
                style,
                borderTop, borderLeft,
                paddingTop, paddingLeft,
                e = this._sourceTouch || this._sourceEvent;

            // If event is not set, just return.
            if (!e) return;

            do {
                x += elm.offsetLeft;
                y += elm.offsetTop;

                style = getComputedStyle(elm, null);

                borderTop = this._getNumStyle(style, "border-top-width");
                borderTop = isNaN(borderTop) ? 0 : borderTop;

                borderLeft = this._getNumStyle(style, "border-left-width");
                borderLeft = isNaN(borderLeft) ? 0 : borderLeft;

                y += borderTop;
                x += borderLeft;

                if (inner) {
                    paddingTop = this._getNumStyle(style, "padding-top");
                    paddingTop = isNaN(paddingTop) ? 0 : paddingTop;

                    paddingLeft = this._getNumStyle(style, "padding-left");
                    paddingLeft = isNaN(paddingLeft) ? 0 : paddingLeft;

                    y += paddingTop;
                    x += paddingLeft;
                }
                inner = false;
                elm = elm.offsetParent;

            } while (elm);

            this._x = e.pageX - x;
            this._y = e.pageY - y;
        }

    }, wd.EventArgs);


    PointerEventArgs.clone = function (pointerEvent, cancelable, bubbles) {
        var cloned = new wd.PointerEventArgs();

        cloned._element      = pointerEvent._element;
        cloned._pointerId    = pointerEvent._pointerId;
        cloned._pointerType  = pointerEvent._pointerType;
        cloned._x            = pointerEvent._x;
        cloned._y            = pointerEvent._y;
        cloned._screenX      = pointerEvent._screenX;
        cloned._screenY      = pointerEvent._screenY;
        cloned._clientX      = pointerEvent._clientX;
        cloned._clientY      = pointerEvent._clientY;
        cloned._pageX        = pointerEvent._pageX;
        cloned._pageY        = pointerEvent._pageY;
        cloned._type         = pointerEvent._type;
        cloned._ctrlKey      = pointerEvent._ctrlKey;
        cloned._shiftKey     = pointerEvent._shiftKey;
        cloned._altKey       = pointerEvent._altKey;
        cloned._metaKey      = pointerEvent._metaKey;
        cloned._buttons      = pointerEvent._buttons;
        cloned._width        = pointerEvent._width;
        cloned._height       = pointerEvent._height;
        cloned._pressure     = pointerEvent._pressure;
        cloned._tiltX        = pointerEvent._tiltX;
        cloned._tiltY        = pointerEvent._tiltY;
        cloned._isPrimary    = pointerEvent._isPrimary;
        cloned._sourceEvent  = pointerEvent._sourceEvent;
        cloned._sourceTouch  = pointerEvent._sourceTouch;

        cloned._cancelable    = (cancelable !== undefined) ? cancelable : pointerEvent._cancelable;
        cloned._bubbles       = (bubbles !== undefined) ? bubbles : pointerEvent._bubbles;

        return cloned;

    };

    wd.PointerEventArgs = PointerEventArgs;

})(window.webDoodling);

// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd) {
    "use strict";

    var AudioErrorEventArgs;

    /**
     * Represents the base class that represent event object in `webDoodling` framework.
     *
     * @example
     * var errorEvent  = new wd.AudioErrorEventArgs('tap');
     *
     * @memberOf webDoodling.AudioErrorEventArgs
     * @public
     * @version 1.0
     **/
    AudioErrorEventArgs = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.AudioErrorEventArgs`, always returns 'AudioErrorEventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AudioErrorEventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("AudioErrorEventArgs"),

        /**
         * The error msg which is show when audio loading has some error.
         *
         * @field {number} errorMsg
         * @default ""
         *
         * @memberOf webDoodling.AudioErrorEventArgs
         * @public
         * @version 1.0
        **/
        error: wd.attribute(""),

        /**
         * Initializes the new instance of `webDoodling.Event`.
         *
         * @constructor init(eventName);
         * @param {string} eventName The name of the event.
         *
         * @memberOf webDoodling.AudioErrorEventArgs
         * @public
         * @version 1.0
         **/
        init: function init(error) {
            this.error = error;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AudioErrorEventArgs].
         *
         * @memberOf webDoodling.AudioErrorEventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AudioErrorEventArgs]";
        }
    }, wd.EventArgs);

    wd.AudioErrorEventArgs = AudioErrorEventArgs;


})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd) {
    "use strict";

    var TimeUpdateEventArgs;

    /**
     * Represents the base class that represent event object in `webDoodling` framework.
     *
     * @example
     * var timeupdateEvent  = new wd.TimeUpdateEventArgs('tap');
     *
     * @memberOf webDoodling.TimeUpdateEventArgs
     * @public
     * @version 1.0
     **/
    TimeUpdateEventArgs = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.TimeUpdateEventArgs`, always returns 'TimeUpdateEventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.TimeUpdateEventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("TimeUpdateEventArgs"),

        /**
         * The current Position of the audio.
         *
         * @field {number} position
         * @default 0
         *
         * @memberOf webDoodling.TimeUpdateEventArgs
         * @public
         * @version 1.0
        **/
        position: wd.attribute(0),

        /**
         * Initializes the new instance of `webDoodling.Event`.
         *
         * @constructor init(eventName);
         * @param {string} eventName The name of the event.
         *
         * @memberOf webDoodling.TimeUpdateEventArgs
         * @public
         * @version 1.0
         **/
        init: function init(position) {
            this.position = position;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.TimeUpdateEventArgs].
         *
         * @memberOf webDoodling.TimeUpdateEventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.TimeUpdateEventArgs]";
        }
    }, wd.EventArgs);

    wd.TimeUpdateEventArgs = TimeUpdateEventArgs;


})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd) {
    "use strict";

    var CollectionEventArgs;

    /**
     * Represents the base class that represent event object in `webDoodling` framework.
     *
     * @example
     * var itemBeforeAddEvent = new wd.CollectionEventArgs(item, process);
     *
     * @memberOf webDoodling.CollectionEventArgs
     * @public
     * @version 1.0
     **/
    CollectionEventArgs= wd.Class({

        /**
         * Returns the `type` of the `webDoodling.CollectionEventArgs`, always returns 'CollectionEventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.CollectionEventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("CollectionEventArgs"),

        /**
         * The item which u want to add in collection.
         *
         * @field {object} item
         *
         * @memberOf webDoodling.CollectionEventArgs
         * @public
         * @version 1.0
        **/
        item: wd.attribute(),

        /**
         * The item which u want to add in collection.
         *
         * @field {object} process
         *
         * @memberOf webDoodling.CollectionEventArgs
         * @public
         * @version 1.0
        **/
        process: wd.attribute(),

        /**
         * Initializes the new instance of `webDoodling.CollectionEventArgs`.
         *
         * @constructor init(args);
         * @param {object} args The arguments.
         *
         * @memberOf webDoodling.CollectionEventArgs
         * @public
         * @version 1.0
         **/
        init: function init(item, process) {
            this.item = item;
            this.process = process;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.CollectionEventArgs].
         *
         * @memberOf webDoodling.CollectionEventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.CollectionEventArgs]";
        }
    }, wd.EventArgs);

    wd.CollectionEventArgs = CollectionEventArgs;


})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd) {
    "use strict";

    var AssetSuccessEventArgs;

    /**
     * Represents the base class that represent event object in `webDoodling` framework.
     *
     * @example
     * var tapEvent  = new wd.AssetSuccessEventArgs(media);
     *
     * @memberOf webDoodling.AssetSuccessEventArgs
     * @public
     * @version 1.0
     **/
    AssetSuccessEventArgs= wd.Class({

        /**
         * Returns the `type` of the `webDoodling.AssetSuccessEventArgs`, always returns 'AssetSuccessEventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AssetSuccessEventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("AssetSuccessEventArgs"),

        /**
         * The media of the asset.
         *
         * @field {object} media
         *
         * @memberOf webDoodling.AssetSuccessEventArgs
         * @public
         * @version 1.0
        **/
        media: wd.attribute(),

        /**
         * Initializes the new instance of `webDoodling.AssetSuccessEventArgs`.
         *
         * @constructor init(media);
         * @param {object} media The media of the asset.
         *
         * @memberOf webDoodling.AssetSuccessEventArgs
         * @public
         * @version 1.0
         **/
        init: function init(media) {
            this.media = media;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AssetSuccessEventArgs].
         *
         * @memberOf webDoodling.AssetSuccessEventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AssetSuccessEventArgs]";
        }
    }, wd.EventArgs);

    wd.AssetSuccessEventArgs = AssetSuccessEventArgs;


})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd) {
    "use strict";

    var AssetErrorEventArgs;

    /**
     * Represents the base class that represent event object in `webDoodling` framework.
     *
     * @example
     * var errorEvent  = new wd.AssetErrorEventArgs(error);
     *
     * @memberOf webDoodling.AssetErrorEventArgs
     * @public
     * @version 1.0
     **/
    AssetErrorEventArgs= wd.Class({

        /**
         * Returns the `type` of the `webDoodling.AssetErrorEventArgs`, always returns 'AssetErrorEventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AssetErrorEventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("AssetErrorEventArgs"),

        /**
         * the error when asset is not loaded
         *
         * @field {string} error
         * @default ""
         *
         * @memberOf webDoodling.AssetErrorEventArgs
         * @public
         * @version 1.0
        **/
        error: wd.attribute(""),

        /**
         * Initializes the new instance of `webDoodling.AssetErrorEventArgs`.
         *
         * @constructor init(error);
         * @param {string} error The detail of the error.
         *
         * @memberOf webDoodling.AssetErrorEventArgs
         * @public
         * @version 1.0
         **/
        init: function init(error) {
            this.error = error;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AssetErrorEventArgs].
         *
         * @memberOf webDoodling.AssetErrorEventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AssetErrorEventArgs]";
        }
    }, wd.EventArgs);

    wd.AssetErrorEventArgs = AssetErrorEventArgs;


})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The browser object
(function (wd, undefined) {
    "use strict";

    var AssetProgressEventArgs;

    /**
     * Represents the base class that represent event object in `webDoodling` framework.
     *
     * @example
     * var progressEvent  = new wd.AssetProgressEventArgs();
     *
     * @memberOf webDoodling.AssetProgressEventArgs
     * @public
     * @version 1.0
     **/
    AssetProgressEventArgs = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.AssetProgressEventArgs`, always returns 'AssetProgressEventArgs'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
         **/
        type: wd.type("AssetProgressEventArgs"),

        /**
         * Represents the total number of asset which are processed.
         *
         * @field {number} processed
         * @default 0
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
        **/
        processed: wd.attribute(0),

        /**
         * Represents the percentage.
         *
         * @field {number} processedPercentage
         * @default 0
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
        **/
        processedPercentage: wd.attribute(0),

        /**
         * The asset of the asset manager.
         *
         * @field {object} asset
         * @default null
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
        **/
        asset: wd.attribute(null),

        /**
         * Its return true if asset successfully loaded.
         *
         * @field {boolean} success
         * @default false
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
        **/
        success: wd.attribute(false),

        /**
         * This error will show when asset not loaded
         *
         * @field {string} error
         * @default ""
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
        **/
        error: wd.attribute(""),

        /**
         * Initializes the new instance of `webDoodling.AssetProgressEventArgs`.
         *
         * @constructor init();
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                arg4 = arguments[3],
                arg5 = arguments[4];
            if (arg1 !== undefined) this.processed = arg1;
            if (arg2 !== undefined) this.processedPercentage = arg2;
            if (arg3 !== undefined) this.asset = arg3;
            if (arg4 !== undefined) this.success = arg4;
            if (arg5 !== undefined) this.error = arg5;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AssetProgressEventArgs].
         *
         * @memberOf webDoodling.AssetProgressEventArgs
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AssetProgressEventArgs]";
        }
    }, wd.EventArgs);

    wd.AssetProgressEventArgs = AssetProgressEventArgs;


})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Scene
(function (wd, undefined) {
    "use strict";

    var Color = wd.Color,
        Scene;

    /**
     * Represents the `webDoodling.Scene`.
     *
     * @class webDoodling.Scene
     * @example
     *
     * var scene = webDoodling.Scene(canvasElm, {
     *     children: [
     *         new webDoodling.Rectangle({
     *             id:'rectangle'
     *             x: 100,
     *             y: 100,
     *             styles: [
     *                 new webDoodling.Fill('red')
     *             ]
     *         }),
     *         new webDoodling.Polygon({
     *             id:'polygon',
     *             x:200,
     *             y:200,
     *             sides:5,
     *             radius:100,
     *             styles:[
     *                 new webDoodling.Stroke('white', 2),
     *                 new webDoodling.Fill('rgba(0, 0, 255, 0.1)')
     *           ]
     *         }),
     *         new webDoodling.Star({
     *             id:'star',
     *             x:300,
     *             y:300,
     *             sides:5,
     *             radius:100,
     *             scaleX:1.5,
     *             scaleY: 0.7,
     *             styles:[
     *                 new webDoodling.Stroke('white', 2),
     *                 new webDoodling.Fill('rgba(255, 0, 0, 0.9)')
     *             ]
     *         })
     *     ],
     *     timeline:{
     *       repeat: 0,
     *           tweens: [
     *                 new webDoodling.Tween('star', "rotation", 360, 1, 50, 'bounceOut'),
     *                 new webDoodling.Tween('rect2', {
     *                   x:800,
     *                   y: 500,
     *                   options:{
     *                       start:51,
     *                       stop:100,
     *                       easing:"quadIn"
     *                   }
     *               })
     *           ]
     *       },
     *       animationLoop:function () {
     *           var rec = scene.children.get('rectangle');
     *           rec.rotation += 4;
     *
     *           var polygon = scene.children.get('polygon');
     *           polygon.rotation += 5;
     *
     *           var star = scene.children.get('star');
     *           star.rotation -= 2;
     *       }
     *
     * });
     *
     * @memberOf webDoodling.Scene
     * @public
     * @version 1.0
     **/
    Scene = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Scene`, always returns 'Scene'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        type: wd.type("Scene"),


        /**
         * Gets or sets the `backgroundColor` of the `webDoodling.Scene`.
         *
         * @field {string} backgroundColor
         * @default   'transparent'
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        backgroundColor: wd.attribute("transparent"),

        /**
         * Gets the canvas element which is associated with the current
         * instance of `webDoodling.Scene`
         *
         * @readonly {HTMLCanvasElement} canvas
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        canvas: wd.readonly(),

        /**
         * Represents the child `webDoodling.DisplayObject`.
         *
         * @readonly {webDoodling.children} children
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        children: wd.readonly(),

        //Animation

        /**
         * Gets or sets the animation frames per second (FPS) value for the current scene.
         *
         * @field {number} fps
         * @default 40
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        fps: wd.property({
            value: wd.config("defaultFPS"),
            get: function() {
                return this._fps;
            },
            set: function(v) {
                this._fps = v;
                this._mainLoop.fps = v;
            }
        }),

        /**
         * Returns the calculate FPS value for last frame.
         *
         * @readonly {number} lastFPS
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        lastFPS: wd.readonly({
            get: function () {
                return this._mainLoop.lastFPS;
            }
        }),

        /**
         * Returns the calculate FPS value for last frame.
         *
         * @readonly {number} lastFPS
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        isPlaying: wd.readonly({
            get: function () {
                return this._mainLoop.isPlaying;
            }
        }),

        /**
         * Gets the `timeline` associated with the current instance of `webDoodling.Scene`
         *
         * @readonly {webDoodling.timeline} timeline
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        timeline: wd.readonly(),

        /**
         * Activates or deactivates the scene. When it is deactivated interactive
         * events are disabled, main loop and scene updates are stopped.
         *
         * @field {boolean} active
         * @default `true`
         *
         * @example
         * //Deactivates the scene.
         * scene.active = false;
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        active: wd.property({
            value: true,
            get: function () {
                return this._active;
            },
            set: function (val) {
                if (val === true) {
                    wd.Scene.manager.activateScene(this);
                }
                else {
                    this._activate(false);
                }
            }
        }),

        /**
         * Represents an event which keeps on triggering at the rate of current `fps`.
         *
         * @event animationLoop(e)
         * @param {object} e An event argument which is passed to the event handler,
         * has following members.
         * +-----------+------------------------------------------------+
         * | name      | description                                    |
         * +===========+================================================+
         * | eventName | The name of the event always `animationLoop`.  |
         * +-----------+------------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         */
        animationLoop: wd.event(),

        /**
         * Returns the width of the `webDoodling.Scene`.
         *
         * @readonly {number} width
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        width: wd.readonly(0),

        /**
         * Returns the height of the `webDoodling.Scene`.
         *
         * @readonly {number} height
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        height: wd.readonly(0),

        /**
         * Initializes the new instance of `webDoodling.Scene`.
         * @constructor init(canvas, options)
         * @param {Canvas} canvas The canvas element on which scene is supposed to be rendered.
         * @param {[object]} options The canvas initialization options.
         * This is an optional parameter.
         *
         * @example
         * //Draws the scene on canvas element myCanvas.
         * var scene = new webDoodling.Scene(myCanvas, {
         *     backgroundColor: 'black',
         *     children: [
         *         new webDoodling.Rectangle({
         *             x: 100,
         *             y: 100,
         *             styles: [
         *                 new webDoodling.Fill('red')
         *             ]
         *         })
         *     ]
         * });
         *
         * @constructor init(canvas, options)
         * @param {string} canvasId An id canvas element on which scene is supposed
         * to be rendered.
         * @param {[object]} options The canvas initialization options.
         * This is an optional parameter.
         *
         * @example
         * //Draws the scene on canvas having id my-canvas.
         * var scene = new webDoodling.Scene("my-canvas", {
         *     backgroundColor: 'black',
         *     children: [
         *         new webDoodling.Polygon({
         *             x: 100,
         *             y: 100,
         *             sides: 5,
         *             radius: 50,
         *             styles: [
         *                 new webDoodling.Fill('red')
         *             ]
         *         })
         *     ]
         * });
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/

        init: function (canvas, options) {
            var self = this;

            this.base();

            // Initialize support objects
            this._hexMap = {}; // Map color to objects
            this._idMap = {}; // Map id to objects
            this._pointersCount = 0;
            this._updateRequests = 0;

            // Setup services
            this._colorService = new wd.utils.ColorService(); // color service
            this._nameService = new wd.utils.NameService(); // name service
            this._id = (new Date()).getTime().toString();

            // Canvas
            this._setupCanvas(canvas);

            // Children
            this._setupChildren();

            // Main Loop
            this._setupMainLoop();

            // Setup Timeline
            this._setupTimeline();

            // Serializable
            this.serializables("backgroundColor", "children", "fps",
                                  "timeline", "active");

            // Events and HittestCanvas
            this._setupEvents();

            if (options !== undefined) {
                this.deserialize(options);
                if (!this._timeline.autoPlay) {
                    this._timeline.pause();
                }
            }

            if (this._active) {
                this._mainLoop.play();
                this.update();
            }

            // Directly triggering ready does not give access to scene declaration variable.
            // For example...
            // var scene = webDoodling.Scene({
            //      ready: function () {
            //          // Would print 'undefined' if ready is triggered directly
            //          // if not within the timeout.
            //          console.log(scene);
            //      }
            // });
            setTimeout(function () {
                self.trigger("ready", new wd.EventArgs("ready"));
            }, 0);
        },

        //TODO: Test and fix Scene.destroy function.
        /**
         * Destroys the scene. As part of destroying it inactivates the scene,
         * disassociate itself from any events, removes all the children
         * and clears the associated canvas.
         *
         * @function destroy()
         * @returns {webDoodling.Scene} The current instance, useful for chaining.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         */
        destroy: function destroy() {
            var key,
                //map = this._hexMap,
                trackedObjects = [],
                i, iLen;

            //Unsubscribe children events.
            function unsubscribe(obj) {
                if (trackedObjects.indexOf(obj) === -1) {
                    trackedObjects.push(obj);

                    if (obj.unsubscribeAll) {
                        obj.unsubscribeAll();
                    }

                    if (obj instanceof wd.Collection) {
                        obj.each(function(item) {
                            unsubscribe(item);
                        });
                    }
                    else if(obj instanceof Array) {
                        for(i = 0, iLen = obj.length; i < iLen; i += 1) {
                            unsubscribe(obj[i]);
                        }
                    }
                    else if (obj instanceof wd.WebDoodlingObject) {
                        for(key in obj) {
                            if (obj[key] instanceof wd.WebDoodlingObject) {
                                unsubscribe(obj[key]);
                            }
                        }
                    }
                }
            }

            this.active = false;
            unsubscribe(this);
            this.children.clear();
            this.clear();
            return this;
        },

        /**
         * update the scene. As part of updating process it clear the scene and redraws
         * all the display object.
         * @functions updates()
         * @returns {webDoodling.Scene} The current instance, useful for chaining.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        update: function update(force) {
            if (!force) {
                this._updateRequests += 1;
            }
            else {
                this._update();
                this._updateRequests = 0;
            }
        },

        resize: function resize(width, height) {
            var touchCanvas = this._touchCanvas,
                can = this.canvas;

            can.setAttribute("width", width + "px");
            can.setAttribute("height", height + "px");

            touchCanvas.setAttribute("width", width + "px");
            touchCanvas.setAttribute("height", height + "px");
            this._width = width;
            this._height = height;
        },

        /**
         * Associates the displayObject to the scene.
         * As part of the association process, does following things.
         *  - Checks whether an object is already associated with the scene. Throws an
         *    error if that is the case.
         *  - If an object supports mouse and touch events, enables mouse and touch
         *    on scene too.
         *  - Associate new hex color code to an  object.
         *  - Associate scene to an object.
         *  - If onSceneAttached handler is found, calls the handler.
         *  - If onReady handler is found, calls the handler.
         *
         * @function associateDisplayObject(obj)
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        associateDisplayObject: function associateDisplayObject(obj) {

            var item = obj;
            if (obj._scene !== undefined) {
                //Object already associated.
                if (obj._scene === this) {
                    throw new wd.Error("wd-display-object-already-associated");
                }
                else {
                    throw new wd.Error("wd-display-object-already-associated");
                }
            }

            if (item.pointers === true) {
                this.pointers = true;
                this._pointersCount += 1;
            }
            var hex = this._colorService.next();
            item._hex = hex;
            this._hexMap[hex] = item;
            item._scene = this;
            if (item.onSceneAttached) {
                item.onSceneAttached(this);
            }
        },

        /**
         * Returns the displayObject which is associated with the scene.
         *
         * If the object is not yet associated, or obj.scene = 'undefined', this will
         * always return undefined.
         *
         * @function get(index)
         * @param {number} The index position of display object in children collection.
         *
         * @function get(id)
         * @param {string} id The displayObject id.
         *
         * @returns {webDoodling.DisplayObject} The child display object in the
         * children collection.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        get: function get(indexOrId) {
            return this.children.get(indexOrId);
        },

        /**
         * Returns the displayObject which is associated with the scene.
         *
         * If the object is not yet associated, or obj.scene = 'undefined', this will
         * always return undefined.
         *
         * @function get(index)
         * @param {number} The index position of display object in children collection.
         *
         * @function get(id)
         * @param {string} id The displayObject id.
         *
         * @returns {webDoodling.DisplayObject} The child display object in the
         * children collection.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        play: function play() {
            this._mainLoop.play();
        },

        /**
         * Returns the displayObject which is associated with the scene.
         *
         * If the object is not yet associated, or obj.scene = 'undefined', this will
         * always return undefined.
         *
         * @function get(index)
         * @param {number} The index position of display object in children collection.
         *
         * @function get(id)
         * @param {string} id The displayObject id.
         *
         * @returns {webDoodling.DisplayObject} The child display object in the
         * children collection.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            this._mainLoop.pause();
        },

        /**
         * Finds the display object in children heirarchy.
         *
         * @function find(key)
         * @param  {string} key The dot (.) separated keys(ids) of display object.
         * @returns {webDoodling.DisplayObject} The webDoodling.DisplayObject if found,
         * else undefined.
         *
         * @example
         * // This example searches rect in child-group through main-group.
         * var childRect = scene.find("main-group.child-group.rect");
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        find: function find(key) {
            return this.children.find(key);
        },

        /**
         * Gets the color at the specified position in the current scene.
         *
         * @function getColorAt(x, y)
         * @param {Object} x The x position.
         * @param {Object} y The y position.
         * @returns { webDoodling.Color } The color.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        getColorAt: function getColorAt(x, y) {
            var context = this._context,
                pixel = context.getImageData(x, y, 1, 1),
                color = wd.Color.hex(pixel.data[0], pixel.data[1], pixel.data[2], 5);
            return color;
        },

        /**
         * Gets the display-object at specified position.
         *
         * @function getObjectAt(x, y, force)
         * @param {Object} x The x position.
         * @param {Object} y The y position.
         * @returns {webDoodling.DisplayObject} If a display-object is found at the position
         * returns the one, else null.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        getObjectAt: function getObjectAt(x, y, force, considerLastObject) {
            var touchBuffer = this._touchBuffer,
                obj, data, color,
                currentTime = new Date(),
                lastCall = this._lastGetObjectAtCallTime,
                lastObject = this._lastObject,
                width = this._width,
                height = this._height, alpha;

            if (isNaN(x) || isNaN(y)) {
                return null;
            }

            force = (force === undefined) ? false : force;
            considerLastObject = (considerLastObject === undefined) ? false : considerLastObject;

            if (touchBuffer === undefined) {
                return null;
            }

            if (this._pointersCount === 0) {
                return null;
            }

            // If pointer is out of the bound, no need to try find object
            // at given point because it requires dealing with image data.
            if (x < 0 || y < 0 || x > width || y > height) {
                return null;
            }

            if (!force && lastObject) {
                if ((currentTime - lastCall) < 30) {
                    return lastObject;
                }
            }

            data = touchBuffer.getImageData(x, y, 1, 1).data;
            alpha = data[3];

            this._lastGetObjectAtCallTime = currentTime;


            color = Color.hex(data[0], data[1], data[2]);
            obj = this._hexMap[color] || null;

            // Due to Canvas' anti aliasing drawing in place, path and fills
            // are interpolated and sometimes does not render drawings with
            // proper hex. In such cases, when alpha is > 0 or object not dected
            // return lastObject if considerLastObject parameter is true.
            if (alpha > 0 && !obj && considerLastObject === true) {
                return lastObject;
            }

            this._lastObject = obj;

            return obj;
        },

        /**
         * Returns a 2DContext which is not directly associated with current object of Scene
         * but useful in many case such as calculations.
         *
         * @return {[type]} [description]
         */
        getExtraContext: function getExtraContext() {
            var canvas, extraContext;
            if (extraContext) {
                return extraContext;
            }
            canvas = document.createElement("canvas");
            extraContext = canvas.getContext("2d");
            return extraContext;
        },

        /**
         * Returns the canvas image in the form of Base64 data url.
         *
         * @function toDataURL()
         * @returns {string} The data url.
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        toDataURL: function toDataURL() {
            return this._canvas.toDataURL();
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Scene].
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Scene]";
        },

        //setupCanvas
        _setupCanvas: function (canvas) {
            var can, ctx,
                style;

            if (canvas === undefined) {
                throw new wd.Error("wd-no-argument", "canvas");
            }
            else if (wd.is.string(canvas)) {
                can = document.getElementById(canvas);
                if (!can) {
                    throw new wd.Error("wd-item-not-found", canvas);
                }
            }
            else if (canvas instanceof HTMLCanvasElement) {
                can = canvas;
            }
            else {
                throw new wd.Error("wd-invalid-argument", "canvas");
            }

            ctx = can.getContext("2d");
            //Set Dimensions
            style = getComputedStyle(can, null);
            this._width = self._width = parseInt(can.getAttribute("width"), 10) || parseInt(style.getPropertyValue("width"), 10);
            this._height = self._height = parseInt(can.getAttribute("height"), 10) || parseInt(style.getPropertyValue("height"), 10);

            this._canvas = can;
            this._context= ctx;

            // Register the current scene with the manger.
            wd.Scene.manager.register(this);
        },

        //Setup Main Loop
        _setupMainLoop: function () {

            var mainLoop = new wd.AnimationLoop(function mainLoop() {
                this.trigger("animationLoop", new wd.EventArgs("animationLoop"));

                if (this._timeline.update() === true) {
                    this.update();
                }
                if (this._updateRequests > 0) {
                    this._update();
                    this._updateRequests = 0;
                }
            }, this._canvas, this);
            mainLoop.fps = this.fps;
            this._mainLoop = mainLoop;
        },

        //Setup Timeline
        _setupTimeline: function _setupTimeline() {
            //Animations and Timeline
            this._timeline = new wd.Timeline(this);
            this._timeline._parent = this;
        },

        // Setup children
        _setupChildren: function _setupChildren() {
            var self,
                children = new wd.DisplayObjectCollection();

            self = this;
            this._children = children;

            children.itemAdd(function (args) {
                self.associateDisplayObject(args.item);
            });
        },


        // Clears the canvas drawing. Does not removes the display objects
        // from children collection.
        _clear: function _clear() {
            var ctx = this._context,
                background = this.backgroundColor,
                w = this._width,
                h = this._height;

            if (background === "transparent") {
                ctx.clearRect(0, 0, w, h);
            }
            else {
                ctx.fillStyle = background;
                ctx.fillRect(0, 0, w, h);
            }

            //Also clear mouse buffer
            if (this._touchBuffer) {
                // TouchBuffer.setTransform(1, 0, 0, 1, 0, 0);
                this._touchBuffer.clearRect(0, 0, w, h);
            }
            return self;
        },

        // Updates the scene
        _update: function _update() {
            var i, iLen,
                obj,
                hitContext,
                ctx = this._context,
                objects = this.children._items;


            // Clear contenxt
            this._clear();
            ctx.save();
            // Update all display objects
            for (i = 0, iLen = objects.length; i < iLen; i++) {
                obj = objects[i];
                hitContext = undefined;
                if (obj.visible === false) {
                    continue;
                }
                if (this.pointers && obj.pointers) {
                    hitContext = this._touchBuffer;
                }
                obj.onUpdate(ctx, hitContext);
            }
            ctx.restore();
        },

        // Mark the scene active or inactive
        _activate: function (active) {
            if (active === this._active) {
                return;
            }
            if (active === true) {
                //Activate pointers if enabled
                if (this.pointers === true) {
                    this._eventManager.enabled = true;
                }
                this._mainLoop.play();
            }
            else {
                //Deactivate pointers if enabled
                if (this.pointers === true) {
                    this._eventManager.enabled = false;
                }
                this._mainLoop.pause();
            }
            this._active = active;
            this.update();
        }

    }, wd.Serializable);

    wd.Scene = Scene;
    //TODO: Recheck the following function
//    function _debounce(func, wait, immediate) {
//        var timeout;
//        return function() {
//            var context = this, args = arguments;
//            var later = function() {
//                timeout = null;
//                if (!immediate) func.apply(context, args);
//            };
//            var callNow = immediate && !timeout;
//            clearTimeout(timeout);
//            timeout = setTimeout(later, wait);
//            if (callNow) func.apply(context, args);
//        };
//    }

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Scene Events
(function (wd) {
    "use strict";

    var cloneArgs = wd.PointerEventArgs.clone;

    wd.Scene.attach({

        /**
         * Represents an event which is triggered when the scene is successfully
         * initialized and all the associated display objects are loaded.
         *
         * @event ready(e)
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        ready: wd.event(),

        /**
         * Gets or sets `pointers` support for this scene. If true, while
         * enables the `pointers` events for the scene. The scene pointers also
         * becomes active when any of the child object has pointers enabled or
         * draggabled set to true at the time of scene initialization.
         *
         * @field {boolean} pointers
         * @default false
         *
         * @example
         *
         * // Enable pointers while declaration.
         * var scene = webDoodling.Scene({
         *     pointers: true,
         *     children: [
         *         ...
         *     ]
         * });
         *
         * //Deactivate pointers.
         * scene.pointers = false;
         *
         * // This example will enable scene pointers even if it is not explicitly mentioned in the scene declaration.
         * var scene = wd.Scene({
         *     children: [
         *         webDoodling.Rectangle({
         *             x: 100, y: 100,
         *             width: 100, height: 100,
         *             draggable: true,
         *             styles: [
         *                 wd.Fill('red')
         *             ]
         *         })
         *     ]
         * });
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointers: wd.property({
            get: function () {
                return this._mouseAndTouch;
            },
            set: function (v) {
                var enabled = this._mouseAndTouch;
                if (v === enabled) {
                    return;
                }
                this._mouseAndTouch = v;
                this._eventManager.enabled = v;
            }
        }),

        /**
         * Returns the x position of the `lastPointerX` in `webDoodling.Scene`.
         *
         * @readonly {number} lastPointerX
         * @default null
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        lastPointerX: wd.readonly(null),

        /**
         * Returns the y position of the `lastPointerY` in `webDoodling.Scene`.
         *
         * @readonly {number} lastPointerY
         * @default null
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        lastPointerY: wd.readonly(null),

        /**
         * Returns `true` if the pointer is within the boundary of the scene, else `false`.
         *
         * @readonly {boolean} lastPointerIn
         * @default false
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        lastPointerIn: wd.readonly(false),

        /**
         * Returns `true` if any of the pointer button is down, else `false`.
         *
         * @readonly {boolean} lastPointerDown
         * @default false
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        lastPointerDown: wd.readonly(false),

        /**
         * Represents an event which is triggered when the `pointerover`
         * the `webDoodling.Scene` canvas.
         *
         * @event pointerover(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerover`. |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointerover: wd.event(),

        /**
         * Represents an event which is triggered when the `pointerout`
         * the `webDoodling.Scene` canvas.
         *
         * @event pointerout(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerout`. |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointerout: wd.event(),

        /**
         * Represents an event which is triggered when the `pointerenter`
         * the `webDoodling.Scene` canvas.
         *
         * @event pointerenter(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerenter`. |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointerenter: wd.event(),

        /**
         * Represents an event which is triggered when the `pointermove`
         * over the `webDoodling.Scene` canvas.
         *
         * @event pointermove(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointermove`.  |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointermove: wd.event(),

        /**
         * Represents an event which is triggered when the `pointerleave`
         * the `webDoodling.Scene` canvas.
         *
         * @event pointerleave(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerleave`. |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointerleave: wd.event(),

        /**
         * Represents an event which is triggered when the pointer is down
         * on the `webDoodling.Scene` canvas.
         *
         * @event pointerdown(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerdown`.  |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointerdown: wd.event(),

        /**
         * Represents an event which is triggered when the pointer is lifted
         * from the `webDoodling.Scene` canvas.
         *
         * @event pointerup(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerup`.    |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointerup: wd.event(),

        /**
         * Represents an event which is triggered when the pointer
         * is cancelled for the `webDoodling.Scene` canvas.
         *
         * @event pointercancel(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointercancel`.|
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        pointercancel: wd.event(),

        /**
         * Represents an event which is triggered when the pointer
         * is pressed and lifted on the `webDoodling.Scene` canvas .
         *
         * @event tap(e)
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `tap`.          |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.Scene
         * @public
         * @version 1.0
         **/
        tap: wd.event(),

        //Event handling protocol
        _setupEvents: function () {
            var eventManager,
                touchCanvas = document.createElement("canvas"),
                touchBuffer,
                width, height;

            this._capturedObjects = {};

            // document.getElementsByTagName('body')[0].appendChild(touchCanvas);

            //Setup EventManager
            eventManager                    = new wd.EventManager(this._canvas, this);
            eventManager.onPointerOver      = this._onPointerOver;
            eventManager.onPointerEnter     = this._onPointerEnter;
            eventManager.onPointerOut       = this._onPointerOut;
            eventManager.onPointerLeave     = this._onPointerLeave;
            eventManager.onPointerMove      = this._onPointerMove;
            eventManager.onPointerDown      = this._onPointerDown;
            eventManager.onPointerUp        = this._onPointerUp;
            eventManager.onPointerCancel    = this._onPointerCancel;
            this._eventManager              = eventManager;


            //Find canvas dimention
            width   = this._canvas.getAttribute("width");
            height  = this._canvas.getAttribute("height");

            //Set touchCanvas dimension
            touchCanvas.width   = width;
            touchCanvas.height  = height;

            //Create hitregion buffer canvas.
            touchBuffer         = touchCanvas.getContext("2d");
            this._touchCanvas   = touchCanvas;

            // //Disable imageSmoothing on buffer canvas, so that it can detect
            // //return proper color code when asked.
            // touchBuffer.imageSmoothingEnabled       = false;
            // touchBuffer.mozImageSmoothingEnabled    = false;
            // touchBuffer.oImageSmoothingEnabled      = false;

            // Only apply webkitImageSmoothingEnabled when width or hegith is > 0
            // http://code.google.com/p/chromium/issues/detail?can=2&start=0&num=100&q=&colspec=ID%20Pri%20Mstone%20ReleaseBlock%20OS%20Area%20Feature%20Status%20Owner%20Summary&groupby=&sort=&id=154695
            if (width > 0 && height > 0) {
                if (touchBuffer.imageSmoothingEnabled !== undefined) {
                    touchBuffer.imageSmoothingEnabled = false;
                }
                else {
                    touchBuffer.mozImageSmoothingEnabled    = false;
                    touchBuffer.oImageSmoothingEnabled      = false;
                    touchBuffer.webkitImageSmoothingEnabled = false;
                }
            }
            this._touchBuffer = touchBuffer;
        },

        //Pointer Over
        _onPointerOver: function (eventArgs) {
            this._lastPointerIn = true;
            this.trigger("pointerover", eventArgs);
        },

        // Pointer Enter
        _onPointerEnter: function (eventArgs) {
            this._lastPointerIn = true;
            this.trigger("pointerenter", eventArgs);
        },


        // Pointer Out
        _onPointerOut: function (eventArgs) {
            this._lastPointerIn = false;
            this.trigger("pointerout", eventArgs);
        },

        //Pointer Leave
        _onPointerLeave: function (eventArgs) {
            this._lastPointerIn = false;
            this.trigger("pointerleave", eventArgs);
        },


        // Pointer Move
        _onPointerMove: function (eventArgs, pointer) {
            var x = eventArgs.x,
                y = eventArgs.y,
                obj = this.getObjectAt(x, y, false, true),
                retObj = null,
                prevObj = pointer.object;

            // Touch does not have pointerover, pointerenter, pointerout and pointerleave events
            // hence, trigger them.
            if (eventArgs.type === "touch") {
                if (x < 0 || y < 0 || x > this._width || y > this._height) {
                    if (this._lastPointerIn !== false) {
                        this._lastPointerIn = false;
                        this.trigger("pointerout", cloneArgs(eventArgs, true, true));
                        this.trigger("pointerleave", cloneArgs(eventArgs, false, false));
                    }
                }
                else {
                    if (this._lastPointerIn !== true) {
                        this._lastPointerIn = true;
                        this.trigger("pointerover", cloneArgs(eventArgs, true, true));
                        this.trigger("pointerenter", cloneArgs(eventArgs, false, false));
                    }
                }
            }

            this._lastPointerX = x;
            this._lastPointerY = y;

            //Object not detected, trigger pointerleave on prev obj if found.
            if (!obj) {
                if (prevObj !== null) {
                    if (prevObj.scene !== this) {
                        return null;
                    }
                    // Trigger pointerleave on privious object, if found.
                    this._triggerObjectEvent("pointerout", prevObj, null, cloneArgs(eventArgs, true, true));
                    this._triggerObjectEvent("pointerleave", prevObj, null, cloneArgs(eventArgs, false, false));
                }
            }
            else {
                //Object found but is it same with prev object? if not, trigger
                //pointerleave on prev one if prev is avilable.
                if (prevObj !== obj) {
                    if (prevObj !== null) {
                        this._triggerObjectEvent("pointerout", prevObj, obj, cloneArgs(eventArgs, true, true));
                        this._triggerObjectEvent("pointerleave", prevObj, obj, cloneArgs(eventArgs, false, false));

                    }
                    this._triggerObjectEvent("pointerover", obj, prevObj, cloneArgs(eventArgs, true, true));
                    this._triggerObjectEvent("pointerenter", obj, prevObj, cloneArgs(eventArgs, false, false));
                }
                this._triggerObjectEvent("pointermove", obj, null, cloneArgs(eventArgs));
                retObj = obj;
            }
            this.trigger("pointermove", eventArgs);
            pointer.object = retObj;
        },

        // Pointer Down
        _onPointerDown: function (eventArgs, pointer) {
            var obj = this.getObjectAt(eventArgs.x, eventArgs.y, true);

            this._lastPointerDown   = true;
            this._lastPointerIn     = true;
            this._lastPointerX      = eventArgs.x;
            this._lastPointerY      = eventArgs.y;

            this.trigger("pointerdown", eventArgs);
            if (eventArgs.pointerType === "touch") {
                this.trigger("pointerover", cloneArgs(eventArgs));
                this.trigger("pointerenter", cloneArgs(eventArgs));
            }

            if (obj) {
                pointer.object = obj;
                this._capturedObjects[eventArgs.identifier] = obj;
                this._triggerObjectEvent("pointerdown", obj, null, eventArgs);
                if (eventArgs.pointerType === "touch") {

                    this._triggerObjectEvent("pointerover", obj, null, cloneArgs(eventArgs, true, true));
                    this._triggerObjectEvent("pointerenter", obj, null, cloneArgs(eventArgs, false, false));
                }
                eventArgs.handled = true;
            }
        },

        // Pointer Up
        _onPointerUp: function (eventArgs, pointer) {
            var obj = pointer.object,
                capturedObj = this._capturedObjects[eventArgs.identifier];

            delete this._capturedObjects[eventArgs.identifier];

            this._lastPointerDown = false;
            if (obj) {
                this._triggerObjectEvent("pointerup", obj, null, eventArgs);

                // Fires pointerout and pointerleave events when pointerType is not
                // a mouse.
                if (eventArgs.pointerType !== "mouse") {
                    this._triggerObjectEvent("pointerout", obj, obj, cloneArgs(eventArgs, true, true));
                    this._triggerObjectEvent("pointerleave", obj, obj, cloneArgs(eventArgs, false, false));
                }
                if (obj === capturedObj) {
                    this._triggerObjectEvent("tap", obj, null, new wd.EventArgs("tap"));
                }
            }

            this.trigger("pointerup", eventArgs);
            if (this._lastPointerIn === true) {
                this.trigger("tap", new wd.EventArgs("tap"));
            }
        },

        // Pointer Cancel
        _onPointerCancel: function (eventArgs, pointer) {
            var obj = pointer.object;
            delete this._capturedObjects[eventArgs.pointerId];

            if (obj) {
                this._triggerObjectEvent("pointercancel", pointer.object, null, cloneArgs(eventArgs));
                // Must fire pointerout and pointerleave after pointer cancel.
                this._triggerObjectEvent("pointerout", obj, obj, cloneArgs(eventArgs, true, true));
                this._triggerObjectEvent("pointerleave", obj, obj, cloneArgs(eventArgs, false, false));
            }
            this.trigger("pointercancel", eventArgs);
        },

        // Triggers specified event for display object and its parents if available
        // and cancelBubble is false.
        _triggerObjectEvent: function (eventName, object, previousObject, eventArgs) {
            var parent, parents = object.parents,
                sameObject = object === previousObject,
                previousParent, previousParents, found,
                triggeringParents,
                i, iLen,
                j, jLen;

            object.trigger(eventName, eventArgs);

            if (this._stopPropagation === true) {
                this._stopPropagation = false;  // Reset it for the next subscriber in event.
                return;
            }

            eventArgs._type = eventName;

            // Pointer Enter
            //
            // If previous object is null, triger pointerenter on all the parents.
            //
            // Else, trigger pointerenter on all the parents who
            // does not match with any of the previous object's parents.


            // Pointer Leave
            // If object is null, trigger pointer leave on all the parents of
            // the previous object.
            //
            // Trigger pointer leave on all the previous parents which does not share
            // parents with current object's parents.
            //
            // Is both object and previousObject are same that m
            if ((eventName === "pointerenter" || eventName === "pointerleave") && !sameObject) {
                if (!previousObject) {
                    triggeringParents = parents;
                }
                else {
                    triggeringParents = [];
                    previousParents = previousObject.parents;
                    for (i = 0, iLen = parents.length; i < iLen; i += 1) {
                        parent = parents[i];
                        found = false;
                        for (j = 0, jLen = previousParents.length; j < jLen; j += 1) {
                            previousParent = previousParents[j];
                            if (parent === previousParent) {
                                found = true;
                                break;
                            }
                        }
                        if (found === false) {
                            triggeringParents.push(parent);
                        }
                        else {
                            break;
                        }
                    }
                }
            }
            else {
                triggeringParents = object.parents;
            }

            // Trigger all parents if not marked for stopPropagation and bubbles is true.
            if (eventArgs.bubbles !== false) {
                for(i = 0, iLen = triggeringParents.length; i < iLen; i += 1) {
                    parent = triggeringParents[i];

                    if (eventArgs._stopPropagation) {
                        eventArgs._stopPropagation = false; // Reset it for the next subscriber in event.
                        break;
                    }
                    parent.trigger(eventName, eventArgs);
                }
            }
        }
    });

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Styles
(function (wd) {
    "use strict";

    var SceneManager;

    // Manages the scene
    SceneManager = wd.Class({

        // Returns the SceneManager
        type: wd.type("SceneManager"),

        // Initializes the new instance of wd.SceneManager
        init: function () {
            this._manager = {};
            this._nameService = new wd.utils.NameService("wd-canvas-");
        },

        // Registers
        register: function register(scene) {
            var canvas, canvasId, scenes;

            canvas = scene.canvas;
            canvasId = canvas.getAttribute("data-wd-canvas");

            // If it is a new canvas,
            if (canvasId  === null) {
                canvasId = this._nameService.next();
                canvas.setAttribute("data-wd-canvas", canvasId);
                this._manager[canvasId] = [scene];
            }
            else {
                scenes = this._manager[canvasId];
                if (scenes.indexOf(scene) === -1) {
                    scenes.push(scene);
                }
            }
        },

        // activates the scene for given canvas, and
        // deactivates all other.
        activateScene: function (scene) {
            var canvasId, scenes,
                i, iLen;

            canvasId = scene.canvas.getAttribute("data-wd-canvas");

            // Scene is already active.
            if (scene.active === true) {
                return;
            }

            // If canvasId not found, return
            if (canvasId  === null) {
                return;
            }
            scenes = this._manager[canvasId];

            for (i = 0, iLen = scenes.length; i < iLen; i += 1) {
                if (scene === scenes[i]) {
                    scenes[i]._activate(true);
                }
                else {
                    scenes[i]._activate(false);
                }
            }
        },

        toString: function toString() {
            return "[object webDoodling.SceneManager]";
        }

    });

    // Do not use wd.Scene.manager in your code.
    wd.Scene.manager = new SceneManager();

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//AssetCore
(function (wd) {
    "use strict";

    /**
     * Represents the various states of assets.
     *
     * @object webDoodling.AssetStates
     *
     * @public
     * @version 1.0
     **/
    wd.AssetStates = {

        /**
         * Represents the asset not loaded state.
         *
         * @field {number} NOT_LOADED
         *
         * @memberOf webDoodling.AssetStates
         * @public
         * @version 1.0
         **/
        NOT_LOADED: 0,

        /**
         * Represents the asset is in ready state.
         *
         * @field {number} READY
         *
         * @memberOf webDoodling.AssetStates
         * @public
         * @version 1.0
         **/
        READY: 1,

        /**
         * Asset has been tried to load but error occured while loading.
         *
         * @field {number} READY
         *
         * @memberOf webDoodling.AssetStates
         * @public
         * @version 1.0
         **/
        ERROR: 2
    };

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//AssetCollection
(function (wd) {
    "use strict";

    var AssetCollection;

    /**
     * Represents the collection of assets which is used by `webDoodling.AssetManager`.
     * Only objects of type `webDoodling.Asset` can be added into this collection.
     *
     * @class webDoodling.AssetCollection
     * @see webDoodling.AssetManager.assets
     *
     * @memberOf webDoodling
     * @extends webDoodling.Collection
     * @public
     * @version 1.0
     **/
    AssetCollection = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.Asset` always 'AssetCollection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AssetCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("AssetCollection"),

        /**
         * Represents the `manager`.
         *
         * @readonly {string} manager
         * @default null
         *
         * @memberOf webDoodling.AssetCollection
         * @public
         * @version 1.0
         **/
        manager: wd.readonly(null),

        /**
         * Initializes the new instance of `webDoodling.AssetCollection`.
         *
         * @constructor init([manager])
         * @param {[webDoodling.AssetManager]} manager The manager to which this collection is attached.
         *
         * @memberOf webDoodling.AssetCollection
         * @public
         * @version 1.0
         **/
        init: function init(manager) {
            this.base();
            if (manager) {
                this._manager = manager;
                this.itemAdd(function (e) {
                    e.item._manager = manager;
                });
            }
        },

        /**
         * Gets invoked when an object is required to be validated before it
         * is pushed into the collection.
         *
         * @callback function onValidate(obj)
         *
         * @member Of webDoodling.AssetCollection
         * @protected
         * @version 1.0
         **/
        onValidate: function onValidate(obj) {
            if (obj instanceof wd.Asset === false) {
                throw new wd.Error("wd-invalid-argument", obj);
            }
            return null;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AssetCollection].
         *
         * @memberOf webDoodling.AssetCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AssetCollection]";
        }

    }, wd.Collection);

    wd.AssetCollection = AssetCollection;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//AssetManager
(function (wd) {
    "use strict";

    var AssetManager;

    /**
     * Represents an asset manager which facilitates asset preloading and
     * provides various notifications useful for tracking progress.
     *
     * @class webDoodling.AssetManager
     * @example
     * var assetManager = new wd.AssetManager({
     *     autoLoad:true,
     *     assets:[
     *         new wd.ImageAsset('image1.png', 'image1'),
     *         new wd.ImageAsset('image2.png', 'image2')],
     *     progress:function () {
     *         alert('onProgress');
     *     },
     *     complete:function () {
     *         alert('Assets loaded.')
     *     }
     * });
     *
     * @memberOf webDoodling
     * @extends webDoodling.Serializable
     * @public
     * @version 1.0
     **/
    AssetManager = wd.Class({

        /**
         * Returns the `type` of `webDoodling.AssetManager`, always return AssetManager.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        type: wd.type("AssetManager"),

        /**
         * If set to true, initiates asset loading as soon as the object is initialized.
         * This attribute is effective only if it is set during initialization.
         *
         * @field {boolean} autoLoad
         * @default false
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        autoLoad: wd.attribute(false),

        /**
         * Returns the count of the assets which have been successfully loaded.
         *
         * @readonly {number} successCount
         * @default 0
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        successCount: wd.readonly(0),

        /**
         * Returns the count of an error when an error has occured while loading.
         *
         * @readonly {number} errorCount
         * @default 0
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        errorCount: wd.readonly(0),

        /**
         * Returns the total percentage of assets which have been currently processed.
         *
         * @readonly {number} currentProgress
         * @default 0
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        currentProgress: wd.readonly(0),

        /**
         * Returns the total percentage of assets which have been processed.
         *
         * @readonly {webDoodling.AssetCollection} assets
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        assets: wd.readonly(),

        /**
         * Triggers the `progress` event when any asset is loaded .
         *
         * @event progress(e)
         * @param {object} e An event param object contains members provides
         * useful asset progress related data.
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        progress: wd.event(),

        /**
         * Triggers the `complete` state of assets which have been processed.
         *
         * @event complete(e)
         * @param {object} e An event param object contains members provides
         * useful asset progress related data.
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        complete: wd.event(),

        /**
         * Triggers the `success` event when all the assets are successfully loaded.
         *
         * @event complete(e)
         * @param {object} e An event param object contains members provides
         * useful asset progress related data.
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        success: wd.event(),

        /**
         * Triggers the `error` event when some or all assets get an error while loading.
         *
         * @event complete(e)
         * @param {object} e An event param object contains members provides
         * useful asset progress related data.
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        error: wd.event(),

        /**
         * Initializes the new instance of `webDoodling.AssetManager`.
         *
         * @constructor init([o])
         * @param {[object]} o The initialization object (optional).
         *
         * @example
         * var assetManager = new wd.AssetManager();
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            var self = this;
            var assets = new wd.AssetCollection(this);
            this.base();

            this.serializables("autoLoad");

            this._assets = assets;
            assets.itemBeforeAdd(function (args) {
                if (args.item instanceof wd.Asset === false) {
                    args.act = false;
                }
            });
            assets.itemAdd(function (args) {
                var item = args.item;
                item._manager = self;
                item.success(function (e) {
                    self._successCount++;
                    self._updateProgress(item, e);
                });

                item.error(function (e) {
                    self._errorCount++;
                    self._updateProgress(item, e);
                });
            });

            if (o) this.deserialize(o);

            if (this.autoLoad === true) {
                this.load();
            }
        },

        /**
         * Returns the asset having specified id or index.
         *
         * @function get(index)
         * @param {number} index The asset index position.
         * @example
         * var asset = assetManager.get(0);
         *
         * @function get(id)
         * @param {string} id The asset id.
         * @example
         * var asset = assetManager.get("img-1");
         *
         * @returns {webDoodling.Asset} Returns the asset if found otherwise `undefined`.
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        get: function get(indexOrId) {
            return this.assets.get(indexOrId);
        },

        /**
         * Loads all the registered assets.
         *
         * @function load([force])
         * @param {[boolean]} force If true, all the assets are forcefully load
         * regardless of its state otherwise only loads assets which is not yet
         * ready (state is not `webDoodling.AssetStates.READY`).
         * @returns {webDoodling.AssetManager} The current instance.
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        load: function load(force) {
            var assets = this.assets;

            if (force && this._successCount > 0) {
                this._successCount = 0;
            }
            this._errorCount = 0;
            this._currentProgress = this._successCount + this._errorCount;
            assets.each(function (asset) {
                asset.load.call(asset, force);
            });
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns[object.weboodling.AssetManager].
         *
         * @memberOf webDoodling.AssetManager
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AssetManager]";
        },

        //Handles the progress, updates and triggers respecitve events.
        _updateProgress: function (asset, args) {
            var s = this._successCount,
                e = this._errorCount,
                t = s + e,
                a = this.assets.length,
                eventArgs = new wd.AssetProgressEventArgs();

            eventArgs.processed = t;
            eventArgs.processedPercentage = (t * 100 / a);
            eventArgs.asset = asset;

            if ("error" in args) {
                eventArgs.error = args.error;
                eventArgs.success = false;
            }
            else {
                eventArgs.success = true;
            }

            // Trigger progress
            if (this._currentProgress !== t) {
                this.trigger("progress", eventArgs);
                this._currentProgress = t;
            }

            // Trigger complete if finished.
            if (t === a) {
                this.trigger("complete", new wd.EventArgs("complete"));
                if (s === t) {
                    this.trigger("success", new wd.EventArgs("success"));
                }
                else {
                    this.trigger("error", new wd.EventArgs("error"));
                }
            }

        }

    }, wd.Serializable);

    wd.AssetManager = AssetManager;
})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Asset
(function (wd) {
    "use strict";

    var AssetStates = wd.AssetStates,
        Asset;

    /**
     * Provides the base class for all the assets in `webddodling`. This
     * class cannot be directly instantiated, use derived class such as
     * `webDoodling.ImageAsset` to instantiate this.
     *
     * @class webDoodling.Asset
     * @example
     * var assest = new wd.AssetManager({
     *     assets:[
     *         new wd.ImageAsset('image1.png', 'image1'),
     *         new wd.ImageAsset('image2.png', 'image2')
     *     ],
     *
     *     var scene = new wd.Scene(canvas,{
     *          autoPlay:true,
     *           children:[
     *               new wd.Image({
     *                   id: 'image1',
     *                   x: 300,
     *                   y: 150,
     *                   source:assetManager.assets.get('image1')
     *               }),
     *               new wd.Image({
     *                   id: 'image2',
     *                   x: 140,
     *                   y: 100,
     *                   source:assetManager.assets.get('image2')
     *               })
     *           ]
     *
     *     });
     * });
     *
     * @memberOf webDoodling
     * @extends webDoodling.Serializable
     * @public
     * @version 1.0
     **/
    Asset = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.Asset`, always returns'Asset'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        type: wd.type("Asset"),

        /**
         * Gets or sets the `id` of the current object.
         *
         * @field {string} id
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        id: wd.attribute(),

        /**
         * Triggers when an asset is succesfully loaded.
         *
         * @event success(eventArgs)
         * @param {webDoodling.AssetSuccessEventArgs} eventArgs
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        success: wd.event(),

        /**
         * Triggers when an error has occured while loading.
         *
         * @event error(e)
         * @param {object} e An event param object contains members provides
         * useful asset progress related data.
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        error: wd.event(),

        /**
         * Gets the loaded media object for current asset. For example
         * for `webDoodling.Asset`  `media` holds the reference
         * to the loaded image. If it is null it means `media` is not yet available.
         *
         * @readonly {object or null} media
         * @default null
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        media: wd.readonly(null),

        /**
         * Represents the `state`.
         *
         * @readonly {webDoodling.AssetStates} state
         * @default webDoodling.AssetStates.NOT_LOADED
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        state: wd.readonly(AssetStates.NOT_LOADED),

        /**
         * Represents the `loadError`.
         *
         * @readonly {object} loadError
         * @default null
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        loadError: wd.readonly(null),

        /**
         * Represents the `manager`.
         *
         * @readonly {webDoodling.AssetManager} manager
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        manager: wd.readonly(),

        /**
         * Prevents initialization of `webDoodling.Asset` object. Assets can
         * be initialized only through derived classes such as `webDoodling.Asset`.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();
            this.serializables("id");
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object.webDoodling.Asset].
         *
         * @memberOf webDoodling.Asset
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Asset]";
        }

    }, wd.Serializable);

    wd.Asset = Asset;
})(window.webDoodling);
//Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India

//ImageAsset
(function (wd, undefined) {
    "use strict";

    var AssetStates = wd.AssetStates,
        ImageAsset;

    /**
     * Represents an image asset which makes it easy to deal with images in
     * `webDoodling`. Once an image is loaded it is accessible through
     * media property.
     *
     * @class webDoodling.ImageAsset
     *
     * @example
     * var image = wd.ImageAsset("path/to/image.png", "image-id");
     * image.success(function() {
     *     alert("image loaded");
     * });
     * image.load();
     *
     * @memberOf webDoodling
     * @extends webDoodling.Asset
     * @public
     * @version 1.0
     **/
    ImageAsset = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.ImageAsset`, always returns 'ImageAsset'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ImageAsset
         * @public
         * @version 1.0
         **/
        type: wd.type("ImageAsset"),

        /**
         * Gets or sets the image source. When the `source` field is set
         * `state` and `media` fields are reset too.
         *
         * Note: Always use ImageAsset in acompany with AssetManager.
         *
         * @field {string} source
         *
         * @memberOf webDoodling.ImageAsset
         * @public
         * @version 1.0
         **/
        source: wd.property({
            get: function () {
                return this._source;
            },
            set: function (value) {
                if (!wd.is.string(value)) {
                    throw new wd.Error("wd-image-source-type-not-supported");
                }
                this._state = AssetStates.NOT_LOADED;
                this._media = null;
                this._source = value;
            }
        }),

        /**
         * Represents the calculated width of the currently loaded image.
         *
         * @readonly {number} width
         * @default 0
         *
         * @memberOf webDoodling.ImageAsset
         * @public
         * @version 1.0.
         **/
        width: wd.readonly(0),

        /**
         * Represents the calculated height of the currently loaded image.
         *
         * @readonly {number} height
         * @default 0
         *
         * @memberOf webDoodling.ImageAsset
         * @public
         * @version 1.0.
         **/
        height: wd.readonly(0),

        /**
         * Initializes the new instance of `webDoodling.ImageAsset`.
         *
         * @constructor init(source, id)
         * @param {string} source The image src. required
         * @param {[string]} id An optional asset identifier.
         *
         * @example
         * var image = wd.ImageAsset("path/to/image.png", "image-id");
         *
         * @memberOf webDoodling.ImageAsset
         * @public
         * @version 1.0
         **/
        init: function init(source, id) {

            this.base();
            this.serializables("source");

            if (arguments.length === 0) {
                return;
            }
            else if (arguments.length === 1) {
                if(wd.is.plainObject(arguments[0])) {
                    this.deserialize(arguments[0]);
                    if (this.id === undefined) {
                        this.id = this.source;
                    }
                }
                else {
                    this.source = source;
                    this.id = source;
                }
            }
            else {
                this.source = source;
                this.id = id;
            }
        },

        /**
         * Initiates the image load, triggers `success` or `error` event. Once the image is loaded
         * it can be accessed through `media` property.
         *
         * @function load([force])
         * @param {boolean} force If true asset is forcefully loaded
         * regardless of its state otherwise only loads if it is not yet
         * ready.
         *
         * @example
         * var image = wd.ImageAsset("path/to/image.png", "image-id");
         * image.success(function() {
         *     alert("image loaded");
         * });
         * image.load();
         *
         * @returns {webDoodling.ImageAsset} The current object, useful for chaining.
         *
         * @memberOf webDoodling.ImageAsset
         * @public
         * @version 1.0
         **/
        load: function load(force) {
            var self = this,
                img = new Image();

            if (!this._source) {
                return;
            }
            if (this._state === AssetStates.READY) {
                if (!force) {
                    return;
                }
            }

            this._state = AssetStates.NOT_LOADED;
            this._loadError = null;
            this._width = this._height = 0;


            img.onload = function () {
                self._state = AssetStates.READY;
                self._media = img;
                self._width = img.width;
                self._height = img.height;
                self.trigger("success", new wd.AssetSuccessEventArgs(img));
            };

            img.onerror = function (e) {
                self._state = AssetStates.ERROR;
                self._loadError = e;
                self.trigger("error", new wd.AssetErrorEventArgs(e));
            };
            img.src = this._source;
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ImageAsset].
         *
         * @memberOf webDoodling.ImageAsset
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ImageAsset]";
        }

    }, wd.Asset);

    wd.ImageAsset = ImageAsset;

})(window.webDoodling);
//Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India

//AudioAsset
(function (wd, undefined) {
    "use strict";

    var AssetStates = wd.AssetStates,
        AudioAsset;

    /**
     * Represents an audio asset which makes it easy to deal with audio in
     * `webDoodling`. Once an audio is loaded it is accessible through
     * media property.
     *
     * @class webDoodling.AudioAsset
     * @example
     * var audio = wd.AudioAsset("path/to/sound.mp3", "audio-id");
     * audio.success(function() {
     *     alert("Audio loaded");
     * });
     * audio.load();
     *
     * @memberOf webDoodling
     * @extends webDoodling.Asset
     * @public
     * @version 1.0
     **/
    AudioAsset = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.AudioAsset`, always returns 'AudioAsset'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AudioAsset
         * @public
         * @version 1.0
         **/
        type: wd.type("AudioAsset"),

        /**
         * Gets or sets the audio source. When the `source` field is set
         * `state` and `media` fields are reset too.
         *
         * @field {string} source
         *
         * @memberOf webDoodling.AudioAsset
         * @public
         * @version 1.0
         **/
        source: wd.property({
            get: function () {
                return this._source;
            },
            set: function (value) {
                this._state = AssetStates.NOT_LOADED;
                this._media = null;
                this._source = value;
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.AudioAsset`.
         * If source is provided as an array then first item in the array
         * is used as an id when id parameter is missing.
         *
         * @constructor init(source, id)
         * @param {string} source The image src. required
         * @param {[string]} id The asset identifier. This is an optional parameter,
         * sets source as an id if not provided.
         *
         * @example
         * var audio = wd.AudioAsset("path/to/sound.mp3", "audio-id");
         *
         * @memberOf webDoodling.AudioAsset
         * @public
         * @version 1.0
         **/
        init: function (source, id) {
            this.base();
            this.serializables("source");

            if (arguments.length === 0) {
                return;
            }
            else if (arguments.length === 1) {
                if(wd.is.plainObject(arguments[0])) {
                    this.deserialize(arguments[0]);
                    if (this.id === undefined) {
                        this.id = this.source;
                    }
                }
                else if (wd.is.array(arguments[0])) {
                    this.source = source;
                    this.id = source[0];
                }
                else {
                    this.source = source;
                    this.id = source;
                }
            }
            else {
                this.source = source;
                this.id = id;
            }
        },

        /**
         * Initiates the audio load, triggers `success` or `error` event. Once the audio is loaded
         * it can be accessed through `media` property.
         *
         * @function load([force])
         * @param {boolean} force If true asset is forcefully loaded
         * regardless of its state otherwise only loads if it is not yet
         * ready.
         *
         * @example
         * var audio = wd.AudioAsset("path/to/sound.mp3", "audio-id");
         * audio.success(function() {
         *     alert("Audio loaded");
         * });
         * audio.load();
         *
         * @returns {webDoodling.AudioAsset} The current object, useful for chaining.
         *
         * @memberOf webDoodling.AudioAsset
         * @public
         * @version 1.0
         **/
        load: function (force) {
            var self = this,
                audio;

            if (!this._source) {
                return;
            }
            if (this._state === AssetStates.READY) {
                if (!force) {
                    return;
                }
            }

            if (wd.is.webAudio) {
                audio = new wd.WebAudioSource(this._source);
            }
            else {
                audio = new wd.HTML5AudioSource(this._source);
            }
            this._state = AssetStates.NOT_LOADED;
            this._loadError = null;
            audio.onLoad = function () {
                self._state = AssetStates.READY;
                self._media = audio;
                self.trigger("success", new wd.AssetSuccessEventArgs(audio));
            };
            audio.onError = function (e) {
                self._state = AssetStates.ERROR;
                self._loadError = e;
                self.trigger("error", new wd.AssetErrorEventArgs(e));
            };
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AudioAsset].
         *
         * @memberOf webDoodling.AudioAsset
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AudioAsset]";
        }

    }, wd.Asset);

    wd.AudioAsset = AudioAsset;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Styles Core
(function (wd) {
    "use strict";

    /**
     * Creates the `CanvasGradient` object which can be used for drawing
     * linear gradients.
     *
     * @function createLinearGradient(scene, x0, y0, x1, y1)
     * @param {webDoodling.Scene, string or HTMLCanvasElement} scene The scene.
     * @param {number} x0 The x value of first coordiante in `LinearGradient`.
     * @param {number} y0 The y value of first coordiante in `LinearGradient`.
     * @param {number} x1 The x value of second coordiante in `LinearGradient`.
     * @param {number} y1 The y value of second coordiante in `LinearGradient`.
     * @returns {CanvasGradient}
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    wd.createLinearGradient = function createLinearGradient(scene, x0, y0, x1, y1) {
        if (scene instanceof wd.Scene) {
            return scene._context.createLinearGradient(x0, y0, x1, y1);
        }
        else {
            if (typeof scene === "string") {
                scene = document.getElementById(scene);
            }
            if (scene instanceof HTMLCanvasElement === false) {
                throw new wd.Error("wd-invalid-argument");
            }
            return scene.getContext("2d").createLinearGradient(x0, y0, x1, y1);
        }
    };

    /**
     * Creates the `CanvasGradient` object which can be used for drawing
     * radial gradients.
     *
     * @function createRadialGradient(scene, x0, y0, r0, x1, y1, r1)
     * @param {webDoodling.Scene, string or HTMLCanvasElement} scene The Scene.
     * @param {number} x0 The x value of first coordiante in radial gradient.
     * @param {number} y0 The y value of first coordiante in radial gradient.
     * @param {number} r0 The radius of start circle.
     * @param {number} x1 The x value of second coordiante in radial gradient.
     * @param {number} y1 The y value of second coordiante in radial gradient.
     * @param {number} r1 The radius of end circle.
     * @returns {CanvasGradient}
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    wd.createRadialGradient = function createRadialGradient(scene, x0, y0, r0, x1, y1, r1) {
        if (scene instanceof wd.Scene) {
            return scene._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
        }
        else {
            if (typeof scene === "string") {
                scene = document.getElementById(scene);
            }
            if (scene instanceof HTMLCanvasElement === false) {
                throw new wd.Error("wd-invalid-argument");
            }
            return scene.getContext("2d").createRadialGradient(x0, y0, r0, x1, y1, r1);
        }
    };

    /**
     * Creates the `CanvasPattern` object which can be used for drawing
     * patterns.
     *
     * @function createPattern(scene, image, repetition)
     * @param {webDoodling.Scene, string or HTMLCanvasElement} scene The scene.
     * @param {Image or webDoodling.ImageAsset} image The image.
     * @param {repetition} repetition.
     * @returns {CanvasPattern or null}
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    wd.createPattern = function createPattern(scene, image, repetition) {

        if (image instanceof wd.ImageAsset) {
            if (image.media) {
                image = image.media;
            }
        }

        if (scene instanceof wd.Scene) {
            return scene._context.createPattern(image, repetition);
        }
        else {
            if (typeof scene === "string") {
                scene = document.getElementById(scene);
            }
            if (scene instanceof HTMLCanvasElement === false) {
                throw new wd.Error("wd-invalid-argument");
            }
            return scene.getContext("2d").createPattern(image, repetition);
        }
    };

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Styles
(function (wd) {
    "use strict";

    var Style;

    /**
     * Provides the base class for styles in `webDoodling.Style`
     * define how should `webDoodling.DisplayObject` be painted.
     *
     * @class webDoodling.Style
     * @example
     * var scene = webDoodling.Scene({
     *     children: [
     *         new webDoodling.Circle({
     *            id: 'circle',
     *            x: 50,
     *            y: 50,
     *            draggable: true,
     *            radius: 30,
     *               styles:[
     *                   new webDoodling.Fill('yellow'),
     *                   new webDoodling.Stroke('red', 20),
     *                   new webDoodling.Shadow(5, 5, 5, "rgba(0,0,0,0.5)")
     *               ]
     *         }),
     *         new webDoodling.Polygon({
     *            id: "traingle",
     *            side: 3,
     *            x: 70,
     *            y: 380,
     *            radius: 100,
     *            enablePointers: true,
     *            styles:[
     *               new webDoodling.Fill({
     *                   id: 'polyFill',
     *                   fill: 'black'
     *               }),
     *            ],
     *            pointerenter: function(e) {
     *                var fill = this.styles.get('polyFill');
     *                fill.fill = 'red';
     *                this.scene.update();
     *            },
     *            pointerout: function(e) {
     *                var fill = this.styles.get('polyFill');
     *                fill.fill = 'black';
     *                this.scene.update();
     *            }
     *        }),
     *     ]
     * });
     *
     * @public
     * @version 1.0
     **/
    Style = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Style`, always returns 'Style'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        type: wd.type("Style"),

        /**
         * Represents the `id` of the current object.
         *
         * @field {string} id
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        id: wd.attribute(),

        /**
         * Returns the `displayObject` of the `webDoodling.Style`.
         *
         * @readonly {webDoodling.displayObject} displayObject
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        displayObject: wd.readonly(),

        /**
         * Gets or sets the visibility of style.
         * If true, style is visible otherwise not.
         *
         * @field {boolean} visible
         * @default true
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        visible: wd.attribute(true),

        /**
         * Returns whether style is applied on hittest canvas or not, if true, style is applied on
         * hittest canvas otherwise not.
         *
         * @field {boolean} supportsHittest
         * @default true
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        supportsHittest: wd.readonly(true),

        /**
         * Gets the object of type `webDoodling.Tweenables` which contains a list of
         * tweenable members for `webDoodling.Style`.
         *
         * @readonly {webDoodling.Tweenables} tweenables
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        tweenables: wd.readonly(),

        /**
         * Initializes the new instance of `webDoodling.Style`.
         * This class is base class of all the styles and must
         * not be instantiated directly.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();

            this._tweenables = new wd.Tweenables(this);
            this.serializables("id", "visible");
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Style].
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Style]";
        }

    }, wd.Serializable);

    wd.Style = Style;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Styles
(function (wd) {
    "use strict";

    var StyleCollection;

    /**
     * Represents the collection of styles. Only an object of type `webDoodling.Style`
     * can be added to this collection.
     *
     * @class webDoodling.StyleCollection
     *
     * @extends webDoodling.ObservableMapList
     * @public
     * @version 1.0
     **/
    StyleCollection = wd.Class({

        /**
         * Returns the `type` of `webDoodling.StyleCollection`.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("StyleCollection"),

        /**
         * Gets the `displayObject` asssociated with style collection.
         *
         * @readonly {webDoodling.DisplayObject} displayObject
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        displayObject: wd.readonly(),

        /**
         * Initializes the new instance of `webDoodling.StyleCollection`.
         *
         * @constructor init(displayObject)
         * @param {webDoodling.DisplayObject} displayObject The display object.
         * @throws {Error} When displayObject is not supplied.
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        init: function init(displayObject) {
            if (!displayObject) {
                throw new wd.Error("wd-no-argument", "displayObject");
            }
            this.base();
            this._displayObject = displayObject;
            this._hitRegionStyles = [];
        },

        /**
         * Adds a `webDoodling.Stroke` style in the collection.
         *
         * @function addStroke(stroke, lineWidth, visible)
         * @param {string, webDoodling.Color, CanvasGradient or CanvasPattern} stroke The stroke
         * style(color, pattern or gradient).
         * @param {number} lineWidth Sets the `lineWidth` of the current object.
         * The line width of the style. This is an optional parameter, default is 1.
         * @param {boolean} visible Sets the `visible` on the current object.
         * The visibility of style.This is an optional parameter, default is `true`.
         * @returns {webDoodling.StyleCollection} The current instance, useful for chaining.
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        addStroke: function addStroke(lineWidth, stroke, visible) {
            var style = new wd.Stroke(lineWidth, stroke, visible);
            this.add(style);
            return this;
        },

        /**
         * Adds a `webDoodling.Fill` style in the collection.
         *
         * @function addFill(fill, visible)
         * @param {string, webDoodling.Color, CanvasGradient or CanvasPattern} fill.
         * @param {[boolean]} visible This is an optional paramter, default is `true`.
         *
         * @returns {webDoodling.StyleCollection} The current instance, useful for chaining.
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        addFill: function addFill(fill, fillRule, visible) {
            var style = new wd.Fill(fill, fillRule, visible);
            this.add(style);
            return this;
        },

        /**
         * Adds a `webDoodling.Shadow` style in the collection.
         *
         * @function addShadow(x, y, blur, color)
         * @param {number} x The x position of shadow.
         * @param {number} y The y position of shadow.
         * @param {number} blur The shadow blur.
         * @param {string, webDoodling.Color} color The shadow color.
         * @param {boolean} visible The visiblity of the  shadow.
         *
         * @returns {webDoodling.StyleCollection} The current instance, useful for chaining.
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        addShadow: function addShadow(x, y, blur, color, visible) {
            var style = new wd.Shadow(x, y, blur, color, visible);
            this.add(style);
            return this;
        },

        //Base class doc can be used here...
        add: function add() {
            this.base.apply(this, arguments);
            this._hitRegionStyles = _getHitRegionStyles(this._items);
            return this;
        },

        //Base class doc can be used here...
        remove: function remove() {
            this.base.apply(this, arguments);
            this._hitRegionStyles = _getHitRegionStyles(this._items);
            return this;
        },

        /**
         * Returns the array of `webDoodling.Style` which contains
         * enough styles to paint entire hit region for given display object.
         *
         * @function getHitRegionStyles()
         * @returns {Array[weboodling.Style]}
         * @remark Display object contains more than one layer of styles,
         * for example a rectangle may have a red stroke having 10px
         * lineWidth, a blue stroke having 5px lineWidth and finally
         * filled with yellow. On the other hand, hit regions are painted
         * with the single unique color associated with each display object.
         * Only a fill and a single stroke with the maximum line width is enough
         * to paint entire hit region.
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        getHitRegionStyles: function getHitRegionStyles() {
            return this._hitRegionStyles;
        },

        //Base class doc can be used here...
        onValidate: function onValidate(obj) {
            if (obj instanceof wd.Style !== true) {
                throw new wd.Error("wd-invalid-argument", obj);
            }
            obj._displayObject = this._displayObject;
            return null;
        },

        /**
         * Return the string representation of current instances.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.StyleCollection]
         *
         * @memberOf webDoodling.StyleCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.StyleCollection]";
        }

    }, wd.Collection);

    wd.StyleCollection = StyleCollection;

    //Calculates the returns the styles required for painting hit regions.
    //For more information see remark of getPaitRegionStyles() above.
    function _getHitRegionStyles(styles) {
        var i, iLen,
            style,
            retStyles = [],
            fill = null,
            stroke = null,
            lineWidth = 0;

        for (i = 0, iLen = styles.length; i < iLen; i += 1) {
            style = styles[i];

            if (style.visible === false) {
                continue;
            }

            if (style instanceof wd.Fill) {
                if (fill === null) {
                    fill = style;
                }
            }
            else if (style instanceof wd.Stroke) {
                if (style.lineWidth > lineWidth) {
                    stroke = style;
                    lineWidth = style.lineWidth;
                }
            }
        }
        if (stroke !== null) {
            retStyles.push(stroke);
        }
        if (fill !== null) {
            retStyles.push(fill);
        }
        return retStyles;
    }

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Stroke
(function (wd, undefined) {
    "use strict";

    var Stroke;

    /**
     * Represents a style which can stroke the display object with
     * specified lineWidth and given color, gradient or pattern.
     *
     * @class webDoodling.Stroke
     *
     * @example
     * var circle = webDoodling.Circle({
     *     x: 100,
     *     y: 100,
     *     radius: 40,
     *     styles:[
     *         new webDoodling.Fill('green'),
     *         new webDoodling.Stroke('blue',20)
     *     ]
     * });
     *
     * @extends webDoodling.Style
     *
     * @public
     * @version 1.0
     **/
    Stroke = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Stroke`, always returns 'Stroke'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        type: wd.type("Stroke"),

        /**
         * Gets or sets the lineWidth of the `webDoodling.Stroke`.
         *
         * @field {number} lineWidth
         * @default 1
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        lineWidth: wd.attribute(1),

        /**
         * Gets or sets the `lineCap` of the `webDoodling.Stroke`. Only following values are valid
         *
         * - butt: Draws a line with flat edge.
         * - round: Draws a line with rounded end cap.
         * - square: Draws a line with square ends.
         *
         * @field {string} lineCap
         * @default butt
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        lineCap: wd.attribute("butt"),

        /**
         * Gets or sets the `lineJoin` of the `webDoodling.Stroke`. The valid values are...
         * - bevel: Joins line with beveled corner
         * - round: Joins the line with rounded corner
         * - miter: Joins the line with sharp corner, this value is affected by `miterLimit` filled.
         *
         * @field {string} lineJoin
         * @default miter
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        lineJoin: wd.attribute("miter"),

        /**
         * Gets or sets the `miterLimit` of the `webDoodling.Stroke`.
         *
         * @field {number} miterLimit
         * @default 10
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        miterLimit: wd.attribute(10),

        /**
         * Gets or sets the stroke of the `webDoodling.Stroke`.
         *
         * @field {string} stroke
         * @default black
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        stroke: wd.attribute("rgba(0,0,0,0.5)"),

        /**
         * Gets or sets the lineDash pattern of the `webDoodling.Stroke`. If any value in the
         * array is NaN or negative it will prevent stroke from being drawn.
         * If the number of elements in array is odd pattern will be the
         * concatentation of two copies of array.
         *
         * @property {Array[number]} lineDash
         * @default null
         *
         * @example
         * var rect = webDoodling.Rectangle({
         *     styles: [
         *         webDoodling.Stroke({
         *             width: 1,
         *             stroke: 'red',
         *             lineDash: [5,5],
         *             lineDashOffset: 0
         *         })
         *     ]
         * });
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        lineDash: wd.attribute(null),

        /**
         * Gets or sets the dashOffset of the `webDoodling.Stroke`. This works
         * only when `lineDash` is set. The lineDashOffset can be useful to
         * change or control the phase of the dash pattern. Such as to achieve
         * animated 'marching ants` effect.
         *
         * @attribute {number}
         * @default 0
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        lineDashOffset: wd.attribute(0),

        /**
         * Initializes the new instance of the `webDoodling.Stroke` with default or
         * specified parameters.
         *
         * @constructor init([o])
         * @param {[object]} o The initialization object in JSON format.
         *
         * @example
         *      var style = new webDoodling.Stroke({
         *       id: "obj1",
         *       lineWidth: 2,
         *       stroke: "red",
         *       visible: true
         *      })
         *
         * var style2 = new webDoodling.Stroke();
         *
         * @constructor init(stroke[lineWidth, visible])
         * @param {string, webDoodling.Color, CanvasGradient or CanvasPattern} stroke Sets the `stroke` of the current object.
         * @param {number} lineWidth Sets the `lineWidth` of the current object. This is an optional paramter, default is 1.
         * @param {boolean} visible Sets the `visible` of the current object. This is an optional paramter, default is `true`.
         *
         * @example
         * var style = new webDoodling.Fill("red", false);
         * var style = new webDoodling.Fill("red");
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                argLen = arguments.length;

            this.base();
            if (argLen === 1) { //stroke or plain object
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                }
                else {
                    if (wd.is.number(arg1)) {
                        this.lineWidth = arg1;
                    }
                    else {
                        this.stroke = arg1;
                    }
                }
            }
            else {
                if (arg1 !== undefined) this.lineWidth = arg1;
                if (arg2 !== undefined) this.stroke = arg2;
                if (arg3 !== undefined) this.visible = arg3;
            }

            this._tweenables.register("number", "lineWidth", "miterLimit");
            this._tweenables.register("color", "stroke");
            this.serializables("lineWidth", "miterLimit", "stroke",
                              "lineCap", "lineJoin", "lineDash", "lineDashOffset");
        },

        /**
         * Applies the style on specified context. This function is invoked by the
         * `webDoodling.StyleableDisplayObject` or derived classes to apply the styles
         * of `webDoodling.Stroke` to given context.
         *
         * @function onApplyStyle(ctx)
         * @param  {2DContext} ctx The 2DContext on which styles needs to be applied.
         * @param  {webDoodling.displayObject} displayObject The display object on which styles needs to be applied.
         * @param  {[string]} color The color which is passed when style is to be applied on hitTest canvas.
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        onApplyStyle: function onApplyStyle(ctx, displayObject, color) {
            var lineDash = this.lineDash,
                lineCap = this.lineCap,
                lineJoin = this.lineJoin,
                miterLimit = this.miterLimit;
            if (lineDash !== null) {
                ctx.setLineDash(lineDash);
                ctx.lineDashOffset = this.lineDashOffset;
            }
            else {
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
            }

            ctx.lineCap = lineCap;
            ctx.lineJoin = lineJoin;
            ctx.miterLimit = miterLimit;
            ctx.lineWidth = this.lineWidth;
            ctx.strokeStyle = color || this.stroke;

            ctx.stroke();
        },

        /**
         * Applies the text style on specified context. This function is invoked by the
         * `webDoodling.StyleableDisplayObject` or derived classes to apply the styles
         * of `webDoodling.Stroke` to given context.
         *
         * @function onApplyText(ctx)
         * @param  {2DContext} ctx The 2DContext on which styles needs to be applied.
         * @param  {webDoodling.displayObject} displayObject The display object on which styles needs to be applied.
         * @param  {[string]} color The color which is passed when style is to be applied on hitTest canvas
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        onApplyTextStyle: function onApplyTextStyle(ctx, text, x, y, displayObject, color) {

            var lineDash = this.lineDash,
                lineCap = this.lineCap,
                lineJoin = this.lineJoin,
                miterLimit = this.miterLimit;

            if (lineDash !== null) {
                ctx.setLineDash(lineDash);
                ctx.lineDashOffset = this.lineDashOffset;
            }
            else {
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
            }

            ctx.lineCap = lineCap;
            ctx.lineJoin = lineJoin;
            ctx.miterLimit = miterLimit;
            ctx.lineWidth = this.lineWidth;
            ctx.strokeStyle = color || this.stroke;
            ctx.strokeText(text, x, y);
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object.webDoodling.Stroke].
         *
         * @memberOf webDoodling.Stroke
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Stroke]";
        }

    }, wd.Style);

    wd.Stroke = Stroke;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Fill
(function (wd, undefined) {
    "use strict";

    var Fill;

    /**
     * Represents a style which can fill the display object with color, gradient or pattern.
     *
     * @class webDoodling.Fill
     *
     * @example
     * var circle = webDoodling.Circle({
     *     x: 100,
     *     y: 100,
     *     radius: 40,
     *     styles:[
     *         new webDoodling.Fill('green')
     *     ]
     * });
     *
     * @extends webDoodling.Style
     * @memberOf webDoodling.Fill
     * @public
     * @version 1.0
     **/
    Fill = wd.Class({

        /**
         * Returns the type of `webDoodling.Fill`, always returns Fill.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Fill
         * @public
         * @version 1.0
         **/
        type: wd.type("Fill"),

        /**
         * Gets or sets the fill of the `webDoodling.Fill`.
         *
         * @field {string} fill
         * @default 'rgba(255,255,255,0.5)'
         *
         * @memberOf webDoodling.Fill
         * @public
         * @version 1.0
         **/
        fill: wd.attribute("rgba(255,0,0,0.5)"),

        /**
         * Gets or sets the fillRule of the `webDoodling.Fill`.
         * Values could be nonzero or evenodd.
         *
         * @field {string} fill
         * @default 'nonzero'
         *
         * @memberOf webDoodling.Fill
         * @public
         * @version 1.0
         **/
        fillRule: wd.attribute("nonzero"),

        /**
         * Initializes the new instance of the `webDoodling.Fill` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {[object]} o The initialization object in JSON format.
         *
         * @example
         * var style = new webDoodling.Fill({
         *     id: "obj1",
         *     fill: "red",
         *     visible: true
         * });
         *
         * var style2 = new webDoodling.Fill();
         * style2.fill = "red";
         *
         * @constructor init(fill [visible])
         * @param {string} fill The css color in string.
         * @param {[boolean]} visible This is an optional paramter, default is `true`.
         *
         * @example
         * var style = new webDoodling.Fill("red", false);
         * var style = new webDoodling.Fill("red");
         *
         * @memberOf webDoodling.Fill
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                argLen = arguments.length;
            this.base();
            if (argLen === 1 && wd.is.plainObject(arg1)) {
                this.deserialize(arg1);
            }
            else {
                if (arg1 !== undefined) this.fill = arg1;
                if (arg2 !== undefined) this.fillRule = arg2;
                if (arg3 !== undefined) this.visible = arg3;
            }
            this._tweenables.register("color", "fill");
            this.serializables("fill", "fillRule");
        },

        /**
         * Applies the style on specified context. This function is invoked by the
         * `webDoodling.StyleableDisplayObject` or derived classes to apply the styles
         * of `webDoodling.Fill` to given context.
         *
         * @function onApplyStyle(ctx)
         * @param  {2DContext} ctx The 2DContext on which styles needs to be applied.
         * @param  {webDoodling.displayObject} displayObject The display object on which styles needs to be applied.
         * @param  {[string]} hitTestColor The color which is passed when style is to be applied on hitTest canvas.
         *
         * @memberOf webDoodling.Fill
         * @public
         * @version 1.0
         **/
        onApplyStyle: function onApplyStyle(ctx, displayObject, hitTestColor) {
            ctx.fillStyle = hitTestColor || this.fill;
            ctx.fill(this.fillRule);
        },

        /**
         * Applies the text style on specified context. This function is invoked by the
         * `webDoodling.StyleableDisplayObject` or derived classes to apply the styles
         * of `webDoodling.Fill` to given context.
         *
         * @function onApplyText(ctx)
         * @param  {2DContext} ctx The 2DContext on which styles needs to be applied.
         * @param  {webDoodling.displayObject} displayObject The display object on which styles needs to be applied.
         * @param  {[string]} hitTestColor The color which is passed when style is to be applied on hitTest canvas.
         *
         * @memberOf webDoodling.Fill
         * @public
         * @version 1.0
         **/
        onApplyTextStyle: function onApplyTextStyle(ctx, text, x, y, displayObject, hitTestColor) {
            ctx.fillStyle = hitTestColor || this.fill;
            ctx.fillText(text, x, y);
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Fill].
         *
         * @memberOf webDoodling.Fill
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Fill]";
        }

    }, wd.Style);

    wd.Fill = Fill;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Shadow
(function (wd, undefined) {
    "use strict";

    var Shadow;

    /**
     * Represents a style which can add a shadow to display objects.
     *
     * @class webDoodling.Shadow
     *
     * @example
     * var rectangle = webDoodling.Rectangle({
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 100,
     *     styles:[
     *      new webDoodling.Fill('green'),
     *      new webDoodling.Shadow(5, 5, 5, 'rgba(0,0,0,0.5)'),
     *     ]
     * });
     *
     * @extends webDoodling.Style
     * @public
     * @version 1.0
     **/
    Shadow = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Shadow`, always returns 'Shadow'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        type: wd.type("Shadow"),

        /**
         * Gets or sets the x coordinate of the `webDoodling.shadow`.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * Gets or sets the y coordinate of the `webDoodling.shadow`.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Gets or sets the blur value of the `webDoodling.shadow`.
         *
         * @field {number} blur
         * @default 5
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        blur: wd.attribute(5),

        /**
         * Gets or sets the color of the `webDoodling.shadow`.
         *
         * @field {string} color
         * @default 'black'
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        color: wd.attribute("black"),

        /**
         * Initializes the new instance of the `webDoodling.Shadow` with default or
         * specified parameters.
         *
         * @constructor init([o])
         * @param {[object]} o The initialization object in JSON format.
         *
         * @example
         * var style = new webDoodling.Shadow({
         *      id: "obj1",
         *      x: 5,
         *      y: 5,
         *      blur: 5,
         *      color: "rgba(0,0,0,0.5)",
         *      visible: true
         * });
         *
         * var style2 = new webDoodling.Shadow(5, 5, 5, "rgba(0,0,0,0.5)");
         *
         * @constructor init(x, y, blur, color, boolean)
         * @param {number} x Sets the `x ` of the current object, this is an optional parameter. Default is 0.
         * @param {number} y Sets the `y` of the current object, this is an optional parameter. Default is 0.
         * @param {number} blur Sets the `blur` of the current object, this is an optional parameter. Default is 5
         * @param {color} color Sets the `color` of the current object, this is an optional parameter. Default is 'black'.
         * @param {boolean} visible Sets the `visible` value of the current object. This is an optional parameter, default is `true`.
         *
         * @example
         * var style = new webDoodling.Fill("red", false);
         * var style = new webDoodling.Fill("red");
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                arg4 = arguments[3],
                arg5 = arguments[4],
                argLen = arguments.length;

            this.base();
            this._supportsHittest = false;

            if (argLen === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                    return;
                }
            }
            if (arg1 !== undefined) this.x = arg1;
            if (arg2 !== undefined) this.y = arg2;
            if (arg3 !== undefined) this.blur = arg3;
            if (arg4 !== undefined) this.color = arg4;
            if (arg5 !== undefined) this.visible = arg5;

            this._tweenables.register("number", "x", "y", "blur");
            this._tweenables.register("color", "color");
            this.serializables("x", "y", "blur", "color");
        },

        /**
         * Applies the style on specified context. This function is invoked by the
         * `webDoodling.StyleableDisplayObject` or derived classes to apply the styles
         * of `webDoodling.Shadow` to given context.
         *
         * @function onApplyStyle(ctx)
         * @param  {2DContext} ctx The 2DContext on which styles needs to be applied.
         * @param  {webDoodling.displayObject} displayObject The display object on which styles needs to be applied.
         * @param  {[string]} hitTestColor The color which is passed when style is to be applied on hitTest canvas.
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        onApplyStyle: function onApplyStyle(ctx) {
            ctx.shadowOffsetX = this.x;
            ctx.shadowOffsetY = this.y;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = this.blur;
        },

        /**
         * Applies the text style on specified context. This function is invoked by the
         * `webDoodling.StyleableDisplayObject` or derived classes to apply the styles
         * of `webDoodling.Shadow` to given context.
         *
         * @function onApplyText(ctx)
         * @param  {2DContext} ctx The 2DContext on which styles needs to be applied.
         * @param  {webDoodling.displayObject} displayObject The display object on which styles needs to be applied.
         * @param  {[string]} color The color which is passed when style is to be applied on hitTest canvas.
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        onApplyTextStyle: function onApplyTextStyle(ctx) {
            ctx.shadowOffsetX = this.x;
            ctx.shadowOffsetY = this.y;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = this.blur;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object.webDoodling.Shadow].
         *
         * @memberOf webDoodling.Shadow
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Shadow]";
        }

    }, wd.Style);

    wd.Shadow = Shadow;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The DisplayObject
(function (wd, undefined) {
    "use strict";

    var is = wd.is,
        EMPTY_FN = function () {},
        DisplayObject;

    /**
     * Represents the `webDoodling.DisplayObject`, a base class for all the objects
     * which need to be displayed on the scene. This class is not meant to be instantiated
     * directly. Please use display objects like `webDoodling.Rectangle`, `webDoodling.Circle`
     * or any other derived classes to draw an object on `webDoodling.Scene`.
     *
     * @class webDoodling.DisplayObject
     *
     * @memberOf webDoodling.DisplayObject
     * @public
     * @version 1.0
     **/
    DisplayObject = wd.Class({

        /**
         * Returns the `type` of `webDoodling.DisplayObject`, always returns 'DisplayObject'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        type: wd.type("DisplayObject"),

        /**
         * Gets and sets the `id` of the `webDoodling.DisplayObject`.
         * This property can only be set once.
         *
         * @field {string} id
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        id: wd.property({
            get: function () {
                return this._id;
            },
            set: function (v) {
                if (is.nullOrUndef(v)) {
                    return;
                }
                if (is.nullOrUndef(this._id) === true) {
                    this._id = v;
                }
                else {
                    throw new wd.Error("wd-display-object-id-immutable");
                }
            }
        }),

        /**
         * Gets or sets the `x` position of `webDoodling.DisplayObject`.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * Gets or sets the `y` position of `webDoodling.DisplayObject`.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Gets or sets the `opacity`(transparency) of the `webDoodling.DisplayObject`.
         * Value range from 0.0 (transparent) to 1.0 (opaque).
         * If set to zero DisplayObject is not visible.
         *
         * @field {number} opacity
         * @default 1.0
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        opacity: wd.attribute(1.0),

        /**
         * Gets or sets the `compositeOperation` for the `webDoodling.DisplayObject`.
         * CompositeOperation sets how DisplayObjects are drawn on the previous
         * display objects within current scene.
         * Valid values are...
         *
         *   - source-atop
         *   - source-in
         *   - source-out
         *   - source-over
         *   - destination-atop
         *   - destination-in
         *   - destination-out
         *   - destination-over
         *   - lighter
         *   - copy
         *   - xor
         *
         * @field {string} compositeOperation
         * @default 'source-over'
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        compositeOperation: wd.attribute("source-over"),

        /**
         * If set to `true` creates the clipping path which can be used as mask.
         *
         * @field {boolean} clip
         * @default `false`
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        clip: wd.attribute(false),

        /**
         * Represents the `skewX` attribute of the `webDoodling.DisplayObject`.
         *
         * @field {number} skewX
         * @default 0
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        skewX: wd.attribute(0),

        /**
         * Represents the `skewY` attribute of the `webDoodling.DisplayObject`.
         *
         * @field {number} skewY
         * @default 0
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        skewY: wd.attribute(0),

        /**
         * Gets or sets the `scaleX` value of the `DisplayObject`.
         *
         * @field {number} scaleX
         * @default 1
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        scaleX: wd.attribute(1),

        /**
         * Gets or sets the `scaleY` value of the `DisplayObject`.
         *
         * @field {number} scaleY
         * @default 1
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        scaleY: wd.attribute(1),

        /**
         * Gets or sets the `originX` value of `webDoodling.DisplayObject`. When applying the
         * transformations like rotation, scale, skew etc... the origin coordinates are
         * taken into account. If it is set to 'auto', the calulated vaule will be display object's
         * width / 2 (if width is supported in display object) otherwise 0.
         *
         * @field {number, 'auto'} originX
         * @default 'auto'
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        originX: wd.attribute("auto"),

        /**
         * Gets or sets the `originY` value of `webDoodling.DisplayObject`. When applying the
         * transformations like rotation, scale, skew etc... the origin coordinates are
         * taken into account. If it is set to 'auto', the calulated vaule will be display object's
         * height / 2 (if height is supported in display object) otherwise 0.
         *
         * @field {number, 'auto'} originY
         * @default 'auto'
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        originY: wd.attribute("auto"),

        /**
         * Gets or sets the `rotation` value of `webDoodling.DisplayObject`.
         *
         * @field {number} rotation
         * @default 0
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        rotation: wd.attribute(0),

        /**
         * Gets or sets the `visible` value of `webDoodling.DisplayObject`.
         *
         * @field {boolean} visible
         * @default true
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        visible: wd.attribute(true),

        /**
         * Returns the `webDoodling.Scene`.
         *
         * @readonly {webDoodling.Scene} scene
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        scene: wd.readonly(),

        /**
         * Returns the parent object. If the object is not a child of any other displayObject,
         * returns `null`.
         *
         * @readonly {webDoodling.parent} parent
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        parent: wd.readonly(null),

        /**
         * Returns an array parents object. If the object is not a child of any other displayObject,
         * returns an empty array.
         *
         * @readonly {webDoodling.parent} parent
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        parents: wd.readonly({
            get: function () {
                return this._parents || [];
            }
        }),

        /**
         * Returns the tweenables for `webDoodling.DisplayObject`. Tweenables are keys which
         * are used for animating displayObject.
         *
         * @readonly {webDoodling.Tweenable} tweenables
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        tweenables: wd.readonly(),

        /**
         * Represents the callback function which is invoked when current instance
         * is attached to a scene.
         *
         * @field {function, boolean} onSceneAttached
         * @default false It means no callback is attached.
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        onSceneAttached: false,

        /**
         * Gets the `currentTransform` considering various
         * properties like scale, rotation and position. Doesn't
         * consider parents transformation, use `currentAbsTransform`
         * which takes parents into account.
         *
         * @readonly {webDoodling.TransformationMatrix} currentTransform
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        currentTransform: wd.readonly({
            get: function () {
                var matrix = new wd.TransformationMatrix(),
                    rotation = this.rotation,
                    origin = this.absOrigin,
                    x = this.x + origin.x,
                    y = this.y + origin.y;

                matrix.translate(x, y);
                matrix.scale(this.scaleX, this.scaleY);
                matrix.rotate(rotation * (Math.PI / 180));
                matrix.skewX(this.skewX * (Math.PI / 180));
                matrix.skewY(this.skewY * (Math.PI / 180));
                return matrix;
            }
        }),

        /**
         * Gets the `currentAbsTransform` considering various
         * properties like scale, rotation and position. Takes
         * parents into account.
         *
         * @readonly {webDoodling.TransformationMatrix} currentAbsTransform
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        currentAbsTransform: wd.property({
            get: function () {
                var matrix = new wd.TransformationMatrix(),
                    hierarchy = [],
                    parent = this.parent,
                    i, iLen;

                hierarchy.push(this);
                while (parent) {
                    hierarchy.unshift(parent);
                    parent = parent.parent;
                }

                for (i = 0, iLen = hierarchy.length; i < iLen; i += 1) {
                    matrix.multiply(hierarchy[i].currentTransform);
                }
                return matrix;
            }
        }),

        /**
         * Gets or sets an object which contains the absolute x and y coordinates
         * of the current display object.
         *
         * @field {Object} absPosition
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        absPosition: wd.property({
            get: function () {
                var matrix = this.currentAbsTransform;
                return {
                    x: matrix.e,
                    y: matrix.f
                };
            },
            set: function (v) {
                var rotation = this.rotation,
                    scaleX = this.scaleX,
                    scaleY = this.scaleY,
                    matrix;

                this.rotation = 0;
                this.scaleX = 1;
                this.scaleY = 1;
                matrix = this.currentAbsTransform;
                matrix.inverse();
                matrix.translate(v.x, v.y);
                this.x += matrix.e;
                this.y += matrix.f;
                this.rotation = rotation;
                this.scaleX = scaleX;
                this.scaleY = scaleY;
            }
        }),

        /**
         * Provides the absolute origin value.
         *
         * @readonly {number} absOrigin
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        absOrigin: wd.readonly({
            get: function () {
                var originX = this.originX, originY = this.originY;
                if (this._isRectObject) {
                    if (originX === "auto") {
                        originX = this.width / 2;
                    }
                    if (originY === "auto") {
                        originY = this.height / 2;
                    }
                }
                else {
                    originX = (originX === "auto") ? 0 : originX;
                    originY = (originY === "auto") ? 0 : originY;
                }
                return {
                    x: originX,
                    y: originY
                };
            }
        }),

        /**
         * Returns the absolute path of current object.
         *
         * @readonly {number} absOrigin
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        absolutePath: wd.readonly({
            get: function () {
                var path = [],
                    parent = this.parent;

                if (this.id === undefined) {
                    throw new wd.Error("wd-id-required");
                }

                path.push(this.id);

                while(parent) {
                    if (parent.id === undefined) {
                        throw new wd.Error("wd-parent-id-not-found");
                    }
                    path.unshift(parent.id);
                    parent = this.parent;
                }
                return path.join(".");
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.displayObject`.
         *
         * @constructor init(o)
         * @param {type} o The initialization object.
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            var tweenables = new wd.Tweenables(this);

            this.base();

            // Tweenables
            this._tweenables = tweenables;
            tweenables
                .register("number", "x", "y", "opacity", "skewX", "skewY", "scaleX",
                          "scaleY", "originX", "originY", "rotation")
                .register("path", "path");

            // Serializable
            this.serializables("id", "x", "y", "clip", "opacity", "skewX", "skewY", "scaleX",
                          "scaleY", "originX", "originY", "rotation", "visible");

            if (o) this.deserialize(o);

            this._isRectObject = ("width" in this && "height" in this);
        },

        getTranslatePoint: function getTranslatePoint() {
            var matrix = this.currentAbsTransform,
                size;
            //size = matrix.rotateFromVector(this.x, this.y);
            //matrix.scale(this.scaleX, this.scaleY);
            size = matrix.transformPoint(this.x, this.y);
            return {x: size.x, y: size.y};
        },

        /**
         * Rotates current display-object towards the specified point.
         *
         * @function rotateTo(x, y)
         * @param {Object} x The x value of the point towards which this object needs to be rotated.
         * @param {Object} y The y value of the point towards which this object needs to be rotated.
         * @returns {Object} The current object, which makes this function chainable.
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        rotateTo: function rotateTo(x, y) {
            var angle = Math.atan2(y - this.y, x - this.x);
            if (!isNaN(angle)) {
                this.rotation = angle * 180 / Math.PI;
            }
        },

        /**
         * Animates the current-display object based on specified parameters.
         *
         * @function animate(o)
         * @param {Object} o The animation options.
         * @returns {Object} The current object, useful for chaining.
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        animate: function animate() {
            var tween = new wd.Tween(),
                callback,
                args,
                animator;

            tween._scene = this._scene;
            args = Array.prototype.slice.call(arguments);
            if (args.length === 1 && is.plainObject(args[0])) {
                args[0].object = this;
            }
            else {
                args.unshift(this);
            }
            callback = args[args.length - 1];
            if (wd.is.func(callback)) {
                args.pop();
            }
            tween._load.apply(tween, args);
            animator = new wd.Animator(this._scene, tween, false, this);
            if (wd.is.func(callback)) {
                animator.onComplete = callback;
            }
            animator.play();
            return animator;
        },

         /**
         * A callback which is invoked everytime by  DisplayObject needs to be drawn on scene.
         *
         * @function onUpdate(context, hitContext)
         * @param  {2DCntext} context    [description]
         * @param  {2DCntext} hitContext [description]
         *
         * @memberOf webDoodling.DisplayObject
         * @protected
         * @version 1.0
         **/
        onUpdate: function onUpdate(context, hitContext) {

            //Draw on scene
            context.save();

            if (this.onBeforeUpdate) {
                this.onBeforeUpdate(context, hitContext);
            }

            var origin = this.absOrigin,
                originX = origin.x,
                originY = origin.y,
                clip = this.clip,
                x, y;

            x = -originX;
            y = -originY;

            this._setContext(context, false, originX, originY);
            this.onDraw(context, x, y);
            context.restore();
            if (clip) {
                context.clip();
            }

            //Draw on hit region
            if (hitContext && this._pointers) {
                hitContext.save();
                this._setContext(hitContext, true, originX, originY);
                this.onDrawHitRegion(hitContext, x, y, this._hex);
                hitContext.restore();
                if (clip) {
                    hitContext.clip();
                }
            }
        },

        onDrawHitRegion: EMPTY_FN,

        /**
         * Returns a cached copy of the current displayObject so that
         * it can be used as source for `webdoodling.Image` displayObject.
         *
         * @function toImageSource(width, height, offsetX, offsetY)
         * @param  {number} width  The image width.
         * @param  {number} height The image height.
         * @returns {HTMLCanvasElement} The in-memory canvas element, which is already
         * painted with the current displayObject.
         *
         * @public
         * @version 1.0
         **/
        toImageSource: function toImageSource(width, height, offsetX, offsetY) {
            return new wd.ImageSource(this, width, height, offsetX, offsetY);
        },

        getAbsBoundingBox: function () {
            var box = this.getBoundingBox(),
                absBox = { },
                matrix, p1, p2, p3, p4,
                minP, maxP,
                origin = this.absOrigin,
                originPoint;

            matrix = this.currentAbsTransform;

            absBox.width = box.width;
            absBox.height = box.height;

            // Find four points of the box and transform them.
            p1              = matrix.transformPoint(box.x - this.x, box.y - this.y);
            p2              = matrix.transformPoint(box.x + box.width - this.x, box.y - this.y);
            p3              = matrix.transformPoint(box.x + box.width - this.x, box.y + box.height - this.y);
            p4              = matrix.transformPoint(box.x - this.x, box.y + box.height - this.y);

            // Find min and max points
            minP = {
                x: Math.min(p1.x, p2.x, p3.x, p4.x),
                y: Math.min(p1.y, p2.y, p3.y, p4.y)
            };

            maxP = {
                x: Math.max(p1.x, p2.x, p3.x, p4.x),
                y: Math.max(p1.y, p2.y, p3.y, p4.y)
            };


            // Get tranformed origin.
            originPoint     = matrix.transformPoint(origin.x, origin.y);

            // Calculate absolute box.
            absBox.x        = minP.x - (originPoint.x - p1.x);
            absBox.y        = minP.y- (originPoint.y - p1.y);
            absBox.width    = maxP.x - minP.x;
            absBox.height   = maxP.y - minP.y;

            // console.log(p, originPoint, origin, p.x - (originPoint.x - p.x));
            // console.log(box, absBox, matrix._matrix, origin, this.x, this.y);

            return absBox;
        },

         /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.DisplayObjectCollection].
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.DisplayObject]";
        },

        //Private Area

        _setContext: function (ctx, shadowMode, originX, originY) {
            var opacity = this.opacity,
                compositeOperation = this.compositeOperation,
                rotation = this.rotation,
                x = this.x + originX,
                y = this.y + originY,
                skewX = this.skewX,
                skewY = this.skewY,
                scaleX = this.scaleX,
                scaleY = this.scaleY,
                angle;

            if (!shadowMode) {
                ctx.globalAlpha = opacity;
                // x += 0.5;
                // y += 0.5;
            }

            ctx.translate(x, y);
            ctx.scale(scaleX, scaleY);
            ctx.globalCompositeOperation = compositeOperation;

            if (rotation !== 0) {
                angle = rotation * Math.PI / 180;
                ctx.rotate(angle);
            }

            if (skewX !== 0) {
                angle = skewX * Math.PI / 180;
                ctx.transform(1, 0, Math.tan(angle), 1, 0, 0);
            }

            if (skewY !== 0) {
                angle = skewY * Math.PI / 180;
                ctx.transform(1, Math.tan(angle), 0, 1, 0, 0);
            }
        },

        // Resets the parents
        resetParents: function() {
            var parents = [],
                parent;

            parent = this._parent;

            while(parent) {
                parents.push(parent);
                parent = parent.parent;
            }
            this._parents = parents;
        }

    }, wd.Serializable);

    wd.DisplayObject = DisplayObject;

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Display Object Evetns
(function (wd) {
    "use strict";

    wd.DisplayObject.attach({

        /***** POINTER EVENTS *****/

        /**
         * Enables `pointer` events for the displayObject. Handling mouse and
         * touch events for the scene is a costly affair, and hence these events are
         * not available by default.
         *
         * @field {boolean} pointers
         * @default false
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointers: wd.property({
            value: false,
            get: function() {
                return this._pointers;
            },
            set: function(v) {
                if (v === this._pointers) {
                    return;
                }

                this._pointers = v;
                if (this._scene) {
                    if (v) {
                        this._scene._pointersCount += 1;
                    }
                    else {
                        this._scene._pointersCount -= 1;
                    }
                }
            }
        }),

        /**
         * Represents an event which is triggered when an object is clicked or tapped.
         *
         * @event tap(e)
         *  +-----------+------------------------------------------+
         * | name      | description                               |
         * +===========+===========================================+
         * | eventName | The name of the event always `tap`.       |
         * +-----------+-------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        tap: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer is entered
         * on the current object's region.
         *
         * @event pointerover(e)
         * @param {Object} e An object with following memeber is passed to the handler function.
         * - eventName {string} The name of an event.
         * - x {number} X position of pointer relative to the current scene.
         * - y {number} Y position of pointer relative to the current scene.
         * - clientX {number} The clientX.
         * - clientY {number} The clientY.
         * - pageX {number} The pageX.
         * - pageY {number} The pageY.
         * - event {Object} An actual event object.
         * - touch {Object} The touch object if available.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerover`. |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointerover: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer is entered
         * on the current object's region.
         *
         * @event pointerenter(e)
         * @param {Object} e An object with following memeber is passed to the handler function.
         * - eventName {string} The name of an event.
         * - x {number} X position of pointer relative to the current scene.
         * - y {number} Y position of pointer relative to the current scene.
         * - clientX {number} The clientX.
         * - clientY {number} The clientY.
         * - pageX {number} The pageX.
         * - pageY {number} The pageY.
         * - event {Object} An actual event object.
         * - touch {Object} The touch object if available.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerenter`. |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointerenter: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer is moved
         * over the current object's region.
         *
         * @event pointermove(e)
         * @param {Object} e An object with following memeber is passed to the handler function.
         *      - eventName {string} The name of an event.
         *      - x {number} X position of mouse relative to the scene.
         *      - y {number} Y position of mouse relative to the scene.
         *      - clientX {number} The clientX.
         *      - clientY {number} The clientY.
         *      - pageX {number} The pageX.
         *      - pageY {number} The pageY.
         *      - event {Object} An actual event object.
         *      - touch {Object} The touch object if available.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointermove`.  |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointermove: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer leaves
         * the current object's region.
         *
         * @event pointerleave(e)
         * @param {Object} e An object with following member is passed to the handler function.
         *     - eventName {string} The name of an event.
         *     - x {number} X position of mouse relative to the scene.
         *     - y {number} Y position of mouse relative to the scene.
         *     - event {Object} An actual event object.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerleave`  |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointerleave: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer is out
         * of the current object's region.
         *
         * @event pointerout(e)
         * @param {Object} e An object with following member is passed to the handler function.
         *     - eventName {string} The name of an event.
         *     - x {number} X position of mouse relative to the scene.
         *     - y {number} Y position of mouse relative to the scene.
         *     - event {Object} An actual event object.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerout`  |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointerout: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer is down
         * in the current object's region.
         *
         * @event pointerdown(e)
         * @param {Object} e An object with following member is passed to the handler function.
         *     - eventName {string} The name of an event.
         *     - x {number} X position of mouse relative to the scene.
         *     - y {number} Y position of mouse relative to the scene.
         *     - event {Object} An actual event object.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerdown`   |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointerdown: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer is up
         * of the current object's region.
         *
         * @event pointerup(e)
         * @param {Object} e An object with following member is passed to the handler function.
         *     - eventName {string} The name of an event.
         *     - x {number} X position of mouse relative to the scene.
         *     - y {number} Y position of mouse relative to the scene.
         *     - event {Object} An actual event object.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointerup`     |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointerup: wd.event(),

        /**
         * Represents an event which gets triggered when the pointer is cancel
         * of the current object's region.
         *
         * @event pointercancel(e)
         * @param {Object} e An object with following member is passed to the handler function.
         *     - eventName {string} The name of an event.
         *     - x {number} X position of mouse relative to the scene.
         *     - y {number} Y position of mouse relative to the scene.
         *     - event {Object} An actual event object.
         *
         * +------------+---------------------------------------------+
         * | name      | description                                  |
         * +===========+==============================================+
         * | eventName | The name of the event always `pointercancel` |
         * +-----------+----------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        pointercancel: wd.event(),

        unbind: function unbind() {
            this
                .off("tap")
                .off("pointerenter")
                .off("pointermove")
                .off("pointerleave")
                .off("pointerdown")
                .off("pointerup")
                .off("pointercancel");
        }

    });


})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//Display Object Draggable
(function (wd) {
    "use strict";

    //Extends `webDoodling.DisplayObject` to make it draggable.
    wd.DisplayObject.attach({

        /**
         * Gets or sets the `draggable` property of display object.
         *
         * @field {boolean} draggable
         * @default false
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        draggable: wd.property({
            value: false,
            get: function () {
                return this._draggable;
            },
            set: function (v) {
                if (v === this._draggable) {
                    return;
                }
                this._setDraggable(v);
            }
        }),

        /**
         * Let you know whether an object is currently being dragged or not. Return
         * `true` if it is dragging othewise `false`.
         *
         * @readonly {boolean} isDragging
         * @default false
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        isDragging: wd.readonly(false),

        //Events

        /**
         * Represents the `dragstart` event, which is invoked when
         * current object starts dragging.
         *
         * @event dragstart(e)
         * @param {object} e An event argument which is passed to the event handler, has following members.
         *
         * +-----------+-------------------------------------------+
         * | name      | description                               |
         * +===========+===========================================+
         * | eventName | The name of the event always `dragStart`. |
         * +-----------+-------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        dragstart: wd.event(),

        /**
         * Represents the `drag` event, which is invoked
         * when the current object is being dragged.
         * This event will fire with every move of `webDoodling.DispalyObject` after
         * it starts dragging.
         *
         * @event drag(e)
         * @param {object} e An event argument which is passed to the event handler, has following members.
         * +-----------+-------------------------------------------+
         * | name      | description                               |
         * +===========+===========================================+
         * | eventName | The name of the event always `drag`.      |
         * +-----------+-------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        drag: wd.event(),

        /**
         * Represents the `dragstop` event, which is invoked when the
         * current instance of display object stops dragging.
         *
         * @event dragstop(e)
         * @param {object} e An event argument which is passed to the event handler, has following members.
         * +-----------+-------------------------------------------+
         * | name      | description                               |
         * +===========+===========================================+
         * | eventName | The name of the event always `dragStop`.  |
         * +-----------+-------------------------------------------+
         *
         * @memberOf webDoodling.DisplayObject
         * @public
         * @version 1.0
         **/
        dragstop: wd.event(),

        //Private

        //Handles dragging
        _setDraggable: function (draggable) {
            var positions = {},
                self = this,
                pointerId;

            function pointerdown(e) {
                var absPos = self.absPosition;
                positions[e.pointerId] = {
                    x: e.x - absPos.x,
                    y: e.y - absPos.y
                };
                pointerId = e.pointerId;
                self._isDragging = true;
                self.scene.pointermove(self._dragPointerMove);
                self.scene.pointerup(self._dragPointerUp);
                self.trigger("dragstart", new wd.EventArgs("dragstart"));
            }

            this._dragPointerDown = this._dragPointerDown || pointerdown;

            function pointermove(e) {
                if (self._isDragging !== true) {
                    return;
                }
                if (pointerId !== e.pointerId) {
                    return;
                }
                var p = positions[e.pointerId];
                self.absPosition = {
                    x: e.x - p.x,
                    y: e.y - p.y
                };
                self.trigger("drag", new wd.EventArgs("drag"));
                self.scene.update();
            }

            this._dragPointerMove = this._dragPointerMove || pointermove;

            function pointerup(e) {
                self._isDragging = false;
                if (pointerId !== e.pointerId) {
                    return;
                }

                delete positions[e.pointerId];
                self.scene.off("pointermove", self._dragPointerMove);
                self.scene.off("pointerup", self._dragPointerUp);
                self.trigger("dragstop", new wd.EventArgs("dragstop"));
            }

            this._dragPointerUp = this._dragPointerUp || pointerup;

            this._draggable = draggable;
            if (draggable === true) {
                this.pointers = true;
                this.pointerdown(this._dragPointerDown);
                if (this.scene) {
                    this.scene.pointers = true;
                    this.scene.update();
                }
            }
            else {
                self._isDragging = false;
                this.off("pointerdown", this._dragPointerDown);
                this.scene.off("pointermove", this._dragPointerMove);
                this.scene.off("pointerup", this._dragPointerUp);
            }
        }
    });

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The DisplayObject Collection
(function (wd, undefined) {
    "use strict";

    var DisplayObjectCollection;

    /**
     * Represent the collection which holds and manages `webDoodling.DisplayObject`.
     *
     * @class webDoodling.DisplayObjectCollection
     * @extends webDoodling.Collection
     *
     * @public
     * @version 1.0
     **/
    DisplayObjectCollection = wd.Class({

        /**
         * Returns the `type` of `webDoodling.DisplayObjectCollection`,
         * always returns'DisplayObjectCollection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.DisplayObjectCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("DisplayObjectCollection"),

        /**
         * Initializes the new instance of `webDoodling.DisplayObjectCollection`.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.DisplayObjectCollection
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();
            this._scene = null;

            this.onValidate = function (obj) {
                if (obj instanceof wd.DisplayObject === false) {
                    throw new wd.Error("wd-invalid-argument", obj);
                }
                return null;
            };
        },

        /**
         * Finds the display object in collection and children heirarchy.
         *
         * @function find(key)
         * @param  {string} key The dot (.) separated keys(ids) of display object.
         * @returns {webDoodling.DisplayObject} The webDoodling.DisplayObject if found, else undefined.
         *
         * @example
         * // This example searches rect in child-group through main-group.
         *  var childRect = scene.find("main-group.child-group.rect");
         *
         * @memberOf webDoodling.DisplayObjectCollection
         * @public
         * @version 1.0
         */
        find: function find(key) {
            var curObj, curKey, index,
                nextKeys,
                collection = arguments[1] || this;

            index = key.indexOf(".");

            if (index >= 0) {
                curKey = key.substring(0, index);
                nextKeys = key.substring(index+1);
                curObj = collection._map[curKey];
                if (curObj && nextKeys && curObj.children) {
                    return collection.find(nextKeys, curObj.children);
                }
                return curObj;
            }
            else {
                return collection._map[key];
            }
        },

        /**
         * Removes an item from the `webDoodling.DisplayObjectCollection` and detatches itself from the
         * associated Scene.
         * Throws an error stating 'Item not found' if the specified object is not found in the list.
         * This function is chainable.
         *
         * @function remove(item)
         * @param {object} An item to be removed from the list.
         * @returns {webDoodling.Collection} The current instance.
         *
         * @memberOf webDoodling.Collection
         * @public
         * @version 1.0
         **/
        remove: function remove(item) {
            var index = this.indexOf(item),
                key = this._keys[index],
                items = this._items,
                keys = this._keys;

            //If index found
            if (index >= 0) {
                this.trigger("itemBeforeRemove", new wd.CollectionEventArgs(item));
                items.splice(index, 1); //delete array item
                keys.splice(index, 1); //delete key item

                //Remove item from the map if key found
                if (key !== undefined) {
                    delete this._map[key]; //delete key mapping
                }

                //Detatch item from scene.
                if (!!this._scene && !!item._scene) {
                    delete this._scene._hexMap[item._hex];
                    delete item._scene;
                    delete item._hex;
                }

                item._parent = null;

                this.trigger("itemRemoved", new wd.CollectionEventArgs(item));
            }
            else {
                throw new wd.Error("wd-item-not-found");
            }
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.DisplayObjectCollection].
         *
         * @memberOf webDoodling.DisplayObjectCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.DisplayObjectCollection]";
        }

    }, wd.Collection);

    wd.DisplayObjectCollection = DisplayObjectCollection;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Animation core
(function (wd, undefined) {
    "use strict";

    /**
     * This function invokes the callback designed for an animation.
     *
     * @function
     * @reference
     * Shim by Paul Irish
     * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     *
     * @public
     * @version 1.0
     **/
    window.requestAnimationFrame =
        window.requestAnimationFrame ||
            window.msRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };

    /**
     * Gets the calculated in-between the numbers.
     *
     * @function getNumberTween(from, to, length, easing)
     * @param {number} from The from number.
     * @param {number} to The to number.
     * @param {number} length The length of returning an array.
     * @param {function} easing The timing function. If not passed, `webDoodling.easing.none` function is used.
     *
     * @example
     * var tween1 = new wd.Tween(obj, "x", 200, 1, 20, "quadIn");
     *
     * var tween2 = new wd.Tween(obj, "x", "+10", 1, 20, "quadIn");
     *
     * var tween3 = new wd.Tween(obj, "x", {x: [250, 400]}, 1, 20, "quadIn");
     *
     * @returns {Array[number]} Returns the array of calculated in-between numbers.
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    wd.getNumberTween = function getNumberTween(from, to, length, easing) {
        var vals = [],
            change = to - from,
            i, t, val;

        for (i = 0; i < length; i += 1) {
            /**
             * if last i:
             *      t = 1
             * else:
             *      t = (1 / (frames - 1) * i
             **/
            t = (i === length - 1) ? 1 : (1 / (length - 1)) * i;
            val = easing(t, from, change, 1);
            vals.push(val);
        }
        return vals;
    };

    /**
     * Gets the calculated in-between colors.
     *
     * @function getColorTween(from, to, length, easing)
     * @param {webDoodling.Color} from The from color.
     * @param {webDoodling.Color} to The to color.
     * @param {number} length The length of returning an array.
     * @param {function} easing The timing function. If not
     * passed, `webDoodling.easing.none` is used.
     *
     * @example
     * var tween1 = new wd.Tween(obj,
     *                  styles: [
     *                      {
     *                          index: 1,
     *                          fill: "yellow"
     *                      }], 1, 20, "quadIn");
     *
     * var tween2 = new wd.Tween(obj,
     *                  styles: [
     *                      {
     *                          index: 1,
     *                          fill: "+10"
     *                      }], 1, 20, "quadIn");
     *
     * @returns {Array[webDoodling.Color]} Returns the array of calculated
     * in-between colors.
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    wd.getColorTween = function getColorTween(from, to, length, easing) {

        var vals = [],
            t, r, g, b, a, i;

        for (i = 0; i < length; i += 1) {
            t = (i === length - 1) ? 1 : (1 / (length - 1)) * i;
            r = Math.round(easing(t, from.r, to.r - from.r, 1));
            g = Math.round(easing(t, from.g, to.g - from.g, 1));
            b = Math.round(easing(t, from.b, to.b - from.b, 1));
            a = easing(t, from.a, to.a - from.a, 1);
            var hex = (new wd.Color(r, g, b, a)).toRGBA();
            vals.push(hex);
        }
        return vals;
    };

    /**
     * Starting from parameter value `from` upto parameter value `to`, calculates
     * the co-ordinates in-between the given path considering the timing function `easing`.
     *
     * @function getPathTween(path, length, easing, xOffset, yOffset, rotationOffset, followDirection, reverse)
     * @param {webDoodling.Path} path.
     * @param {number} length The length of the returning array.
     * @param {function} easing The timing function. If not passed, `webDoodling.easing.none` function is used.
     * @param {number} xOffset Add the xOffset.
     * @param {number} yOffset Add the yOffset.
     * @param {number} rotationOffset Add the rotationOffset.
     * @param {boolean} followDirection Follow the path direction, `true` if ignored.
     * @param {boolean} reverse If the reverse is `true` considers path end as start position, `false` if ignored.
     *
     * @example
     * var tween = wd.Tween("polygon", "path", {
     *                  path: "polygon-path",
     *                  followPath: true
     *              }, 1, 50, "linear");
     *
     * @returns {Array} Returns the array of calculated in-between the points.
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    wd.getPathTween = function getPathTween(path, length, easing, xOffset, yOffset, rotationOffset, followDirection, reverse) {
        var t, index, lastIndex,
            x1, y1, x2, y2,
            dx, dy,
            slope, slopeChanged = false,
            prevSlope,
            //Fetch points array from specified path.
            points = path.toArray(),
            vals = [],
            change = points.length - 1,
            i, counter;

        easing = easing || wd.easing.none;
        xOffset = xOffset || 0;
        yOffset = yOffset || 0;
        followDirection = (followDirection === undefined) ? false : followDirection;
        reverse = (reverse === undefined) ? false : reverse;
        rotationOffset = (rotationOffset === undefined) ? 0 : rotationOffset;

        //Add offsets to points if required.
        if (xOffset || yOffset) {
            for (i=0; i < points.length; i += 1) {
                points[i].x += xOffset;
                points[i].y += yOffset;
            }
        }

        if (reverse) {
            points.reverse();
        }

        for (i = 0; i < length; i += 1) {
            t = (i === length - 1) ? 1 : (1 / (length - 1)) * i;
            index = Math.max(Math.min(Math.round(easing(t, 0, change, 1)), change), 0);

            if (i > 0) {
                x1 = vals[lastIndex].x;
                y1 = vals[lastIndex].y;
                x2 = points[index].x;
                y2 = points[index].y;

                if (followDirection) {
                    //Find slop
                    dx = x2 - x1;
                    dy = y2 - y1;
                    slope = Math.atan2(dy, dx) * 180 / Math.PI;

                    //If slope detected first time, apply to all previous
                    if (slope !== 0 && slopeChanged === false) {

                        counter = 0;
                        while (counter < i) {
                            vals[counter].slope = slope;
                            counter += 1;
                        }
                        slopeChanged = true;
                    }
                    //Fill the gaps
                    else if (slope === 0 && prevSlope) {
                        slope = prevSlope;
                    }
                    prevSlope = slope;
                }
                else {
                    slope = 0;
                }
            }
            else {
                x2 = points[0].x;
                y2 = points[0].y;
                slope = 0;
            }

            slope += rotationOffset;

            lastIndex = vals.push({
                x: x2,
                y: y2,
                slope: slope
            }) - 1;
        }

        return vals;
    };

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Tweenables
(function (wd, undefined) {
    "use strict";

    var Tweenables;
    /**
     * Represents the tweenables, which helps to define tweenable members for host object.
     * Defines tweenable fields for `webDoodling.DisplayObject`.
     * Tweenable fields can be used by `webDoodling.Tween` to
     * animate display object using `DisplayObject.animate` and `webDoodling.Timeline`.
     *
     * @class webDoodling.Tweenables
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    Tweenables = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Tweenables`, always returns'Tweenables'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        type: wd.type("Tweenables"),

        /**
         * Returns an `object` to which tweenables are associated.
         *
         * @readonly {object} object
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        object: wd.readonly({
            get: function () {
                return this._object;
            }
        }),

        /**
         * Returns the `length` of the tweenables for specified objects.
         *
         * @readonly {number} length
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        length: wd.readonly({
            get: function () {
                return this._tweenables.length;
            }
        }),

        /**
         * Returns the tweenable `keys`.
         *
         * @readonly {Array} keys
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        keys: wd.readonly({
            get: function () {
                return this._tweenables.slice();
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.Tweenables`.
         *
         * @constructor init(associatedObject)
         * @param {object} associatedObject An object to which tweenables are associated.
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        init: function init(associatedObject) {
            if (associatedObject === undefined) {
                throw new wd.Error("wd-not-an-object");
            }
            this._object = associatedObject;
            this._tweenables = [];
            this._tweenablesMap = {};
        },

        /**
         * Registers the new tweenables.
         *
         * @function register(type, keys)
         * @param {string} type The type of tweenables, could be either number, color or path.
         * @param {variable args} keys The keys.
         * @returns {weboodling.Tweenables} The current object, useful for chaining.
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        register: function register(type /* key_0, key_1, key_n **/) {
            var keys, key,
                i, iLen,
                tweenables = this._tweenables,
                tweenablesMap = this._tweenablesMap;

            if (arguments.length < 2) {
                throw new wd.Error("wd-invalid-argument");
                //throw new wd.Error("Invalid arguments, expecting at-least two arguments (type, key1, key2, ...)");
            }

            keys = Array.prototype.splice.call(arguments, 1);
            for (i = 0, iLen = keys.length; i < iLen; i++) {
                key = keys[i];
                if (tweenablesMap[key] === undefined) {
                    tweenables.push(key);
                    tweenablesMap[key] = type;
                }
            }
            return this;
        },

        /**
         * Returns the `type` of tweenable for given key.
         *
         * @function getType(key)
         * @param {string} key The key for which type need to be looked.
         * @returns {string} The type of tweenable.
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        getType: function getType(key) {
            return this._tweenablesMap[key];
        },

        /**
         * Returns the array of values useful for animating key on associated object.
         *
         * @function getFrames(key, val, length, easing)
         * @param {string} key The key.
         * @param {number} val The value of an object.
         * @param {number} length The length of an object.
         * @param {string, function} easing The easing function or its registered name.
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        getFrames: function getFrames(key, val, length, easing) {
            var tweenable = this._tweenablesMap[key];
            if (tweenable === undefined) {
                throw new wd.Error("wd-not-a-tweenable", key);
//                throw new Error("Key '" + key + "' doesn't support animation.");
            }
            switch (tweenable) {
            case "number":
                return this._getNumberFrames(key, val, length, easing);
            case "color":
                return this._getColorFrames(key, val, length, easing);
            case "path":
                return this._getPathFrames(key, val, length, easing);
            default:
                throw new wd.Error("wd-invalid-argument");
            }
        },

        pushFrames: function pushFrames(frames, key, val, length, easing) {
            var framesToPush = this.getFrames(key, val, length, easing),
                frame,
                xFrames,
                yFrames,
                rFrames,
                i, iLen;

            if (key === "path") {
                xFrames = [];
                yFrames = [];
                rFrames = [];
                for (i = 0, iLen = framesToPush.length; i < iLen; i += 1) {
                    frame = framesToPush[i];
                    xFrames.push(frame.x);
                    yFrames.push(frame.y);
                    rFrames.push(frame.slope);
                }
                this._pushFrames(frames, "x", xFrames);
                this._pushFrames(frames, "y", yFrames);
                this._pushFrames(frames, "rotation", rFrames);
            }
            else {
                this._pushFrames(frames, key, framesToPush);
            }
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Tweenables].
         *
         * @memberOf webDoodling.Tweenables
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Tweenables]";
        },

        //Private Members

        _pushFrames: function (frames, key, framesToPush) {
            var propFrames = [],
                object = this._object,
                i, iLen;

            for (i = 0, iLen = framesToPush.length; i < iLen; i++) {
                propFrames.push({
                    item: object,
                    key: key,
                    value: framesToPush[i]
                });
            }
            frames.push(propFrames);
        },

        _getNumberFrames: function (key, val, length, easing) {
            var startVal, endVal;

            if (wd.is.array(val)) {
                startVal = val[0];
                endVal = val[1];
            }
            else if(wd.is.string(val)) {
                val = this._parseRelativeValue(this._object[key], val);
                startVal = val[0];
                endVal = val[1];
            }
            else {
                startVal = this._object[key];
                endVal = val;
            }
            return wd.getNumberTween(startVal, endVal, length, easing);
        },

        _getColorFrames: function (key, val, length, easing) {
            var startVal, endVal;
            if (wd.is.array(val)) {
                startVal = val[0];
                endVal = val[1];
            }
            else if (wd.is.string(val)) {
                val = this._parseRelativeColor(this._object[key], val);
                startVal = val[0];
                endVal = val[1];
            }
            else {
                startVal = this._object[key];
                endVal = val;
            }

            startVal = (startVal instanceof wd.Color) ? startVal : new wd.Color(startVal);
            endVal = (endVal instanceof wd.Color) ? endVal : new wd.Color(endVal);

            return wd.getColorTween(startVal, endVal, length, easing);
        },

        _getPathFrames: function (key, val, length, easing) {
            var path = val,
                followPath = false,
                reverse = false,
                object = this._object,
                origin = object.absOrigin;

            if (wd.is.plainObject(val)) {
                path = val.path;
                followPath = (val.followPath === undefined) ? followPath : val.followPath;
                reverse = (val.reverse === undefined) ? reverse : val.reverse;
            }

            if (wd.is.string(path)) {
                path = object.scene.get(path);
            }

            return wd.getPathTween(path, length, easing,
                -origin.x, -origin.y,
                object.rotation, followPath, reverse);

        },

        _parseRelativeValue: function (currentVal, relativeVal) {
            var operator, val;
//            if (wd.is.string(relativeVal) === false) {
//                return [currentVal, currentVal];
//            }
            operator = relativeVal[0];
            val = parseFloat(relativeVal.substr(1));
            switch (operator) {
            case "+":
                return [currentVal, currentVal + val];
            case "-":
                return [currentVal, currentVal - val];
            default:
                throw new wd.Error("wd-relative-operator-not-supported");
            }
        },

        _parseRelativeColor: function (currentVal, relativeVal) {
            var operator, val,
                color = new wd.Color(currentVal);
            operator = relativeVal[0];
            if (operator !== "+" && operator !== "-") {
                return [currentVal, relativeVal];
            }
            val = parseFloat(relativeVal.substr(1));
            if (isNaN(val)) {
                return [currentVal, currentVal];
            }
            switch (operator) {
            case "-":
                color.darker(val);
                return [currentVal, color.toRGBA()];
            case "+":
                color.lighter(val);
                return [currentVal, color.toRGBA()];
            }
        }
    });

    wd.Tweenables = Tweenables;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Easing
(function (wd, undefined) {
    "use strict";

    // Based on Rober Penner's easing algorithms
    // http://robertpenner.com/easing/

    var easing = {};

    /**
     * `webDoodling.easing` contains various easing function useful for controlling tween
     * behaviour.
     *
     * @module webDoodling.easing
     * @example
     * var tween = new wd.Tween({
     *      start: 1,
     *      stop: 10,
     *      easing: wd.easing.quadIn
     * });
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    easing = {

        /**
         * The `linear` easing function which controlling the tween with linear effect.
         *
         * @function linear(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.linear
         * });
         *
         * @returns {number} Returns the final value of linear effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        linear: function linear(t, b, c, d) {
            return c * t / d + b;
        },

        //Quadratic Easing
        /**
         * The quadratic easing function, mode in.
         *
         * @function quadIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quadIn
         * });
         *
         * @returns {number} Returns the final value of quadratic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quadIn: function quadIn(t, b, c, d) {
            return c * (t /= d) * t + b;
        },

        /**
         * The quadratic easing function, mode out.
         *
         * @function quadOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quadOut
         * });
         *
         * @returns {number} Returns the final value of quadratic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quadOut: function quadOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },

        /**
         * The quadratic easing function, mode in and out.
         *
         * @function quadInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quadInOut
         * });
         *
         * @returns {number} Returns the final value of quadratic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quadInOut: function quadInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) { return c / 2 * t * t + b; }
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        },

        //Cubic Easing

        /**
         * The cubic easing function, mode in.
         *
         * @function cubicIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.cubicIn
         * });
         *
         * @returns {number} Returns the final value of cubic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        cubicIn: function cubicIn(t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },

        /**
         * The cubic easing function, mode out.
         *
         * @function cubicOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.cubicOut
         * });
         *
         * @returns {number} Returns the final value of cubic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        cubicOut: function cubicOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },

        /**
         * The cubic easing function, mode in and out.
         *
         * @function cubicInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.cubicInOut
         * });
         *
         * @returns {number} Returns the final value of cubic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        cubicInOut: function cubicInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) { return c / 2 * t * t * t + b; }
            return c / 2 * ((t -= 2) * t * t + 2) + b;
        },

        //Quartic Easing

        /**
         * The quadratic easing function, mode in.
         *
         * @function quartIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quartIn
         * });
         *
         * @returns {number} Returns the final value of quartic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quartIn: function quartIn(t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },

        /**
         * The quadratic easing function, mode out.
         *
         * @function quartOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quartOut
         * });
         *
         * @returns {number} Returns the final value of quartic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quartOut: function quartOut(t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        },

        /**
         * The quadratic easing function, mode in and out.
         *
         * @function quartInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quartInOut
         * });
         *
         * @returns {number} Returns the final value of quartic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quartInOut: function quartInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) { return c / 2 * t * t * t * t + b; }
            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        },

        //Quantic Easing

        /**
         * The quadratic easing function, mode in.
         *
         * @function quintIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quintIn
         * });
         *
         * @returns {number} Returns the final value of Quantic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quintIn: function quintIn(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },

        /**
         * The quadratic easing function, mode out.
         *
         * @function quintOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quintOut
         * });
         *
         * @returns {number} Returns the final value of Quantic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quintOut: function quintOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },

        /**
         * The quadratic easing function, mode in and out.
         *
         * @function quintInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.quintInOut
         * });
         *
         * @returns {number} Returns the final value of Quantic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        quintInOut: function quintInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) { return c / 2 * t * t * t * t * t + b; }
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },

        //Sinusodial Easing

        /**
         * The sinusodial easing function, mode in.
         *
         * @function sineIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.sineIn
         * });
         *
         * @returns {number} Returns the final value of Sinusodial effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        sineIn: function sineIn(t, b, c, d) {
            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },

        /**
         * The sinusodial easing function, mode out.
        *
         * @function sineOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.sineOut
         * });
         *
         * @returns {number} Returns the final value of Sinusodial effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        sineOut: function sineOut(t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },

        /**
         * The sinusodial easing function, mode in and out.
         *
         * @function sineInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.sineInOut
         * });
         *
         * @returns {number} Returns the final value of Sinusodial effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        sineInOut: function sineInOut(t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        },

        //Exponential Easing

        /**
         * The exponential easing function, mode in.
        *
         * @function expoIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.expoIn
         * });
         *
         * @returns {number} Returns the final value of Exponential effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        expoIn: function expoIn(t, b, c, d) {
            return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
        },

        /**
         * The exponential easing function, mode out.
        *
         * @function expoOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.expoOut
         * });
         *
         * @returns {number} Returns the final value of Exponential effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        expoOut: function expoOut(t, b, c, d) {
            return (t === d) ? b + c : c * 1.001 * (-Math.pow(2, -10 * t / d) + 1) + b;
        },

        /**
         * The exponential easing function, mode in and out.
        *
         * @function expoInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.expoInOut
         * });
         *
         * @returns {number} Returns the final value of Exponential effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        expoInOut: function expoInOut(t, b, c, d) {
            if (t === 0)  { return b; }
            if (t === d) { return b + c; }
            if ((t /= d / 2) < 1) { return c / 2 * Math.pow(2, 10 * (t - 1)) + b - c * 0.0005; }
            return c / 2 * 1.0005 * (-Math.pow(2, -10 * --t) + 2) + b;
        },

        //Circular Easing

        /**
         * The circular easing function, mode in.
         *
         * @function circIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.circIn
         * });
         *
         * @returns {number} Returns the final value of Circular effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        circIn: function circIn(t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },

        /**
         * The circular easing function, mode out.
         *
         * @function circOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.circOut
         * });
         *
         * @returns {number} Returns the final value of Circular effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        circOut: function circOut(t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },

        /**
         * The circular easing function, mode in and out.
         *
         * @function circInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.circInOut
         * });
         *
         * @returns {number} Returns the final value of Circular effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        circInOut: function circInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) { return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b; }
            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        },

        //Elastic Easing

        /**
         * An elastic easing function, mode in.
         *
         * @function elasticIn(t, b, c, d, a, p)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         * @param {number} a  // TODO:
         * @param {number} p  // TODO:
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.elasticIn
         * });
         *
         * @returns {number} Returns the final value of Elastic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        elasticIn: function elasticIn(t, b, c, d, a, p) {
            var s;
            if (t === 0) { return b; }
            if ((t /= d) === 1) { return b + c; }
            if (!p) { p = d * 0.3; }
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else { s = p / (2 * Math.PI) * Math.asin(c / a); }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },

        /**
         * An elastic easing function, mode out.
        *
         * @function elasticOut(t, b, c, d, a, p)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         * @param {number} a  // TODO:
         * @param {number} p  // TODO:
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.elasticOut
         * });
         *
         * @returns {number} Returns the final value of Elastic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        elasticOut: function elasticOut(t, b, c, d, a, p) {
            var s;
            if (t === 0) { return b; }
            if ((t /= d) === 1) { return b + c; }
            if (!p) { p = d * 0.3; }
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else { s = p / (2 * Math.PI) * Math.asin(c / a); }
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },

        /**
         * An elastic easing function, mode in and out.
        *
         * @function elasticInOut(t, b, c, d, a, p)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         * @param {number} a  // TODO:
         * @param {number} p  // TODO:
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.elasticInOut
         * });
         *
         * @returns {number} Returns the final value of Elastic effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        elasticInOut: function elasticInOut(t, b, c, d, a, p) {
            var s;
            if (t === 0) { return b; }
            if ((t /= d / 2) === 2) { return b + c; }
            if (!p) { p = d * (0.3 * 1.5); }
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else { s = p / (2 * Math.PI) * Math.asin(c / a); }
            if (t < 1) { return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
        },

        //Back Easing

        /**
         * The back easing function, mode in.
        *
         * @function backIn(t, b, c, d, s)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         * @param {number} s  // TODO:
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.backIn
         * });
         *
         * @returns {number} Returns the final value of back effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        backIn: function backIn(t, b, c, d, s) {
            if (s === undefined) { s = 1.70158; }
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },

        /**
         * The back easing function, mode out.
         *
         * @function backOut(t, b, c, d, s)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         * @param {number} s TODO:
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.backOut
         * });
         *
         * @returns {number} Returns the final value of back effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        backOut: function backOut(t, b, c, d, s) {
            if (s === undefined) { s = 1.70158; }
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },

        /**
         * The back easing function, mode in and out.
        *
         * @function backInOut(t, b, c, d, s)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         * @param {number} s TODO:
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.backInOut
         * });
         *
         * @returns {number} Returns the final value of back effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        backInOut: function backInOut(t, b, c, d, s) {
            if (s === undefined) { s = 1.70158; }
            if ((t /= d / 2) < 1) { return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; }
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        },

        //Bounce Easing

        /**
         * The bouncing easing function, mode in.
        *
         * @function bounceIn(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.bounceIn
         * });
         *
         * @returns {number} Returns the final value of bounce effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        bounceIn: function bounceIn(t, b, c, d) {
            return c - wd.easing.bounceOut(d - t, 0, c, d) + b;
        },

        /**
         * The bounce easing function, mode out.
         *
         * @function bounceOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.bounceOut
         * });
         *
         * @returns {number} Returns the final value of bounce effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        bounceOut: function bounceOut(t, b, c, d) {
            if ((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            } else if (t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
            } else if (t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
            } else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
            }
        },

        /**
         * The bounce easing function, mode in and out.
        *
         * @function bounceInOut(t, b, c, d)
         * @param {number} t The current time, must be between 0.0 to 1.0.
         * @param {number} b The start value.
         * @param {number} c The change between start and end value.
         * @param {number} d The total time.
         *
         * @example
         * var tween = new wd.Tween({
         *      start: 1,
         *      stop: 10,
         *      easing: wd.easing.bounceInOut
         * });
         *
         * @returns {number} Returns the final value of bounce effect.
         *
         * @memberOf webDoodling.easing
         * @public
         * @version 1.0
         **/
        bounceInOut: function bounceInOut(t, b, c, d) {
            if (t < d / 2) { return easing.bounceIn(t * 2, 0, c, d) * 0.5 + b; }
            else {
                return easing.bounceOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            }
        }

    };

    easing.none = easing.linear;
    wd.easing = easing;


})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The AnmationLoop
(function (wd) {
    "use strict";

    var AnimationLoop;
    /**
     * Provides the core functionality which facilitates
     * and managing of animation loops. If available, it takes the advantage of
     * the `window.requestAnimationFrame` function
     * to provide efficient animation loop.
     *
     * @class webDoodling.AnimationLoop
     * @example
     * var loop = new wd.AnimationLoop(function() {
     *      //Animation related code should go here.
     *      var circle = scene.children.get("circle");
     *      circle.radius += 10;
     * }, canvasElm);
     * loop.play();
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    AnimationLoop = wd.Class({

        /**
         * Returns the `type` of `webDoodling.AnimationLoop`, always returns 'AnimationLoop'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        type: wd.type("AnimationLoop"),

        /**
         * TODO: Correct the description
         * The `scope` represents the loop's execution context. That is when `this` is used in
         * inside loop's callback function it represents
         *
         * @readonly {Object} scope
         * @example
         * var loop = wd.AnimationLoop({
         *     scope: window,
         *     onTick: function() {
         *         console.log(this); //Prints window object.
         *     }
         * });
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        scope: wd.readonly(),

        /**
         * Represents the callback function which is invoked while loop is playing.
         * If the `scope` is set, callback is executed within the context of a
         * given scope.
         *
         * @callback onTick(time)
         * @param {number} time The current time.
         *
         * @example
         * var loop = new AnimationLoop(scene.canvas)
         * loop.onTick = function (time) {
         *     console.log(time); // Prints time on console on every animation loop tick;
         * }
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        onTick: wd.attribute(false),

        /**
         * An html `element` to which `webDoodling.AnimationLoop` gets attached. This element
         * is required by the `requestAnimationFrame` function. Which in-turn helps generate
         * efficient animation loop only if the element is visible. Loop pauses itself
         * if the current document tab in which this element resides is not active.
         *
         * @readonly {Object} element
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        element: wd.readonly(),

        /**
         * Returns the playing status of the loop, whether it is being played or not.
         * If animation is running returns `true` else `false`.
         *
         * @readonly {boolean} isPlaying
         * @default false
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        isPlaying: wd.readonly(false),

        /**
         * Represents the loop's frames per second.
         *
         * @field {number} fps
         * @default 40
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        fps: wd.attribute(wd.config("defaultFPS")),

        /**
         * For every animation frame, the effort is calculated in millisecond. This
         * gives the calculated effort in millisecond of last frame.
         *
         * @readonly {number} lastFPS
         * @default false
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        lastFPS: wd.readonly({
            value: false,
            get: function () {
                //Only activate when required;
                if (this._lastFPS === false) { //false means not yet activated.
                    this._lastFPS = 0;
                    return 0;
                }
                return this._lastFPS;
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.AnimationLoop`.
         *
         * @constructor AnimationLoop(onTick, element, scope)
         * @param {funcation} onTick A callback function which is supposed to be invoked for each and every tick of the loop.
         * @param {HTMLElement} element An html element to which this loop need to be attached.
         * on every loop ticks.
         * @param {object} scope An object in whoes scope callbacks should be executed.
         *
         * @example
         * var animationLoop = new wd.AnimationLoop(function() {
         *      var circle = scene.children.get("circle");
         *      circle.radius += 10;
         * }, canvasElm);
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        init: function init(onTick, element, scope) {
            this.onTick = onTick;
            this._element = element || window;
            this._scope = scope;
            this._isPlaying = false;
        },

        /**
         * Commences the `webDoodling.animation` loop,and sets the `isPlaying` state to true.
         * -When loop going to pause this function will help to play again.
         *
         * @function play()
         * @example
         * var animationLoop = new wd.AnimationLoop(function() {
         *      var circle = scene.children.get("circle");
         *      circle.radius += 10;
         * }, canvasElm);
         * animationLoop.play();
         *
         * @returns {webDoodling.AnimationLoop} The current object, useful for chaining.
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        play: function play() {
            if (this._isPlaying === true) {
                return this;
            }
            this._isPlaying = true;
            this._tick();
            return this;
        },

        /**
         * Pause the `webDoodling.animation` loop.
         *
         * @function pause()
         * @example
         * var animationLoop = new wd.AnimationLoop(function() {
         *      var circle = scene.children.get("circle");
         *      circle.radius += 10;
         * }, canvasElm);
         * animationLoop.pause();
         *
         * @returns {weboodling.AnimationLoop} The current object, useful for chaining.
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            this._isPlaying = false;
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AnimationLoop].
         *
         * @memberOf webDoodling.AnimationLoop
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AnimationLoop]";
        },

        /*** Private Area ***/

        /**
         * Ticks the animation loop.
         *
         * @function _tick()
         *
         * @static webDoodling.AnimationLoop
         * @private
         * @version 1.0
         **/
        _tick: function () {
            var element = this._element,
                callback = this.onTick,
                scope = this._scope,
                self = this,
                fps = this.fps,
                lastTime = (new Date()) - 0,
                newFPSTime,
                lastFPSTime = lastTime,
                newSecond, lastSecond = 0,
                fpsTime = 1000 / fps,
                timeDelta = 0;

            function animationLoop() {
                var newTime;
                if (self._isPlaying !== true) {
                    return;
                }

                newTime = new Date();
                timeDelta = newTime - lastTime;
                //If fps is 0 then dont restrict time.
                if (fps !== 0) {
                    if (timeDelta < fpsTime) {
                        window.requestAnimationFrame(animationLoop, element);
                        return;
                    }
                }
                lastTime = newTime;
                if (scope) {
                    callback.call(scope);
                }
                else {
                    callback();
                }

                if (self._lastFPS !== false) {
                    //Update lastFPS readonly property
                    newFPSTime = new Date();
                    newSecond = newFPSTime.getSeconds();
                    if (newSecond !== lastSecond) {
                        self._lastFPS = Math.round(1000 / (newFPSTime - lastFPSTime), 2);
                        lastSecond = newSecond;
                    }
                    lastFPSTime = newFPSTime;
                }
                window.requestAnimationFrame(animationLoop, element);
            }
            window.requestAnimationFrame(animationLoop, element);
        }
    });

    wd.AnimationLoop = AnimationLoop;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Timeline
(function (wd, undefined) {
    "use strict";

    //holds the key name that need to be ignored.
    var _reservedKeys = {
            options: "",
            index: "",
            id: ""
        },
        defaultFramesCount = wd.config("defaultFramesCount"),
        Tween;


    /**
     * Represents the `webDoodling.Tween` object. While creating animations using webDoodling
     * tween object stores tween parameters, and also facilitates
     *
     * @class webDoodling.Tween
     *
     * @example
     * var tween = new wd.Tween({
     *      object: obj,
     *      start: 1,
     *      stop: 20,
     *      easing: "quadIn",
     *      values: {
     *          x: 200
     *      }
     * });
     *
     * @memberOf webDoodling
     * @extends webDoodling.Serializable
     * @public
     * @version 1.0
     **/
    Tween = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Tween`, always returns 'Tween'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        type: wd.type("Tween"),

        /**
         * The display object `values` which need to be tweened.
         *
         * @field {Object} values
         * @example
         * var tween = new wd.Tween();
         * tween.values = {x: 100};
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        values: wd.property(),

        /**
         * Tween Play from the `start` position.
         * -If the `start` value is less than 1 then its set to 1.
         *
         * @field {number} start
         * @default 1
         *
         * @example
         * var tween = new wd.Tween();
         * tween.start = 15;
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        start: wd.property({
            value: 1,
            get: function () {
                return this._start;
            },
            set: function (v) {
                v = parseInt(v);
                if (isNaN(v)) {
                    throw new wd.Error("wd-not-a-number", "start");
                }
                this._start = (v < 1) ? 1 : v;
            }
        }),

        /**
         * Tween play from start to stop position.
         * -When set the stop position at that time length will be set.
         * -If stop value is less than start value then its set to start position.
         *
         * @field {number} stop
         * @default defaultFramesCount
         *
         * @example
         * var tween = new wd.Tween();
         * tween.start = 1;
         * tween.stop = 30;
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        stop: wd.property({
            value: defaultFramesCount,
            get: function () {
                return this._stop;
            },
            set: function (v) {
                v = parseInt(v);
                if (isNaN(v)) {
                    throw new wd.Error("wd-not-a-number", "stop");
                }
                if (v < this._start) {
                    v = this._start;
                }
                this._stop = v;
                this._length = v - this._start + 1;
            }
        }),

        /**
         * `length` define how much frames will be play.
         * - When set the `length` stop will be set.
         *
         * @field {number} length
         * @default defaultFramesCount
         *
         * @example
         * var tween = new wd.Tween();
         * tween.start = 1;
         * tween.length = 30;
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        length: wd.property({
            value: defaultFramesCount,
            get: function () {
                return this._length;
            },
            set: function (v) {
                v = parseInt(v);
                if (isNaN(v)) {
                    throw new wd.Error("wd-not-a-number", "length");
                }
                this._length = v;
                this._stop = this._start + v - 1;
            }
        }),

        /**
         * Easing effect to controlling tween.
         *
         * @field {string} easing
         * @default linear
         *
         * @example
         * var tween = new wd.Tween();
         * tween.easing = "quadIn";
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        easing: wd.property("linear"),

        /**
         * Returns the associated `webDoodling.Scene` for this object.
         *
         * @readonly {webDoodling.scene} scene
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        scene: wd.readonly(),

        /**
         * Returns the associated `webDoodling.Timeline` for this object.
         *
         * @readonly {webDoodling.Timeline} timeline
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        timeline: wd.readonly(),

        /**
         * `displayObject` on which want to get tween effect.
         *
         * @field {string, webDoodling.DisplayObject} displayObject
         *
         * @example
         * var rect, tween;
         * rect = new wd.Rectangle({
         *      x: 20,
         *      y: 20,
         *      width: 100,
         *      height: 100
         * });
         * tween = new wd.Tween();
         * tween.object = rect;
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        object: wd.property(),

        /**
         * Initializes the new instance of `webDoodling.Tween`.
         *
         * @constructor init()
         *
         * @constructor init(o)
         * @params {object} The tween Object.
         *
         * @constructor init(displayObject, propertyName, propertyValue, startFrame, length, easing)
         * @params {object} displayObject The object on which was tween.
         * @params {string} propertyName The name of the object property.
         * @params {string, number} propertyValue The value of the object property.
         * @params {number} startFrame startFrame start position of the tween effect.
         * @params {number} length The length of the tween.
         * @params {string} easing The easing effect of the tween controlling.
         *
         * @example
         * //TODO: Recheck the example
         * var tween1 = new wd.Tween();
         * tween1.object = scene.get("rectangle");
         * tween1.start = 1,
         * tween1.stop = 30;
         * tween1.easing = "quadIn";
         *
         * var tween2 = new wd.Tween({
         *      object: scene.get("rectangle"),
         *      start: 1,
         *      stop: 30,
         *      easing: "quadIn",
         *      values: {
         *          x: 100
         *      }
         * });
         *
         * var tween3 = new wd.Tween(scene.get("rectangle", "x", 100, 1, 30, "quadOut");
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();

            if (arguments.length > 0) {
                this._load.apply(this, arguments);
            }


            this.serializables(
                "start",
                "length",
                "values",
                {
                    key: "object",
                    value: function () {
                        if (!this.object) {
                            return;
                        }
                        else if (wd.is.string(this.object)) {
                            return this.object;
                        }
                        return this.object.absolutePath;
                    }
                },
                {
                    key: "easing",
                    value: function () {
                        if (wd.is.func(this.easing)) {
                            return this.easing.name; // Return function name.
                        }
                        return this.easing;
                    }
                });
        },

        /**
         * Returns an array containing values useful for animating an object.
         *
         * @function getFrames()
         * @returns {Array}
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        getFrames: function getFrames() {
            var obj = this._getObject(),
                params = this._values,
                frames = [],
                startFrames,

                // Tween Options
                easing = this._easing,
                start = this._start,
                length = this._length;

            if (obj === null) {
                return frames;
            }
            if (wd.is.string(easing)) {
                easing = wd.easing[easing];
                if (!easing) { easing = wd.easing.none; }
            }

            function buildFrame(o, p, key) {
                //console.log(o, p, key);
                var oldVal = o[key],
                    newVal = p[key],
                    i, iLen,
                    item, k2, o2,
                    tweenables = o.tweenables;

                if (oldVal instanceof wd.Collection) {
                    if (newVal instanceof Array === true) {
                        for (i = 0, iLen = newVal.length; i < iLen; i++) {
                            item = newVal[i];
                            if (item.index !== undefined) {
                                k2 = item.index;
                            }
                            else if (item.id !== undefined) {
                                k2 = item.id;
                            }

                            if (k2 !== undefined) {
                                o2 = oldVal.get(k2);
                                buildFrames(o2, item);
                            }
                        }
                    }
                    else if (wd.is.plainObject(newVal)) {
                        item = newVal;
                        if (item.index !== undefined) {
                            k2 = item.index;
                        }
                        else if (item.id !== undefined) {
                            k2 = item.id;
                        }
                        if (k2 !== undefined) {
                            o2 = oldVal.get(k2);
                            buildFrames(o2, item);
                        }
                    }
                }
                else if (tweenables) {
                    tweenables.pushFrames(frames, key, newVal, length, easing);
                }
            }

            function buildFrames(o, p) {
                var key;
                for (key in p) {
                    if (key in _reservedKeys) {
                    //Ignore certain keys
                        continue;
                    }
                    else if (o.tweenables) {
                        buildFrame(o, p, key);
                    }
                }
            }
            buildFrames(obj, params);
            if (start > 1) {
                startFrames = [];
                startFrames[start - 1] = undefined;
                //return startFrames.concat(frames);
            }
            return frames;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Tween].
         *
         * @memberOf webDoodling.Tween
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Tween]";
        },

        /*** Private Area ***/

        //Returns the associated display object.
        _getObject: function () {
            var parent;

            if (wd.is.string(this._object)) {

                if (this._timeline || this.scene) {
                    parent = this._timeline.parent || this.scene;
                    this._object = parent.children.find(this._object);
                    return this._object || null;
                }

                return null;
            }
            return this._object;
        },

        //Responsible for normalizing tween parameters and options.
        _load: function () {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                arg4 = arguments[3],
                arg5 = arguments[4],
                arg6 = arguments[5],
                is = wd.is,
                defaultLength = wd.config("defaultFramesCount");

            if (arguments.length === 1 && is.plainObject(arg1)) {
                this.start  = (arg1.start !== undefined) ? arg1.start : 1;
                this.easing = (arg1.easing !== undefined) ? arg1.easing : "linear";
                this.length = (arg1.length !== undefined) ? arg1.length : defaultLength;

                // object
                if (arg1.object !== undefined) {
                    this._object = arg1.object;
                }
                else {
                    throw new wd.Error("wd-no-argument", "object");
                }

                // values
                if (arg1.values !== undefined) {
                    this._values = arg1.values;
                }
                else {
                    throw new wd.Error("wd-no-argument", "values");
                }

                // Set stop if available and override length.
                if (arg1.stop !== undefined) this.stop = arg1.stop;
            }
            // new wd.Tween("obj", { values }, start, length, easing);
            else if (arguments.length >= 2 && is.plainObject(arg2)) {
                this._object = arg1;
                this.values = arg2;
                this.start  = (arg3 !== undefined) ? arg3 : 1;
                this.length = (arg4 !== undefined) ? arg4 : defaultLength;
                this.easing = (arg5 !== undefined) ? arg5 : "linear";
            }

            // new wd.Tween("obj", x, 10, start, length, easing);
            else if (arguments.length >= 3 && is.string(arg2)) {
                this._object = arg1;
                // setup values
                this.values = { };
                this.values[arg2] = arg3;
                this.start  = (arg4 !== undefined) ? arg4 : 1;
                this.length = (arg5 !== undefined) ? arg5 : defaultLength;
                this.easing = (arg6 !== undefined) ? arg6 : "linear";
            }
            else {
                throw new wd.Error("wd-invalid-argument");
            }
        }

    }, wd.Serializable);

    wd.Tween = Tween;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The DisplayObject Collection
(function (wd) {
    "use strict";

    var TweenCollection;
    /**
     * Represents the collection of `tween`.Only object of type `webDoodling.Tween`can be added to this collection.
     *
     * @class webDoodling.TweenCollection
     *
     * @memberOf webDoodling
     * @extends webDoodling.Collection
     * @public
     * @version 1.0
     **/
    TweenCollection = wd.Class({

        /**
         * Returns the `type` of `webDoodling.TweenCollection`, always returns'TweenCollection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.TweenCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("TweenCollection"),

        /**
         * Remove function generally should allow items to be removed from the collection,
         * however for `webdoodlnig.TweenCollection` once the tween is added, it can't be removed.
         * This overridden function prevents tweens to be removed from the collection.
         *
         * @function remove()
         * @example
         * //TODO: Recheck the example
         * var scene;
         * scene = wd.Scene(canvas, {
         *      children: [
         *          wd.Circle({
         *              id: "circle",
         *              x: 100,
         *              y: 100,
         *              radius: 50
         *          })
         *      ],
         *      timeline: {
         *         repeat: 0,
         *         tweens: [
         *             wd.Tween("circle", "radius", "+10", 1, 30),
         *             wd.Tween("circle", "x", "150", 1, 30)
         *          ]
         *      }
         * });
         * scene.timline.tweens.remove();
         *
         * @memberOf webDoodling.TweenCollection
         * @public
         * @version 1.0
         **/
        remove: function remove() {
            throw new wd.Error("wd-tweens-cannot-be-removed");
        },

        /**
         * Gets invoked before the item is added into the collection so that
         * only objects of type `webDoodling.Tween` can be added.
         *
         * @function onValidate()
         * @param {webDoodling.Tween} obj The webDoodling.Tween object.
         *
         * @memberOf webDoodling.TweenCollection
         * @protected
         * @version 1.0
         **/
        onValidate: function onValidate(obj) {
            if (obj instanceof wd.Tween === false) {
                throw new wd.Error("wd-invalid-argument", obj);
            }
            return null;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.TweenCollection].
         *
         * @memberOf webDoodling.TweenCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.TweenCollection]";
        }

    }, wd.Collection);

    wd.TweenCollection = TweenCollection;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Timeline
(function (wd, undefined) {
    "use strict";

    /**
     * Defines the `webDoodling.animation` timeline object. Timeline object is already associated
     * with `Scene` and `Movie` objects.
     *
     * @class webDoodling.Timeline
     *
     * @example
     * var timeline = new wd.Timeline();
     * timeline.autoPlay = true;
     * timeline.repeat = 0;
     * timline.tweens = [wd.Tween(obj, "x", 200, 1, 20, "linear")];
     *
     * @memberOf webDoodling
     * @extends webDoodling.Serializable
     * @public
     * @version 1.0
     **/
    var Timeline;

    Timeline = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Timeline`, always returns 'Timeline'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        type: wd.type("Timeline"),

        /**
         * The `scene`, on which this timeline is associated with.
         *
         * @readonly {webDoodling.Scene} scene
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        scene: wd.readonly(),

        /**
         * Returns the parent object which contains object object of `webDoodling.Timeline`.
         *
         * @readonly {Object} parent
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        parent: wd.readonly(),

        /**
         * Gets the total numbers of frames in the timeline.
         *
         * @readonly {number} totalFrames
         * @default 0
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        totalFrames: wd.readonly(0),

        /**
         * Gets or sets the current `frame` in the timeline. While setting
         * if the value is less then 1 or greater then `totalFrames` it will be changed
         * to nearest ranged value.
         *
         * @readonly {number} frame
         * @default 1
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        frame: wd.readonly(1),

        /**
         * Repeat number of frames in the timeline. If this value is zero (0), timeline
         * will repeate forever.
         *
         * @field {number} repeat
         * @default 1
         *
         * @example
         * var timeline = new wd.Timeline();
         * //this will play tween animation only one time.
         * timeline.repeat = 1;
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        repeat: wd.attribute(1),

        /**
         * Returns all tweens associated with current timeline.
         *
         * @readonly tweens {webDoodling.TweenCollection}
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        tweens: wd.readonly(),

        /**
         * The field `autoPlay` can be set during object initialization. If it is set to `true`
         * timeline starts playing immediately otherwise it remains in paused state.
         *
         * @field {boolean} autoPlay
         * @default true
         *
         * @example
         * var timeline = new wd.Timeline();
         * timeline.autoPlay = true;
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        autoPlay: wd.attribute(true),

        /**
         * Returns `true` if timeline is currently playing otherwise `false`.
         *
         * @readonly {Boolean} isPlaying
         * @default false
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        isPlaying: wd.readonly(true),

        /**
         * Returns `true` if current frame is on the last frame of timeline otherwise `false`.
         *
         * @readonly {Boolean} isLastFrame
         * @default false
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        isLastFrame: wd.readonly({
            get: function () {
                return this._frame === this._totalFrames;
            }
        }),

        /**
         * Returns `true` if current frame is on the first frame of timeline otherwise `false`.
         *
         * @readonly {Boolean} isFirstFrame
         * @default false
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        isFirstFrame: wd.readonly({
            get: function () {
                return this._frame === 1;
            }
        }),

        /**
         * Represents a callback which is invoked everytime, timeline is updated with new value.
         * The default value `false` indicates that no callback is registered yet and hence nothing
         * to be invoked.
         *
         * Callback is invoked under the context of current instance of `webDoodling.Timeline`. That means
         * when `this` inside this function would represent running instance of `webDoodling.Timeline`.
         *
         * @callback onFrame
         * @param {number} frame The current frame in timeline.
         *
         * @example
         * //TODO: Recheck the example
         * var timeline = new wd.Timeline();
         * timeline.onFrame = function (frame) {
         *      if (frame === 10) {
         *          this.pause();
         *      }
         * }
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        onFrame: false,

        /**
         * Initializes the new instance of `webDoodling.Timeline`.
         *
         * @constructor init(o)
         * @param {object} o The initialization object.
         *
         * @constructor init(tweens)
         * @param {Array(webDoodling.Tween)} tweens The tween objects in array will be appended into timeline's `tweens` collection.
         *
         * @constructor init(scene)
         * @param {webDoodling.Scene} scene The scene to which this timeline object is associated with.
         *
         * @example
         * //TODO: Recheck the example
         * var timeline = new wd.Timeline({
         *      repeat: 0,
         *      autoPlay: true,
         *      tweens: [
         *          wd.Tween(obj, "x", 100, 1, 30, "linear")
         *      ]
         * });
         *
         * var tween1 = new wd.Tween(obj, "x", 100, 1, 30, "quadIn"),
         *     tween2 = new wd.Tween(obj, "radius", "+10", 1, 30),
         *     timeline = new wd.Timeline([tween1, tween2]);
         *
         * var scene, timeline;
         * scene = new wd.Scene(canvas, {
         *     children: [
         *          wd.Circle({
         *              x: 20,
         *              y: 20,
         *              radius: 50
         *          })
         *     ]
         * });
         * timeline = new wd.Timeline(scene);
         *
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                self = this;

            this._keyframes = [];
            this._frames = {};
            this._currentFrame = 1;
            this._compiled = false;
            this._startMap = {};
            this._repeatCount = 0;
            this._tweens = new wd.TweenCollection();

            this.base();

            this.serializables("repeat", "tweens", "autoPlay");

            this._tweens.itemAdd(function (e) {
                self._onAdd(e);
            });

            if (wd.is.plainObject(arg1)) {
                this.deserialize(arg1);
            }
            //Remove array concept
            else if(wd.is.array(arg1)) {
                this.add(arg1);
            }
            else if (arg1 instanceof wd.Scene) {
                this._scene = arg1;
            }

            if (!this.autoPlay) {
                this.pause();
            }
        },

        /**
         * Adds the Tween or an Array of Tween to the timeline.
         *
         * @function add(tween)
         * @param {wd.Tween} tween The webDoodling.Tween object which contains instructions for animating object.
         *
         * @function add(arrayOfTween)
         * @param {Array} arrayOfTween
         *
         * @example
         * //TODO: Recheck example
         * var scene, tween1, tween2;
         * scene = wd.Scene(canvas, {
         *      children: [
         *          wd.Circle({
         *              id: "circle"
         *              x: 20,
         *              y: 20,
         *              radius: 50
         *          })
         *      ],
         *      timeline: {
         *          repeat: 0,
         *          tweens: [
         *              wd.Tween("circle", "radius", "+10", 1, 30)
         *          ]
         *      }
         * });
         * tween1 = new wd.Tween(scene.get("circle"), "x", 50, 1, 30, "linear");
         * scene.timeline.add(tween1);
         *
         * tween2 = new wd.Tween(scene.get("circle"), "y", 50, 1, 30, "quadIn");
         * scene.timeline.add(tween1, tween2);
         *
         * @returns {webDoodling.Timeline} The current object, useful for chaining.
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        add: function add() {
            this._tweens.add.apply(this._tweens, arguments);
            return this;
        },

        /**
         * Updates the scene with current display object states and advances
         * the frame to the next frame.
         *
         * @function update()
         * @returns {boolean} `true` if scene need to be updated else `false`.
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        update: function update() {

            var totalFrames = this._totalFrames,
                frame;

            // Timeline is not currently playing.
            if (this._isPlaying !== true) {
                return false;
            }

            //If timeline has already been played for more then
            //required repeatation, dont update any more.
            if (this.repeat > 0) {
                if (this._repeatCount >= this.repeat) {
                    return false;
                }
            }

            //No tweens, no frames hence no update.
            if (totalFrames === 0) {
                return false;
            }

            // Timeline needs to be compiled before it is used,
            //if not compiled do it now.
            if (this._compiled === false) {
                this._compile();
            }

            frame = this._frame;
            this._updateValues(frame);

            if (this.onFrame) {
                this.onFrame(frame);
            }

            //Increment the repeat count if on last frame.
            // This doesnt consider new frame if set
            //withing onFrame.
            if (frame === this._totalFrames) { //On last frame
                this._repeatCount += 1;
            }

            //Check if frame has changed within onFrame function
            //if not changed process otherwise ignore.
            if (frame === this._frame) {
                if (frame === this._totalFrames) { //On last frame
                    this._frame = 1;
                }
                else {
                    this._frame++;
                }
            }
            return true;
        },

        /**
         * Plays the timeline if it is not currently paused.
         *
         * @function play()
         *
         * @example
         * //TODO: Recheck example
         * var scene, tween1, tween2;
         * scene = wd.Scene(canvas, {
         *      children: [
         *          wd.Circle({
         *              id: "circle"
         *              x: 20,
         *              y: 20,
         *              radius: 50
         *          })
         *      ],
         *      timeline: {
         *          repeat: 0,
         *          tweens: [
         *              wd.Tween("circle", "radius", "+10", 1, 30)
         *          ]
         *      }
         * });
         * scene.timeline.pause();
         *
         * scene.timeline.play();
         *
         * @returns {webDoodling.Timeline} Current object useful for chaining.
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        play: function play() {
            this._isPlaying = true;
            return this;
        },

        /**
         * Pauses the timeline animation, which can be resumed by `play` method.
         *
         * @function pause()
         *
         * @example
         * //TODO: Recheck example
         * var scene, tween1, tween2;
         * scene = wd.Scene(canvas, {
         *      children: [
         *          wd.Circle({
         *              id: "circle"
         *              x: 20,
         *              y: 20,
         *              radius: 50
         *          })
         *      ],
         *      timeline: {
         *          repeat: 0,
         *          tweens: [
         *              wd.Tween("circle", "radius", "+10", 1, 30)
         *          ]
         *      }
         * });
         * scene.timeline.pause();
         *
         * @returns {webDoodling.Timeline} The current object useful for chaining.
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            this._isPlaying = false;
            return this;
        },

        /**
         * Go to the specified frame and starts playing timeline
         * if it is not already playing.
         *
         * @function gotoAndPlay(postion)
         * @param {number} frame The frame number, must be in the range of available frames.
         *
         * @example
         * //TODO: Recheck example
         * var scene, tween1, tween2;
         * scene = wd.Scene(canvas, {
         *      children: [
         *          wd.Circle({
         *              id: "circle"
         *              x: 20,
         *              y: 20,
         *              radius: 50
         *          })
         *      ],
         *      timeline: {
         *          repeat: 0,
         *          tweens: [
         *              wd.Tween("circle", "radius", "+10", 1, 30)
         *          ]
         *      }
         * });
         * scene.timeline.gotoAndPlay(15);
         *
         * @returns {webDoodling.Sprite} The current object useful for chaining.
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        gotoAndPlay: function gotoAndPlay(frame) {
            this._frame = Math.max(1, Math.min(parseInt(frame, 10), this._totalFrames));
            this._isPlaying = true;
            return this;
        },

        /**
         * Go to the specified frame and pauses playing timeline
         * if it is already playing.
         *
         * @function gotoAndPause(postion)
         * @param {number} frame The frame number, must be in the range of available frames.
         *
         * @example
         * //TODO: Recheck example
         * var scene, tween1, tween2;
         * scene = wd.Scene(canvas, {
         *      children: [
         *          wd.Circle({
         *              id: "circle"
         *              x: 20,
         *              y: 20,
         *              radius: 50
         *          })
         *      ],
         *      timeline: {
         *          repeat: 0,
         *          tweens: [
         *              wd.Tween("circle", "radius", "+10", 1, 30)
         *          ]
         *      }
         * });
         * scene.timeline.gotoAndPause(15);
         *
         * @returns {webDoodling.Sprite} The current object useful for chaining.
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        gotoAndPause: function gotoAndPause(frame) {
            this._isPlaying = false;
            this._frame = Math.max(1, Math.min(parseInt(frame, 10), this._totalFrames));
            this._updateValues(this.frame);
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Timeline].
         *
         * @memberOf webDoodling.Timeline
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Timeline]";
        },

        //Invoked whenever new tween is added into the timeline.
        _onAdd: function (e) {
            var tween = e.item;

            if (this._compiled === true) {
                //Dont add new keyframe after compilation, just ignore and return.
                throw new wd.Error("wd-timeline-immutable");
            }
            // This._keyframes.push(tween);
            this._totalFrames = Math.max(tween.stop, this._totalFrames);
            this._startMap = this._startMap || {};
            this._startMap[tween.start] = this._startMap[tween.start] || [];
            this._startMap[tween.start].push(tween);
        },

        //Compiles the timeline into the cached frames which help improve performance.
        _compile: function () {
            var totalFrames = this._totalFrames,
                tween, tweens,
                i, iLen, frameIndex, f,
                frame,
                newFrames,
                self = this,
                intialVals = [];

            //Updates the objects value at given frame.
            function _updateValues(frameNo) {
                var frame = self._frames[frameNo - 1],
                    i, itemCount, item,
                    tag;

                if (frame !== undefined) {
                    for (i = 0, itemCount = frame.length; i < itemCount; i += 1) {
                        item = frame[i];
                        tag = item.key + "__processed";
                        if (tag in item.item === false) {
                            intialVals.push({
                                item: item.item,
                                key: item.key,
                                value: item.item[item.key]
                            });
                            item.item[tag] = true;
                        }
                        item.item[item.key] = item.value;
                    }
                }
            }

            //Reset the objects to its initial state.
            function reset() {
                var item, i, iLen, tag;
                //Reset to original values
                for(i=0, iLen=intialVals.length; i < iLen; i += 1) {
                    item = intialVals[i];
                    item.item[item.key] = item.value;
                    tag = item.key + "__processed";
                    delete item.item[tag];
                }
            }

            for(i=0; i < totalFrames; i += 1) {
                frame  = i + 1;
                // Check tween at current frame. If found compile it.
                tweens = this._startMap[frame];
                _updateValues(frame);

                if (tweens !== undefined) {
                    for (frameIndex = 0; frameIndex < tweens.length; frameIndex++) {
                        tween = tweens[frameIndex];
                        //Keyframe found at current frame.
                        if (tween !== undefined) {
                            if (tween.processed) {
                                continue;
                            }
                            tween._scene = this._scene;
                            tween._timeline = this;
                            newFrames = tween.getFrames();

                            //Starting from current frame, inject new frames
                            //into frames array.
                            for (i = 0, iLen = newFrames.length; i < iLen; i++) {
                                for (var j = 0, jLen = newFrames[i].length; j < jLen; j++) {
                                    var framePos = frame + j - 1;
                                    f = this._frames[framePos] || [];
                                    f.push(newFrames[i][j]);
                                    this._frames[framePos] = f;
                                }
                            }
                            tween.processed = true;
                        }
                    }
                }
            }
            reset();
            this._compiled = true;
        },

        //Updates the associated objects value.
        _updateValues: function (frameNo) {
            var frame = this._frames[frameNo - 1],
                i, itemCount, item;

            if (frame !== undefined) {
                for (i = 0, itemCount = frame.length; i < itemCount; i += 1) {
                    item = frame[i];
                    item.item[item.key] = item.value;
                }
            }
        }
    }, wd.Serializable);
    wd.Timeline = Timeline;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Animator
(function (wd, undefined) {
    "use strict";
    var Animator;

    /**
     * Represents a `webDoodling.Animator` that animates the display objects. This class is used by
     * `DisplayObject.animate` method. It allows animation to play only once along with other
     * control features like `pause`.
     *
     * @class webDoodling.Animator
     * @example
     * var rect = wd.Rectangle({
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 200,
     *     styles: [
     *         webDoodling.Fill('red')
     *     ]
     * });
     *
     * var animation = rect.animate("x", 200); //rect.animation function return animator object.
     *
     * //Pause the animation;
     * animation.puase();
     *
     * //Replay animation again.
     * animation.play();
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    Animator = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Animator`, always returns 'Animator'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        type: wd.type("Animator"),

        /**
         * Represents the callback function which is invoked while animation is completed.
         *
         * @callback onComplete
         * @example
         * var rect = wd.Rectangle({
         *     x: 100,
         *     y: 100,
         *     width: 200,
         *     height: 200,
         *     styles: [
         *         webDoodling.Fill('red')
         *     ]
         * });
         *
         * var animation = rect.animate("x", 200, function () {
         *      x: 300
         * });
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        onComplete: wd.attribute(false),

        /**
         * Returns the position of the `webDoodling.Animator`.
         *
         * @readonly {number} position
         * @default 1
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        position: wd.readonly(1),

        /**
         * Returns whether animation is playing or not, `true` if animation is palying otherwise `false`.
         *
         * @readonly {boolean} isPlaying
         * @default `false`
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        isPlaying: wd.readonly(false),

        /**
         * Returns whether animation has been stopped after play or not. `true` if animation has been
         * stoped else `false`. Stopped animation can not be replayed.
         *
         * @readonly {boolean} isStopped
         * @default `false`
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        isStopped: wd.readonly(false),

        /**
         * Initializes the new instance of `webDoodling.Animator`.
         *
         * @constructor init(scene, tween, autoStart, scope)
         * @param  {webDoodling.scene} scene The scene to which this animation is bound to.
         * @param  {webDoodling.tween} tween The tween object which describes animation parameters.
         * @param  {[boolean]} autoStart If set to true starts animation immediately. Default is `true`.
         * @param  {[function]} scope The scope in which animation loop run and any callback should occur. Default is current object.
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        init: function init(scene, tween, autoStart, scope) {
            var start = tween.start,
                length = tween.length,
                totalLength = start + length - 1,
                frames = tween.getFrames(),
                objLength = frames.length,
                self = this, i,
                loop;

            autoStart = (autoStart === undefined) ? true: autoStart;
            scope = scope || self;
            this._scene = scene;
            this._position = 1;

            loop = function animatorLoop() {
                if (self._isPlaying === false) {
                    return;
                }
                if (self._position < start) {
                    self._position++;
                    return;
                }

                if (self._position >= totalLength) {
                    self.stop();
                    if (wd.is.func(self.onComplete)) {
                        self.onComplete.call(scope);
                    }
                    return;
                }

                for (i = 0; i < objLength; i++) {
                    var obj = frames[i][self._position - start];
                    obj.item[obj.key] = obj.value;
                }
                scene.update();


                self._position++;
            };

            scene.on("animationloop", loop);
            this._frames = frames;
            this._loop = loop;

            if (autoStart) {
                this.play();
            }
        },

        /**
         * Starts playing the animation if it is paused or not yet started.
         *
         * @function play()
         * @example
         * var rect = wd.Rectangle({
         *     x: 100,
         *     y: 100,
         *     width: 200,
         *     height: 200,
         *     styles: [
         *         webDoodling.Fill('red')
         *     ]
         * });
         *
         * var animation = rect.animate("x", 200); //rect.animation function return animator object.
         *
         * //Pause the animation;
         * animation.puase();
         *
         * //Replay animation again.
         * animation.play();
         *
         * @returns {webDoodling.Animator} The current object useful for chaining.
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        play: function play() {
            if (!this._isStopped) {
                this._isPlaying = true;
            }
            return this;
        },

        /**
         * Pauses the animation if it is currently playing. Paused animations
         * can be resumed by play method.
         *
         * @function pause()
         * @example
         * var rect = wd.Rectangle({
         *     x: 100,
         *     y: 100,
         *     width: 200,
         *     height: 200,
         *     styles: [
         *         wd.Fill('red')
         *     ]
         * });
         *
         * var animation = rect.animate("x", 200); //rect.animation function return animator object.
         *
         * //Pause the animation;
         * animation.pause();
         *
         * //Replay animation again.
         * animation.play();
         *
         * @returns {webDoodling.Animator} The current object useful for chaining.
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            if (!this._isStopped) {
                this._isPlaying = false;
            }
            return this;
        },

        /**
         * Pauses the animation if it is currenly playing. Paused animations
         * can be resumed by play method.
         *
         * @function stop()
         * @example
         * var rect = wd.Rectangle({
         *     x: 100,
         *     y: 100,
         *     width: 200,
         *     height: 200,
         *     styles: [
         *         wd.Fill('red')
         *     ]
         * });
         *
         * var animation = rect.animate("x", 200); //rect.animation function return animator object.
         *
         * animation.play();
         *
         * animation.stop();
         *
         * @returns {webDoodling.Animator} The current object useful for chaining.
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        stop: function stop() {
            this._scene.update();
            this._isStopped = true;
            this._isPlaying = false;
            this._scene.off("animationLoop", this._loop);
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Animator].
         *
         * @memberOf webDoodling.Animator
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Animator]";
        }
    });

    wd.Animator = Animator;

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Filters
(function (wd) {
    "use strict";

    var Filter;

    /**
     * Provides the base class for Filters in `webDoodling.Filter`.
     *
     * @class webDoodling.Filter
     *
     * @extends webDoodling.Filter
     * @public
     * @version 1.0
     **/
    Filter = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Filter`, always returns 'Filter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Filter
         * @public
         * @version 1.0
         **/
        type: wd.type("Filter"),

        /**
         * Represents the `id` of the current object.
         *
         * @field {string} id
         *
         * @memberOf webDoodling.Filter
         * @public
         * @version 1.0
         **/
        id: wd.attribute(),

        /**
         * Gets the object of type `webDoodling.Tweenables` which contains a list of
         * tweenable members for `webDoodling.Style`.
         *
         * @readonly {webDoodling.Tweenables} tweenables
         *
         * @memberOf webDoodling.Style
         * @public
         * @version 1.0
         **/
        filters: wd.readonly(),


        // Initializes the new instance of `webDoodling.Filter`.
        init: function () {
            this.base();
            this.serializables("id");
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Filter].
         *
         * @memberOf webDoodling.Filter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Filter]";
        }

    }, wd.Serializable);

    wd.Filter = Filter;
})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Asset Collection
(function (wd, undefined) {
    "use strict";

    var FilterCollection;

    /**
     * Represent the `webDoodling.FilterCollection`.
     *
     * @class webDoodling.FilterCollection
     *
     * @extends webDoodling.Collection
     * @public
     * @version 1.0
     **/
    FilterCollection = wd.Class({

        /**
         * Returns the `type` of `webDoodling.FilterCollection`,
         * always returns 'FilterCollection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.FilterCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("FilterCollection"),

        /**
         * Returns the `filterable` source of the `webDoodling.FilterCollection`.
         *
         * @readonly {webDoodling.Image} filterable
         *
         * @memberOf webDoodling.filterableFilter
         * @public
         * @version 1.0
         **/
        source: wd.property({
            get: function () {
                return this._source;
            },
            set: function (v) {
                this._source = v;
                this._ready = false;
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.FilterCollection`.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.FilterCollection
         * @public
         * @version 1.0
         **/
        init: function init() {
            var self = this;
            this.base();

            this.onValidate = function (obj) {
                if (obj instanceof wd.Filter === false) {
                    throw new wd.Error("wd-invalid-argument", obj);
                }
                obj._filters = self;
                return null;
            };

            this._ready = false;
        },

        /** property the filters
         * @return {[type]} [description]
         **/
        apply: function apply() {

            var i, iLen,
                filter,
                typedArraySupported,
                buf, buf8, data,
                setPixel,
                canvas, context,
                filters,
                width, height,
                isLittleEndian,
                imageData;

            if (this._ready === false) {
                this._setupCanvas();
            }

            iLen = this.length;
            canvas = this._sourceCanvas;
            context = this._sourceContext;
            filters = this._items;
            width = canvas.width;
            height = canvas.height;
            isLittleEndian = true;
            imageData = context.getImageData(0, 0, width, height);

            try {
                //new xyz();
                buf = new ArrayBuffer(imageData.data.length);
                buf8 = new Uint8ClampedArray(buf);
                data = new Uint32Array(buf);

                // Determine whether Uint32 is little-endian or big-endian.
                data[1] = 0x0a0b0c0d;

                //var isLittleEndian = true;
                if (buf[4] === 0x0a && buf[5] === 0x0b && buf[6] === 0x0c &&
                    buf[7] === 0x0d) {
                    isLittleEndian = false;
                    setPixel = function (index, r, g, b, a) {

                        // Clamp values in 0 to 255 range
                        r = (r < 0) ? 0 : (r > 255) ? 255 : r;
                        g = (g < 0) ? 0 : (g > 255) ? 255 : g;
                        b = (b < 0) ? 0 : (b > 255) ? 255 : b;
                        a = (a < 0) ? 0 : (a > 255) ? 255 : a;

                        data[index / 4] =
                            (r << 24) |    // red
                            (g << 16) |    // green
                            (b <<  8) |    // blue
                             a;            // alpha
                    };
                }
                else {
                    setPixel = function (index, r, g, b, a) {

                        // Clamp values in 0 to 255 range
                        r = (r < 0) ? 0 : (r > 255) ? 255 : r;
                        g = (g < 0) ? 0 : (g > 255) ? 255 : g;
                        b = (b < 0) ? 0 : (b > 255) ? 255 : b;
                        a = (a < 0) ? 0 : (a > 255) ? 255 : a;

                        data[index / 4] =
                            (a << 24)  |    // alpha
                            (b << 16)  |    // blue
                            (g <<  8) |    // green
                            r;              // red
                    };
                }
                typedArraySupported = true;
            }
            catch (e) {
                typedArraySupported = false;
                data = imageData.data;
                setPixel = function (index, r, g, b, a) {
                    data[index]     = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = a;
                };
            }

            for (i = 0; i < iLen; i += 1) {

                filter = filters[i];
                filter.setPixel = setPixel;
                imageData = filter.filter(context, imageData, {
                    typedArraySupported: typedArraySupported,
                    isLittleEndian: isLittleEndian
                });
                delete filter.setPixel;
                if (typedArraySupported) {
                    imageData.data.set(buf8);
                }
            }
            context.putImageData(imageData, 0, 0);
            this._notifyUpdate();
            return this;
        },

        /**
         * Reverse the effect filters and resets the image to its original state.
         * @return {[type]} [description]
         */
        reset: function reset() {
            var canvas,
                context,
                w, h;

            // There is no need to reset when source canvas
            // does not exist.
            if (this._sourceCanvas === undefined) {
                return;
            }

            canvas = this._sourceCanvas;
            context = canvas.getContext("2d");
            w = canvas.width;
            h = canvas.height;

            // document.body.appendChild(canvas);

            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, w, h);
            context.drawImage(this._source, 0, 0, w, h, 0, 0, w, h);
            this._notifyUpdate();
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [webDoodling.FilterCollection]
         *
         * @memberOf webDoodling.FilterCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.FilterCollection]";
        },

        _setupCanvas: function () {
            //Sets the orignal source.
            var canvas = document.createElement("canvas"),
                context = canvas.getContext("2d"),
                w = this._source.width,
                h = this._source.height;

            canvas.width = w;
            canvas.height = h;
            context.drawImage(this._source, 0, 0, w, h, 0, 0, w, h);
            this._sourceCanvas = canvas;
            this._sourceContext = context;
            this._ready = true;
        },

        _notifyUpdate: function () {
            if (this.onUpdate) {
                this.onUpdate(this._sourceCanvas);
            }
        }

    }, wd.Collection);

    wd.FilterCollection = FilterCollection;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Brighten Filter
(function (wd) {
    "use strict";

    var BrightenFilter;

    /**
     * Represent the `webDoodling.BrightenFilter`.
     *
     * @class webDoodling.BrightenFilter
     *
     * @example
     * wd.Image({
     *   x: 0,
     *   y: 0,
     *   keepOriginal: true,
     *   source: "../(media)/img/boat.png",
     *   filters: [
     *      wd.BrightenFilter(-150),
     *   ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    BrightenFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.BrightenFilter`, always returns 'BrightenFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.BrightenFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("BrightenFilter"),

        /**
         * Gets or sets the amount of brightness required for this filter.
         *
         * @field {number} amount
         * @default 10
         * Range from -150 to 150
         *
         * @memberOf webDoodling.BrightenFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.max(Math.min(v, 150), -150);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.BrightenFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var brightenFilter1 = new webDoodling.BrightenFilter(10);
         *
         * // Initialize object.
         * var brightenFilter2 = new webDoodling.BrightenFilter({
         *    id: 'brighten-filter2',
         *    amount: 10
         * });
         *
         * var brightenFilter3 = new webDoodling.BrightenFilter();
         * brightenFilter3.amount = 30;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of brightness for brighten filter.
         *
         * @memberOf webDoodling.BrightenFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();

            var arg = arguments[0];
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for brighten effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @param {context} ctx The 2D context of canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.BrightenFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                brightness = this.amount,
                adjustment = brightness,
                x, y, r, g, b, a, index;

            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = Math.min(Math.max(data[index] + adjustment, 0), 255);
                    g = Math.min(Math.max(data[index + 1] + adjustment, 0), 255);
                    b = Math.min(Math.max(data[index + 2] + adjustment, 0), 255);
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.BrightenFilter].
         *
         * @memberOf webDoodling.BrightenFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.BrightenFilter]";
        }


    }, wd.Filter);

    wd.BrightenFilter = BrightenFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Color Filter
(function (wd, undefined) {
    "use strict";

    var ColorFilter;

    /**
     * Represent the `webDoodling.ColorFilter`.
     *
     * @class webDoodling.ColorFilter
     *
     * @example
     * wd.Image({
     *     x: 0,
     *     y: 0,
     *     keepOriginal: true,
     *     source: "../(media)/img/boat.png",
     *     filters: [
     *         wd.ColorFilter('rgb(100,90,5)'),
     *     ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    ColorFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ColorFilter`, always returns 'ColorFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ColorFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("ColorFilter"),

        /**
         * Gets or sets the amount of red required for this filter.
         *
         * @field {number} red
         * @default 10
         * Range from 0 to 255
         *
         * @memberOf webDoodling.ColorFilter
         * @public
         * @version 1.0
         **/
        r: wd.property({
            value: 10,
            get: function () {
                return this._r;
            },
            set: function (v) {
                this._r = Math.min(Math.max(v, 0), 255);
            }
        }),

        /**
         * Gets or sets the amount of green required for this filter.
         *
         * @field {number} green
         * @default 10
         * Range from 0 to 255
         *
         * @memberOf webDoodling.ColorFilter
         * @public
         * @version 1.0
         **/
        g: wd.property({
            value: 10,
            get: function () {
                return this._g;
            },
            set: function (v) {
                this._g = Math.min(Math.max(v, 0), 255);
            }
        }),

        /**
         * Gets or sets the amount of blue required for this filter.
         *
         * @field {number} blue
         * @default 10
         * Range from 0 to 255
         *
         * @memberOf webDoodling.ColorFilter
         * @public
         * @version 1.0
         **/
        b: wd.property({
            value: 10,
            get: function () {
                return this._b;
            },
            set: function (v) {
                this._b = Math.min(Math.max(v, 0), 255);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.ColorFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var colorFilter1 = new webDoodling.ColorFilter('rgb(20, 100, 120)');
         *
         * // Initialize object.
         * var colorFilter2 = new webDoodling.ColorFilter({
         *    id: 'color-filter2',
         *    r: 10,
         *    g: 150,
         *    b: 100
         * });
         *
         * var colorFilter3 = new webDoodling.ColorFilter();
         * colorFilter3.r = 40;
         * colorFilter3.g = 120;
         * colorFilter3.b = 200;
         *
         * @constructor init(rgb)
         * @param {string} rgb Represent the CSS color format.
         *
         * @memberOf webDoodling.ColorFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                argLen = arguments.length,
                rgb;

            this.base();
            this.serializables("r", "g", "b");
            if (argLen === 1) {
                if(wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                }
                else {
                    //CSS Color
                    rgb = new wd.Color(arg1),
                    this.r = rgb.r;
                    this.g = rgb.g;
                    this.b = rgb.b;
                }
            }
            else {
                if (arg1 !== undefined) this.r = arg1;
                if (arg2 !== undefined) this.g = arg2;
                if (arg3 !== undefined) this.b = arg3;
            }
        },


        /**
         * Returs the filtered image data after processing for color effect.
         *
         * @function filter(ctx, imageData)
         * @param {context} ctx The 2D context of the canvas.
         * @param {number} imageData The image data to be proecessed for the color effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ColorFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                er = this.r, eg = this.g, eb = this.b,
                p1 = 0.99, p2 = 0.99, p3 = 0.99,
                x, y, r, g, b, a, index;

            for(y = 0; y < sh; y += 1){
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = data[index] * p1 + er;
                    g = data[index + 1] * p2 + eg;
                    b = data[index + 2] * p3 + eb;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ColorFilter].
         *
         * @memberOf webDoodling.ColorFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ColorFilter]";
        }


    }, wd.Filter);

    wd.ColorFilter = ColorFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Gray Scale Filter
(function (wd) {
    "use strict";

    var GrayScaleFilter;

    /**
     * Represent the `webDoodling.GrayScaleFilter`.
     *
     * @class webDoodling.GrayScaleFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.GrayScaleFilter(10)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    GrayScaleFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.GrayScaleFilter`, always returns 'GrayScale'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.GrayScaleFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("GrayScaleFilter"),

        /**
         * Gets or sets the amount of gray required for this filter.
         *
         * @field {number} amount
         * @default 10
         * Range from 0 to 100
         *
         * @memberOf webDoodling.GrayScaleFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 100);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.GrayScaleFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var grayFilter1 = new webDoodling.GrayScaleFilter(10);
         *
         * // Initialize object.
         * var grayFilter2 = new webDoodling.GrayScaleFilter({
         *    id: 'gray-filter2',
         *    amount: 10
         * });
         *
         * var grayFilter3 = new webDoodling.GrayScaleFilter();
         * grayFilter3.amount = 50;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of gray for gray filter.
         *
         * @memberOf webDoodling.GrayScaleFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for gray effect.
         *
         * @function filter(ctx, imageData)
         * @param {context} ctx The 2D context of the canvas.
         * @param {number} imageData The image data to be proecessed for the gray effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.GrayScaleFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                amount = this.amount,
                brightness, x, y, index, r, g, b, a;

            //brightness is based on the fact that humans are most sensitive to the green light followed by the red
            //light and then least sensitive to the blue light..
            amount /= 100;

            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    brightness = (0.34 + amount) * data[index] + (0.5 + amount) * data[index + 1] + (0.16 + amount) * data[index + 2];
                    r = brightness;
                    g = brightness;
                    b = brightness;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.GrayScaleFilter].
         *
         * @memberOf webDoodling.GrayScaleFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.GrayScaleFilter]";
        }
    }, wd.Filter);

    wd.GrayScaleFilter = GrayScaleFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Invert Filter
(function (wd) {
    "use strict";

    var InvertFilter;

    /**
     * Represent the `webDoodling.InvertFilter`.
     *
     * @class webDoodling.InvertFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.InvertFilter(5)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    InvertFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.InvertFilter`, always returns 'Invert'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.InvertFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("InvertFilter"),

        /**
         * Gets or sets the amount of level required for this  invert filter.
         *
         * @field {number} amount
         * @default 10
         * Range from 0 to 100
         *
         * @memberOf webDoodling.InvertFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 100);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.InvertFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var invertFilter1 = new webDoodling.InvertFilter(10);
         *
         * // Initialize object.
         * var invertFilter2 = new webDoodling.InvertFilter({
         *    id: 'invert-filter2',
         *    amount: 10
         * });
         *
         * var invertFilter3 = new webDoodling.InvertFilter();
         * invertFilter3.amount = 50;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of color invert for invert filter.
         *
         * @memberOf webDoodling.InvertFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for invert effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the invert effect.
         * @param {context} ctx The 2D context of canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.InvertFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                amount = this.amount,
                x, y, index, r, g, b, a;

            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = 255 - data[index] + amount;
                    g = 255 - data[index + 1] + amount;
                    b = 255 - data[index + 2] + amount;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.InvertFilter].
         *
         * @memberOf webDoodling.InvertFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.InvertFilter]";
        }
    }, wd.Filter);

    wd.InvertFilter = InvertFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Sharpen Filter
(function (wd) {
    "use strict";

    var SharpenFilter;

    /**
     * Represent the `webDoodling.SharpenFilter`.
     *
     * @class webDoodling.SharpenFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.SharpenFilter(100)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    SharpenFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.SharpenFilter`, always returns 'SharpenFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.SharpenFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("SharpenFilter"),

        /**
         * Gets or sets the amount of level required for this filter.
         *
         * @field {number} amount
         * @default 10
         *
         * @memberOf webDoodling.SharpenFilter
         * @public
         * @version 1.0
         **/
        amount: wd.attribute(10),

        /**
         * Initializes the new instance of the `webDoodling.SharpenFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var sharpenFilter1 = new webDoodling.SharpenFilter(20);
         *
         * // Initialize object.
         * var sharpenFilter2 = new webDoodling.SharpenFilter({
         *    id: 'sharpen-filter2',
         *    amount: 40
         * });
         *
         * var sharpenFilter3 = new webDoodling.SharpenFilter();
         * sharpenFilter3.amount = 50;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of sharpness for sharpen filter.
         *
         * @memberOf webDoodling.SharpenFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for sharpen effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the sharpen effect.
         * @param {context} ctx The 2D context of canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.SharpenFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var amount = this.amount * 0.1,
                src, sw, sh, matrix, side, halfside, obaque, sy, sx, dstoff, r, g, b,
                a, srcoff, wt, output, alphafun, y, x, cy, cx, scx, scy, dr, dg, db, da;

            src = imageData.data;
            sw = imageData.width;
            sh = imageData.height;
            matrix = [0, -1, 0,
                      -1, 5, -1,
                       0, -1, 0];
            side = Math.round(Math.sqrt(matrix.length));
            halfside = Math.floor(side / 2);
            obaque = false;
            output = ctx.createImageData(sw,sh);
            //dst = output.data;
            alphafun = (obaque) ? 1 : 0;
            for(y = 0; y < sh ; y += 1){
                for(x = 0; x < sw; x += 1){
                    sy = y;
                    sx = x;
                    dstoff = (y * sw + x) * 4;
                    r = 0;
                    g = 0;
                    b = 0;
                    a = 0;
                    for(cy = 0; cy < side; cy += 1){
                        for(cx = 0; cx < side; cx += 1){
                            scy = sy + cy - halfside;
                            scx = sx + cx - halfside;
                            if(scy >= 0 && scy < sh && scx >= 0 && scx < sw){
                                srcoff = (scy * sw + scx) * 4;
                                wt = matrix[cy * side + cx];
                                r += src[srcoff] * wt;
                                g += src[srcoff + 1] * wt;
                                b += src[srcoff + 2] * wt;
                                a += src[srcoff + 3] * wt;
                            }
                        }
                    }
                    dr = r * amount + src[dstoff] * (1 - amount);
                    dg = g * amount + src[dstoff + 1] * (1 - amount);
                    db = b * amount + src[dstoff + 2] * (1 - amount);
                    da = a + alphafun * (255 - a);
                    this.setPixel(dstoff, dr, dg, db, da);
                }
            }
            return output;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.SharpenFilter].
         *
         * @memberOf webDoodling.SharpenFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.SharpenFilter]";
        }
    }, wd.Filter);

    wd.SharpenFilter = SharpenFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Sobel Filter
(function (wd) {
    "use strict";

    var SobelFilter;

    /**
     * Represent the `webDoodling.SobelFilter`.
     *
     * @class webDoodling.SobelFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.SobelFilter(80)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    SobelFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.SobelFilter`, always returns 'SobelFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.SobelFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("SobelFilter"),

        /**
         * Gets or sets the amount of threshold required for this filter.
         *
         * @field {number} threshold
         * @default 10
         *
         * @memberOf webDoodling.SobelFilter
         * @public
         * @version 1.0
         **/
        threshold: wd.attribute(10),

        /**
         * Initializes the new instance of the `webDoodling.SobelFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var sobelFilter1 = new webDoodling.SobelFilter(20);
         *
         * // Initialize object.
         * var sobelFilter2 = new webDoodling.SobelFilter({
         *    id: 'sobel-filter2',
         *    threshold: 40
         * });
         *
         * var sobelFilter3 = new webDoodling.SobelFilter();
         * sobelFilter3.threshold = 50;
         *
         * @constructor init(threshold)
         * @param {number} threshold The amount of edge detection for sobel filter.
         *
         * @memberOf webDoodling.SobelFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("threshold");

            if (wd.is.number(arg)) {
                this.threshold = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for edge detection or sobel effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the sobel effect.
         * @param {context} ctx The 2D context of canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.SobelFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                threshold = this.threshold / 100,
                r, g, b, a, brightness, i, iLen, grayData, verticle, horizontal,
                v, h, x, y, index, hData, vData;

            for(i = 0, iLen = data.length; i < iLen; i += 4) {
                brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
                data[i] = brightness;
                data[i + 1] = brightness;
                data[i + 2] = brightness;
            }
            grayData = ctx.getImageData(0, 0, sw, sh);
            ctx.putImageData(imageData, 0, 0);

            verticle = _convoluteFilter(ctx, grayData,
                                        [-1 * threshold, 0, 1 * threshold,
                                         -2 * threshold, 0, 2 * threshold,
                                         -1 * threshold, 0, 1 * threshold]);
            horizontal = _convoluteFilter(ctx, grayData,
                                          [-1 * threshold, -2 * threshold, -1 * threshold,
                                            0, 0, 0,
                                            1 * threshold, 2 * threshold, 1 * threshold]);
            hData = horizontal.data;
            vData = verticle.data;

            for (y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    v = Math.abs(vData[index]);
                    h = Math.abs(hData[index]);
                    r = v;
                    g = h;
                    b = (v + h) / 4;
                    a = 255;
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.SobelFilter].
         *
         * @memberOf webDoodling.SobelFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.SobelFilter]";
        }
    }, wd.Filter);

    wd.SobelFilter = SobelFilter;

    function _convoluteFilter(ctx, imageData, matrix) {
        var src, sw, sh, side, halfside, sy, sx, dstoff, r, g, b,
            a, srcoff, wt, output, dst, y, x, cy, cx, scx, scy;

        src = imageData.data;
        sw = imageData.width;
        sh = imageData.height;
        side = Math.round(Math.sqrt(matrix.length));
        halfside = Math.floor(side / 2);
        output = ctx.createImageData(sw,sh);
        dst = output.data;
        for(y = 0; y < sh ; y += 1){
            for(x = 0; x < sw; x += 1){
                sy = y;
                sx = x;
                dstoff = (y * sw + x) * 4;
                r = 0;
                g = 0;
                b = 0;
                a = 0;
                for(cy = 0; cy < side; cy += 1){
                    for(cx = 0; cx < side; cx += 1){
                        scy = sy + cy - halfside;
                        scx = sx + cx - halfside;
                        if(scy >= 0 && scy < sh && scx >= 0 && scx < sw){
                            srcoff = (scy * sw + scx) * 4;
                            wt = matrix[cy * side + cx];
                            r += src[srcoff] * wt;
                            g += src[srcoff + 1] * wt;
                            b += src[srcoff + 2] * wt;
                            a += src[srcoff + 3] * wt;
                        }
                    }
                }
                dst[dstoff] = r;
                dst[dstoff + 1] = g;
                dst[dstoff + 2] = b;
                dst[dstoff + 3] = a;
            }
        }
        return output;
    }
})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Threshold Filter
(function (wd) {
    "use strict";

    var ThresholdFilter;

    /**
     * Represent the `webDoodling.ThresholdFilter`.
     *
     * @class webDoodling.ThresholdFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.ThresholdFilter(100)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    ThresholdFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ThresholdFilter`, always returns 'Thresholdimage'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ThresholdFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("ThresholdFilter"),

        /**
         * Gets or sets the amount of threshold required for this  Threshold filter.
         *
         * @field {number} amount
         * @default 10
         * Range from 0 to 255
         *
         * @memberOf webDoodling.ThresholdFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 255);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.ThresholdFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var thresholdFilter1 = new webDoodling.ThresholdFilter(10);
         *
         * // Initialize object.
         * var thresholdFilter2 = new webDoodling.ThresholdFilter({
         *    id: 'threshold-filter2',
         *    amount: 10
         * });
         *
         * var thresholdFilter3 = new webDoodling.ThresholdFilter();
         * thresholdFilter3.amount = 30;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of color for Threshold filter.
         *
         * @memberOf webDoodling.ThresholdFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for Threshold effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the Threshold effect.
         * @param {context} ctx The 2D context of canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ThresholdFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                amount = this.amount,
                threshold = amount, brightness, v, x, y, r, g, b, a, index;

            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    brightness = 0.34 * data[index] + 0.5 * data[index + 1] + 0.16 * data[index + 2];
                    v = (brightness >= threshold) ? 255 : 0;
                    r = g = b = v;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ThresholdFilter].
         *
         * @memberOf webDoodling.ThresholdFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ThresholdFilter]";
        }
    }, wd.Filter);

    wd.ThresholdFilter = ThresholdFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Channel Filter
(function (wd, undefined) {
    "use strict";

    var ToggleChannelFilter;

    /**
     * Represent the `webDoodling.ToggleChannelFilter`.
     *
     * @class webDoodling.ToggleChannelFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.ToggleChannelFilter(true, true, false)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    ToggleChannelFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ToggleChannelFilter`, always returns 'ToggleChannelFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ToggleChannelFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("ToggleChannelFilter"),

        /**
         * Gets or sets the red value of boolean true or false.
         *
         * @field {boolean} r
         * @default true
         * r values are true or false
         *
         * @memberOf webDoodling.ToggleChannelFilter
         * @public
         * @version 1.0
         **/
        r: wd.attribute(true),

        /**
         * Gets or sets the green value of boolean true or false.
         *
         * @field {boolean} g
         * @default true
         * g values are true or false
         *
         * @memberOf webDoodling.ToggleChannelFilter
         * @public
         * @version 1.0
         **/
        g: wd.attribute(true),

        /**
         * Gets or sets the blue value of boolean true or false.
         *
         * @field {boolean} b
         * @default true
         * b values are true or false
         *
         * @memberOf webDoodling.ToggleChannelFilter
         * @public
         * @version 1.0
         **/
        b: wd.attribute(true),

        /**
         * Initializes the new instance of the `webDoodling.ToggleChannelFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var channelFilter1 = new webDoodling.ToggleChannelFilter(true, false, true);
         *
         * // Initialize object.
         * var channnelFilter2 = new webDoodling.ToggleChannelFilter({
         *    id: 'channel-filter2',
         *    r: true,
         *    g: false,
         *    b: true,
         * });
         *
         * var channelFilter3 = new webDoodling.ToggleChannelFilter();
         * channelFilter3.r = true;
         * channelFilter3.g = true;
         * channelFilter3.b = false;
         *
         * @constructor init(r, g, b)
         * @param {boolean} r Its true when we need Red color Channel.
         * @param {boolean} g Its true when we need Green color Channel.
         * @param {boolean} b Its true when we need Blue color Channel.
         *
         * @memberOf webDoodling.ToggleChannelFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                len = arguments.length;

            this.base();

            this.serializables("r", "g", "b");

            if(len === 1 && wd.is.plainObject(arg1)) {
                this.deserialize(arg1);
            }
            else {
                this.r = (arg1 !== undefined) ? !!arg1 : this.r;
                this.g = (arg2 !== undefined) ? !!arg2 : this.g;
                this.b = (arg3 !== undefined) ? !!arg3 : this.b;
            }
        },


        /**
         * Returs the filtered image data after processing for channel effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the channel effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ToggleChannelFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                x, y, r, g, b, a, index;

            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = (this.r === false && this.g === true && this.b === true) ? 0 : data[index];
                    g = (this.r === true && this.g === false && this.b === true) ? 0 : data[index + 1];
                    b = (this.r === true && this.g === true && this.b === false) ? 0 : data[index + 2];
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ToggleChannelFilter].
         *
         * @memberOf webDoodling.ToggleChannelFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ToggleChannelFilter]";
        }

    }, wd.Filter);

    wd.ToggleChannelFilter = ToggleChannelFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Clip Filter
(function (wd) {
    "use strict";

    var ClipFilter;

    /**
     * Represent the `webDoodling.ClipFilter`.
     *
     * @class webDoodling.ClipFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *        wd.ClipFilter(49)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    ClipFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ClipFilter`, always returns 'ClipFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ClipFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("ClipFilter"),

        /**
         * Gets or sets the amount of adjustment required for this filter.
         *
         * @field {number} adjust
         * @default 10
         * Range from 0 to 100
         *
         * @memberOf webDoodling.ClipFilter
         * @public
         * @version 1.0
         **/
        adjust: wd.property({
            value: 10,
            get: function () {
                return this._adjust;
            },
            set: function (v) {
                this._adjust = Math.min(Math.max(v, 0), 100);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.ClipFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var clipFilter1 = new webDoodling.ClipFilter(4);
         *
         * // Initialize object.
         * var clipFilter2 = new webDoodling.ClipFilter({
         *    id: 'clip-filter2',
         *    adjust: 10,
         * });
         *
         * var clipFilter3 = new webDoodling.ClipFilter();
         * clipFilter3.adjust = 4;
         *
         * @constructor init(adjust)
         * @param {number} adjust The adjustment of color for clip filter.
         *
         * @memberOf webDoodling.ClipFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();

            this.serializables("adjust");

            if (wd.is.number(arg)) {
                this.adjust = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for clip effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the clip effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ClipFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                clip = this.adjust,
                x, y, r, g, b, a, index;

            clip = Math.abs(clip) * 2.55;
            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    if (data[index] > 255 - clip) {
                        r = 255;
                    }
                    else if (data[index] < clip) {
                        r = 0;
                    }
                    if (data[index + 1] > 255 - clip) {
                        g = 255;
                    }
                    else if (data[index + 1] < clip) {
                        g = 0;
                    }
                    if (data[index + 2] > 255 - clip) {
                        b = 255;
                    }
                    else if(data[index + 2] < clip) {
                        b = 0;
                    }
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ClipFilter].
         *
         * @memberOf webDoodling.ClipFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ClipFilter]";
        }

    }, wd.Filter);

    wd.ClipFilter = ClipFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Contrast Filter
(function (wd) {
    "use strict";

    var ContrastFilter;

    /**
     * Represent the `webDoodling.ContrastFilter`.
     *
     * @class webDoodling.ContrastFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.ContrastFilter(100)
     *    ]
     * }),
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    ContrastFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ContrastFilter`, always returns 'ContrastFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ContrastFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("ContrastFilter"),

        /**
         * Gets or sets the amount of contrast required for this filter.
         *
         * @field {number} amount
         * @default 10
         * Range from -100 to 100
         *
         * @memberOf webDoodling.ContrastFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.max(Math.min(v, 100), -100);
            }
        }),


        /**
         * Initializes the new instance of the `webDoodling.ContrastFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var contrastFilter1 = new webDoodling.ContrastFilter(10);
         *
         * // Initialize object.
         * var contrastFilter2 = new webDoodling.ContrastFilter({
         *    id: 'contrast-filter2',
         *    amount: 10
         * });
         *
         * var contrastFilter3 = new webDoodling.ContrastFilter();
         * contrastFilter3.amount = 30;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of contrast for contrast filter.
         *
         * @memberOf webDoodling.ContrastFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for contrast effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the contrast effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ContrastFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                amount = Math.pow((this.amount + 100) / 100, 2),
                x, y, r, g, b, a, index;

            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = ((data[index] / 255 - 0.5) * amount + 0.5) * 255;
                    g = ((data[index + 1] / 255 - 0.5) * amount + 0.5) * 255;
                    b = ((data[index + 2] / 255 - 0.5) * amount + 0.5) * 255;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ContrastFilter].
         *
         * @memberOf webDoodling.ContrastFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ContrastFilter]";
        }

    }, wd.Filter);

    wd.ContrastFilter = ContrastFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Emboss Filter
(function (wd) {
    "use strict";

    var EmbossFilter;

    /**
     * Represent the `webDoodling.EmbossFilter`.
     *
     * @class webDoodling.EmbossFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.EmbossFilter(100, 135)
     *    ]
     * }),
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    EmbossFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.EmbossFilter`, always returns 'EmbossFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.EmbossFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("EmbossFilter"),

        /**
         * Gets or sets the amount of emboss required for this filter.
         *
         * @field {number} amount
         * @default 100
         * Range from 0 to 100
         *
         * @memberOf webDoodling.EmbossFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 100,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 100);
            }
        }),

        /**
         * Gets or sets the angle required for this filter.
         *
         * @field {number} angle
         * @default 135
         * Range from -180 to 180
         *
         * @memberOf webDoodling.EmbossFilter
         * @public
         * @version 1.0
         **/
        angle: wd.property({
            value: 135,
            get: function () {
                return this._angle;
            },
            set: function (v) {
                this._angle = Math.max(Math.min(v, 180), -180);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.EmbossFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var embossFilter1 = new webDoodling.EmbossFilter(40, 140);
         *
         * // Initialize object.
         * var embossFilter2 = new webDoodling.EmbossFilter({
         *    id: 'emboss-filter2',
         *    amount: 4,
         *    angle: 140,
         * });
         *
         * var embossFilter3 = new webDoodling.EmbossFilter();
         * embossFilter3.amount = 4;
         * embossFilter3.angle = 140;
         *
         * @constructor init(amount, angle)
         * @param {number} amount The amount of emboss for emboss filter.
         * @param {number} angle The angle for emboss filter.
         *
         * @memberOf webDoodling.EmbossFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                len = arguments.length;

            this.base();
            this.serializables("amount", "angle");

            if (len === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                }
                else {
                    this.amount = arg1;
                }
            }
            else if (len === 2) {
                this.amount = arg1;
                this.angle = arg2;
            }
        },


        /**
         * Returs the filtered image data after processing for emboss effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the emboss effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.EmbossFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var scale = this.amount,
                angler = this.angle,
                src, sw, sh, matrix, obaque, r, g, b, a,
                output, dst, y, x, angle, x1, y1,
                a1, a2, a3, a4, a5, a6, a7, a8, m00, m10, m20, m01, m11, m21, m02, m12, m22, pi00, pi01, pi02,
                pi10, pi11, pi12, pi20, pi21, pi22, index, pyc, pyp, pyn, pxc, pxp, pxn, dr, dg, db, da;

            scale = Math.min(Math.max(scale / 100, 0), 1);
            angle = angler / 180 * Math.PI;
            x1 = Math.cos(-angle) * scale;
            y1 = Math.sin(-angle) * scale;
            a1 = -x1 - y1;
            a2 = -x1;
            a3 = y1 - x1;
            a4 = -y1;
            a5 = y1;
            a6 = -y1 + x1;
            a7 = x1;
            a8 = y1 + x1;
            src = imageData.data;
            sw = imageData.width;
            sh = imageData.height;
            matrix = [a1, a4, a6,
                      a2, 0, a7,
                      a3, a5, a8];
            m00 = matrix[0];
            m01 = matrix[1];
            m02 = matrix[2];
            m10 = matrix[3];
            m11 = matrix[4];
            m12 = matrix[5];
            m20 = matrix[6];
            m21 = matrix[7];
            m22 = matrix[8];
            obaque = false;
            output = ctx.createImageData(sw,sh);
            dst = output.data;
            for (y = 0; y < sh ; y += 1) {
                pyc = y * sw * 4;
                pyp = pyc - sw * 4;
                pyn = pyc + sw * 4;

                if (y < 1) pyp = pyc;
                if (y >= sw - 1) pyn = pyc;
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;

                    pxc = x * 4;
                    pxp = pxc - 4;
                    pxn = pxc + 4;

                    if (x < 1) pxp = pxc;
                    if (x >= sw - 1) pxn = pxc;

                    pi00 = pyp + pxp;    pi01 = pyp + pxc;    pi02 = pyp + pxn;
                    pi10 = pyc + pxp;    pi11 = pyc + pxc;    pi12 = pyc + pxn;
                    pi20 = pyn + pxp;    pi21 = pyn + pxc;    pi22 = pyn + pxn;

                    r = src[pi00] * m00 + src[pi01] * m01 + src[pi02] * m02 + src[pi10] * m10 + src[pi11] * m11 + src[pi12] * m12 + src[pi20] * m20 + src[pi21] * m21 + src[pi22] * m22;

                    g = src[pi00 + 1] * m00 + src[pi01 + 1] * m01 + src[pi02 + 1] * m02 + src[pi10 + 1] * m10 + src[pi11 + 1] * m11 + src[pi12 + 1] * m12 + src[pi20 + 1] * m20 + src[pi21 + 1] * m21 + src[pi22 + 1] * m22;

                    b = src[pi00 + 2] * m00 + src[pi01 + 2] * m01 + src[pi02 + 2] * m02 + src[pi10 + 2] * m10 + src[pi11 + 2] * m11 + src[pi12 + 2] * m12 + src[pi20 + 2] * m20 + src[pi21 + 2] * m21 + src[pi22 + 2] * m22;

                    if (obaque) {
                        a = src[pi00 + 3] * m00 + src[pi01 + 3] * m01 + src[pi02 + 3] * m02
                            + src[pi10 + 3] * m10 + src[pi11 + 3] * m11 + src[pi12 + 3] * m12
                            + src[pi20 + 3] * m20 + src[pi21 + 3] * m21 + src[pi22 + 3] * m22;
                    } else {
                        a = src[index + 3];
                    }

                    dst[index] = r;
                    dst[index + 1] = g;
                    dst[index + 2] = b;
                    dst[index + 3] = a;
                }
            }
            for (y = 0; y < sh; y += 1) {
                for(x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    dr = 128 + dst[index];
                    dg = 128 + dst[index + 1];
                    db = 128 + dst[index + 2];
                    da = src[index + 3];
                    this.setPixel(index, dr, dg, db, da);
                }
            }
            //ctx.clearRect(0,0,thecanvas.width,thecanvas.height);
            return output;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.EmbossFilter].
         *
         * @memberOf webDoodling.EmbossFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.EmbossFilter]";
        }

    }, wd.Filter);

    wd.EmbossFilter = EmbossFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Gamma Filter
(function (wd) {
    "use strict";

    var GammaFilter;

    /**
     * Represent the `webDoodling.GammaFilter`.
     *
     * @class webDoodling.GammaFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.GammaFilter(0.10)
     *    ]
     * }),
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    GammaFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.GammaFilter`, always returns 'GammaFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.GammaFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("GammaFilter"),

        /**
         * Gets or sets the amount of gamma correction required for this filter.
         *
         * @field {number} amount
         * @default 1.0
         * Range from 0 to 1.0
         *
         * @memberOf webDoodling.GammaFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 1.0,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 9.99);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.GammaFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var gammaFilter1 = new webDoodling.GammaFilter(10);
         *
         * // Initialize object.
         * var gammaFilter2 = new webDoodling.GammaFilter({
         *    id: 'gamma-filter2',
         *    amount: 10
         * });
         *
         * var gammaFilter3 = new webDoodling.GammaFilter();
         * gammaFilter3.amount = 30;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of radians for gamma filter.
         *
         * @memberOf webDoodling.GammaFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for gamma effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the gamma effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.GammaFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                x, y, r, g, b, a, index;

            for (y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = Math.pow(data[index] / 255, this.amount) * 255;
                    g = Math.pow(data[index + 1] / 255, this.amount) * 255;
                    b = Math.pow(data[index + 2] / 255, this.amount) * 255;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.GammaFilter].
         *
         * @memberOf webDoodling.GammaFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.GammaFilter]";
        }

    }, wd.Filter);

    wd.GammaFilter = GammaFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Glow Filter
(function (wd) {
    "use strict";

    var GlowFilter;

    /**
     * Represent the `webDoodling.GlowFilter`.
     *
     * @class webDoodling.GlowFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.GlowFilter(2)
     *    ]
     * }),
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    GlowFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.GlowFilter`, always returns 'GlowFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.GlowFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("GlowFilter"),

        /**
         * Gets or sets the amount of radius required for this filter.
         *
         * @field {number} radius
         * @default 10
         * Range from 0 to 20
         *
         * @memberOf webDoodling.GlowFilter
         * @public
         * @version 1.0
         **/
        radius: wd.property({
            value: 10,
            get: function () {
                return this._radius;
            },
            set: function (v) {
                this._radius = Math.min(Math.max(v, 0), 20);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.GlowFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var glowFilter1 = new webDoodling.GlowFilter(10);
         *
         * // Initialize object.
         * var glowFilter2 = new webDoodling.GlowFilter({
         *    id: 'glow-filter2',
         *    radius: 10
         * });
         *
         * var glowFilter3 = new webDoodling.GlowFilter();
         * glowFilter3.radius = 5;
         *
         * @constructor init(radius)
         * @param {number} radius The radius for glow filter.
         *
         * @memberOf webDoodling.GlowFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("radius");

            if (wd.is.number(arg)) {
                this.radius = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for glow effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the glow effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.GlowFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var orignalData = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                blurData = _blurEffect(ctx, imageData, this.radius),
                data = blurData.data,
                x, y, r, g, b, a, index;

            for (y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = 255 - (((255 - data[index]) * (255 - orignalData[index])) / 255);
                    g = 255 - (((255 - data[index + 1]) * (255 - orignalData[index + 1])) / 255);
                    b = 255 - (((255 - data[index + 2]) * (255 - orignalData[index + 2])) / 255);
                    a = 255 - (((255 - data[index + 3]) * (255 - orignalData[index + 3])) / 255);
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.GlowFilter].
         *
         * @memberOf webDoodling.GlowFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.GlowFilter]";
        }

    }, wd.Filter);

    wd.GlowFilter = GlowFilter;

    function _blurEffect(ctx, imageData, scale) {
        var mul = [512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
                       454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
                       482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
                       437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
                       497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
                       320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
                       446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
                       329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
                       505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
                       399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
                       324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
                       268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
                       451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
                       385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
                       332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
                       289,287,285,282,280,278,275,273,271,269,267,265,263,261,259],

            shg = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
                       17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
                       19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
                       20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
                       21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
                       21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
                       22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
                       22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
                       23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
                       23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
                       23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
                       23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
                       24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
                       24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
                       24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
                       24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24],

            x, y, i, p, yp, yi, yw, rSum, gSum, bSum, aSum,
            rOutSum, gOutSum, bOutSum, aOutSum,
            rInSum, gInSum, bInSum, aInSum, pr, pg, pb, pa, rbs,

            data = imageData.data,
            radius = scale,
            width = imageData.width,
            height = imageData.height,
            div = (radius + radius) + 1,
            widthMinus = width - 1,
            heightMinus = height - 1,
            radiusPlus = radius + 1,
            sumFactor = radiusPlus * (radiusPlus + 1) / 2,
            stackStart = new _blurStack(),
            stackEnd = null,
            stack = stackStart,
            stackIn = null,
            stackOut = null,
            mSum = mul[radius],
            sSum = shg[radius];

        for (i = 1; i < div; i++) {
            stack = stack.next = new _blurStack();
            if(i === radiusPlus) {
                stackEnd = stack;
            }
        }
        stack.next = stackStart;
        yw = yi = 0;
        for (y = 0; y < height; y++) {
            rInSum = gInSum = bInSum = aInSum = rSum = gSum = bSum = aSum = 0;
            rOutSum = radiusPlus * ( pr = data[yi] );
            gOutSum = radiusPlus * ( pg = data[yi + 1] );
            bOutSum = radiusPlus * ( pb = data[yi + 2] );
            aOutSum = radiusPlus * ( pa = data[yi + 3] );
            rSum += sumFactor * pr;
            gSum += sumFactor * pg;
            bSum += sumFactor * pb;
            aSum += sumFactor * pa;
            stack = stackStart;
            for (i = 0; i < radiusPlus; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }
            for (i = 1; i < radiusPlus; i++) {
                p = yi + ((widthMinus < i ? widthMinus : i) << 2);
                rSum += (stack.r = (pr = data[p])) * (rbs = radiusPlus - i);
                gSum += (stack.g = (pg = data[p + 1])) * rbs;
                bSum += (stack.b = (pb = data[p + 2])) * rbs;
                aSum += (stack.a = (pa = data[p + 3])) * rbs;
                rInSum += pr;
                gInSum += pg;
                bInSum += pb;
                aInSum += pa;
                stack = stack.next;
            }
            stackIn = stackStart;
            stackOut = stackEnd;
            for (x = 0; x < width; x++) {
                data[yi + 3] = pa = (aSum * mSum) >> sSum;
                if(pa != 0) {
                    pa = 255 / pa;
                    data[yi] = ((rSum * mSum) >> sSum) * pa;
                    data[yi + 1] = ((gSum * mSum) >> sSum) * pa;
                    data[yi + 2] = ((bSum * mSum) >> sSum) * pa;
                }
                else {
                    data[yi] = data[yi + 1] = data[yi + 2] = 0;
                }
                rSum -= rOutSum;
                gSum -= gOutSum;
                bSum -= bOutSum;
                aSum -= aOutSum;

                rOutSum -= stackIn.r;
                gOutSum -= stackIn.g;
                bOutSum -= stackIn.b;
                aOutSum -= stackIn.a;

                p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus ? p : widthMinus ) ) << 2;

                rInSum += (stackIn.r = data[p]);
                gInSum += (stackIn.g = data[p + 1]);
                bInSum += (stackIn.b = data[p + 2]);
                aInSum += (stackIn.a = data[p + 3]);

                rSum += rInSum;
                gSum += gInSum;
                bSum += bInSum;
                aSum += aInSum;

                stackIn = stackIn.next;

                rOutSum += (pr = stackOut.r);
                gOutSum += (pg = stackOut.g);
                bOutSum += (pb = stackOut.b);
                aOutSum += (pa = stackOut.a);

                rInSum -= pr;
                gInSum -= pg;
                bInSum -= pb;
                aInSum -= pa;

                stackOut = stackOut.next;

                yi += 4;
            }
            yw += width;
        }
        for (x = 0; x < width; x++) {
            gInSum = bInSum = aInSum = rInSum = gSum = bSum = aSum = rSum = 0;
            yi = x << 2;
            rOutSum = radiusPlus * (pr = data[yi]);
            gOutSum = radiusPlus * (pg = data[yi + 1]);
            bOutSum = radiusPlus * (pb = data[yi + 2]);
            aOutSum = radiusPlus * (pa = data[yi + 3]);

            rSum += sumFactor * pr;
            gSum += sumFactor * pg;
            bSum += sumFactor * pb;
            aSum += sumFactor * pa;

            stack = stackStart;

            for(i = 0; i < radiusPlus; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            yp = width;

            for(i = 1; i <= radius; i++) {
                yi = (yp + x) << 2;
                rSum += (stack.r = (pr = data[yi])) * (rbs = radiusPlus - i);
                gSum += (stack.g = (pg = data[yi + 1])) * rbs;
                bSum += (stack.b = (pb = data[yi + 2])) * rbs;
                aSum += (stack.a = (pa = data[yi + 3])) * rbs;
                rInSum += pr;
                gInSum += pg;
                bInSum += pb;
                aInSum += pa;
                stack = stack.next;
                if(i < heightMinus) {
                    yp += width;
                }
            }
            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for(y = 0; y < height; y++) {
                p = yi << 2;
                data[p + 3] = pa = (aSum * mSum) >> sSum;
                if(pa > 0) {
                    pa = 255 / pa;
                    data[p] = ((rSum * mSum) >> sSum) * pa;
                    data[p + 1] = ((gSum * mSum) >> sSum) * pa;
                    data[p + 2] = ((bSum * mSum) >> sSum) * pa;
                }
                else {
                    data[p] = data[p + 1] = data[p + 2] = 0;
                }
                rSum -= rOutSum;
                gSum -= gOutSum;
                bSum -= bOutSum;
                aSum -= aOutSum;
                rOutSum -= stackIn.r;
                gOutSum -= stackIn.g;
                bOutSum -= stackIn.b;
                aOutSum -= stackIn.a;

                p = ( x + (( ( p = y + radiusPlus) < heightMinus ? p : heightMinus ) * width )) << 2;

                rSum += (rInSum += (stackIn.r = data[p]));
                gSum += (gInSum += (stackIn.g = data[p + 1]));
                bSum += (bInSum += (stackIn.b = data[p + 2]));
                aSum += (aInSum += (stackIn.a = data[p + 3]));

                stackIn = stackIn.next;

                rOutSum += (pr = stackOut.r);
                gOutSum += (pg = stackOut.g);
                bOutSum += (pb = stackOut.b);
                aOutSum += (pa = stackOut.a);

                rInSum -= pr;
                gInSum -= pg;
                bInSum -= pb;
                aInSum -= pa;

                stackOut = stackOut.next;

                yi += width;
            }
        }
        return imageData;
    }
    function _blurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The HDR Filter
(function (wd) {
    "use strict";

    var HDRFilter;

    /**
     * Represent the `webDoodling.HDRFilter`.
     *
     * @class webDoodling.HDRFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.HDRFilter(100)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    HDRFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.HDRFilter`, always returns 'HDRFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.HDRFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("HDRFilter"),

        /**
         * Gets or sets the amount of hdr required for this filter.
         *
         * @field {number} amount
         * @default 10
         *
         * @memberOf webDoodling.HDRFilter
         * @public
         * @version 1.0
         **/
        amount: wd.attribute(10),

        /**
         * Initializes the new instance of the `webDoodling.HDRFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var hdrFilter1 = new webDoodling.HDRFilter(10);
         *
         * // Initialize object.
         * var hdrFilter2 = new webDoodling.HDRFilter({
         *    id: 'hdr-filter2',
         *    amount: 10
         * });
         *
         * var hdrFilter3 = new webDoodling.HDRFilter();
         * hdrFilter3.amount = 50;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of range for hdr filter.
         *
         * @memberOf webDoodling.HDRFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for hdr effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the hdr effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.HDRFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                x, y, index, r, g, b, a;

            for (y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = _changeContrast(data[index], this.amount);
                    g = _changeContrast(data[index + 1], this.amount);
                    b = _changeContrast(data[index + 2], this.amount);
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.HDRFilter].
         *
         * @memberOf webDoodling.HDRFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.HDRFilter]";
        }

    }, wd.Filter);

    wd.HDRFilter = HDRFilter;

    function _changeContrast(v, scale) {
        if (v > 0 && v <= 127) {
            v = Math.sin(Math.PI * (90 - v / 4) / 180) * v;
        }
        else if (v > 127) {
            v = Math.sin(Math.PI * (90 - (255 - v) / 4) / 180) * v;
        }
        return v - scale;
    }

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The HorizontalFlip
(function (wd) {
    "use strict";

    var HorizontalFlip;

    /**
     * Represent the `webDoodling.HorizontalFlip`.
     *
     * @class webDoodling.HorizontalFlip
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.HorizontalFlip()
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    HorizontalFlip = wd.Class({
        /**
         * Returns the `type` of `webDoodling.HorizontalFlip`, always returns 'HorizontalFlip'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.HorizontalFlip
         * @public
         * @version 1.0
         **/
        type: wd.type("HorizontalFlip"),

        /**
         * Returs the filtered image data after processing for horizontal flip.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the horizontal flip.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.HorizontalFlip
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                w = imageData.width,
                h = imageData.height,
                output = ctx.createImageData(w, h),
                x, y, dstIndex, index, r, g, b, a;

            for(x = 0; x < w; x++){
                for(y = 0; y < h; y++){
                    index = (y * w + x) * 4;
                    dstIndex = (y * w + (w - x - 1)) * 4;
                    r = data[index];
                    g = data[index + 1];
                    b = data[index + 2];
                    a = data[index + 3];
                    this.setPixel(dstIndex, r, g, b, a);
                }
            }
            return output;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.HorizontalFlip].
         *
         * @memberOf webDoodling.HorizontalFlip
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.HorizontalFlip]";
        }

    }, wd.Filter);

    wd.HorizontalFlip = HorizontalFlip;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Hsl Filter
(function (wd) {
    "use strict";

    var HSLFilter;

    /**
     * Represent the `webDoodling.HSLFilter`.
     *
     * @class webDoodling.HSLFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.HSLFilter(50, 50, 50)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    HSLFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.HSLFilter`, always returns 'HSLFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.HSLFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("HSLFilter"),

        /**
         * Gets or sets the amount of hue required for this filter.
         *
         * @field {number} h
         * @default 10
         * Range from -180 to 180
         *
         * @memberOf webDoodling.HSLFilter
         * @public
         * @version 1.0
         **/
        h: wd.property({
            value: 10,
            get: function () {
                return this._h;
            },
            set: function (v) {
                this._h = Math.max(Math.min(v, 180), -180);
            }
        }),

        /**
         * Gets or sets the amount of saturation required for this filter.
         *
         * @field {number} s
         * @default 10
         * Range from -100 to 100
         *
         * @memberOf webDoodling.HSLFilter
         * @public
         * @version 1.0
         **/
        s: wd.property({
            value: 10,
            get: function () {
                return this._s;
            },
            set: function (v) {
                this._s = Math.max(Math.min(v, 100), -100);
            }
        }),

        /**
         * Gets or sets the amount of lightness required for this filter.
         *
         * @field {number} l
         * @default 10
         * Range from -100 to  100
         *
         * @memberOf webDoodling.HSLFilter
         * @public
         * @version 1.0
         **/
        l: wd.property({
            value: 10,
            get: function () {
                return this._l;
            },
            set: function (v) {
                this._l = Math.max(Math.min(v, 100), -100);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.HSLFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var hslFilter1 = new webDoodling.HSLFilter(140, 50, 50);
         *
         * // Initialize object.
         * var hslFilter2 = new webDoodling.HSLFilter({
         *    id: 'hsl-filter2',
         *    h: 100,
         *    s: -100,
         *    l: -100
         * });
         *
         * var hslFilter3 = new webDoodling.HSLFilter();
         * hslFilter3.h = 180;
         * hslFilter3.s = 10;
         * hslFilter3.l = 10;
         *
         * @constructor init(h, s, l)
         * @param {number} h The hue value for hsl filter.
         * @param {number} s The saturation value for hsl filter.
         * @param {number} l The lightness value for hsl filter.
         *
         * @memberOf webDoodling.HSLFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                len = arguments.length;

            this.base();
            this.serializables("h", "s", "l");

            if (len === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                }
                else {
                    this.h = arg1;
                }
            }
            else if (len === 2) {
                this.h = arg1;
                this.s = arg2;
            }
            else if (len === 3) {
                this.h = arg1;
                this.s = arg2;
                this.l = arg3;
            }
        },


        /**
         * Returs the filtered image data after processing for hsl effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the hsl effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.HSLFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                width = imageData.width,
                height = imageData.height,
                hsv, rgb, y, x, r, g, b, a, gray,
                h = this.h,
                s = -this.s,
                l = this.l,
                pixel, mul, add;

            h /= 360;
            s /= 100;
            l /= 100;
            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    pixel = (y * width + x) * 4;
                    r = data[pixel];
                    g = data[pixel + 1];
                    b = data[pixel + 2];
                    a = data[pixel + 3];
                    hsv = _toHSV(r, g, b);
                    hsv[0] += h;
                    while(hsv[0] < 0){
                        hsv[0] += 360;
                    }
                    rgb = _fromHSV(hsv[0], hsv[1], hsv[2]);
                    r = rgb[0];
                    g = rgb[1];
                    b = rgb[2];
                    if (s !== 0) {
                        gray = 0.34 * r + 0.5 * g + 0.16 * b;
                        r = gray * s + r * (1 - s);
                        g = gray * s + g * (1 - s);
                        b = gray * s + b * (1 - s);
                    }
                    if (l !== 0) {
                        l = Math.min(Math.max(-1, l), 1);
                        mul = l < 0 ? 1 + l : 1 - l;
                        add = l < 0 ? 0 : l * 255;
                        r = r * mul + add;
                        g = g * mul + add;
                        b = b * mul + add;
                        a = a;
                    }
                    this.setPixel(pixel, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.HSLFilter].
         *
         * @memberOf webDoodling.HSLFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.HSLFilter]";
        }

    }, wd.Filter);

    wd.HSLFilter = HSLFilter;

    function _toHSV(r, g, b) {
        r = r/255, g = g/255, b = b/255;

        var Cmax = Math.max(r, g, b),
            Cmin = Math.min(r, g, b),
            h, s, v = Cmax,
            D = Cmax - Cmin;

        s = Cmax === 0 ? 0 : D / Cmax;
        if (Cmax === Cmin) {
            h = 0;
        }
        else {
            switch(Cmax){
            case r: h = (g - b) / D + (g < b ? 6 : 0); break;
            case g: h = (b - r) / D + 2; break;
            case b: h = (r - g) / D + 4; break;
            }
            h /= 6;
        }
        return [h, s, v];
    }
    function _fromHSV(h, s, v) {
        var r, g, b,
            i = Math.floor(h * 6),
            f = h * 6 - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s);

        switch(i % 6){
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
        }

        return [r * 255, g * 255, b * 255];
    }

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Noise Filter
(function (wd) {
    "use strict";

    var NoiseFilter;

    /**
     * Represent the `webDoodling.NoiseFilter`.
     *
     * @class webDoodling.NoiseFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.NoiseFilter(150)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    NoiseFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.NoiseFilter`, always returns 'NoiseFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.NoiseFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("NoiseFilter"),

        /**
         * Gets or sets the amount of noise required for this filter.
         *
         * @field {number} amount
         * @default 10
         * Range from 0 to 400
         *
         * @memberOf webDoodling.NoiseFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 400);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.NoiseFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var noiseFilter1 = new webDoodling.NoiseFilter(10);
         *
         * // Initialize object.
         * var noiseFilter2 = new webDoodling.NoiseFilter({
         *    id: 'noise-filter2',
         *    amount: 10
         * });
         *
         * var noiseFilter3 = new webDoodling.NoiseFilter();
         * noiseFilter3.amount = 50;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of noise on image for noise filter.
         *
         * @memberOf webDoodling.NoiseFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for noise effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the noise effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.NoiseFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                rand, y, x, r, g, b, a, index;

            for (y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    rand = ((2 * Math.random() - 1) * this.amount);
                    r = data[index] + rand;
                    g = data[index + 1] + rand;
                    b = data[index + 2] + rand;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.NoiseFilter].
         *
         * @memberOf webDoodling.NoiseFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.NoiseFilter]";
        }

    }, wd.Filter);

    wd.NoiseFilter = NoiseFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Sepia Filter
(function (wd) {
    "use strict";

    var SepiaFilter;

    /**
     * Represent the `webDoodling.SepiaFilter`.
     *
     * @class webDoodling.SepiaFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.SepiaFilter(50)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    SepiaFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.SepiaFilter`, always returns 'SepiaFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.SepiaFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("SepiaFilter"),

        /**
         * Gets or sets the amount color required for this filter.
         *
         * @field {number} amount
         * @default 10
         * Range from 0 to 100
         *
         * @memberOf webDoodling.SepiaFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 100);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.SepiaFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var sepiaFilter1 = new webDoodling.SepiaFilter(20);
         *
         * // Initialize object.
         * var sepiaFilter2 = new webDoodling.SepiaFilter({
         *    id: 'sepia-filter2',
         *    amount: 40
         * });
         *
         * var sepiaFilter3 = new webDoodling.SepiaFilter();
         * sepiaFilter3.amount = 50;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of color for sepia filter.
         *
         * @memberOf webDoodling.SepiaFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for sepia effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the sepia effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.SepiaFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                amount = this.amount,
                x, y, lum, r, g, b, a, index;

            amount *= 255 / 100;
            for (y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    lum = data[index] * 0.3 + data[index + 1] * 0.59 + data[index + 2] * 0.11;
                    r = g = b = lum;
                    r += 40;
                    g += 20;
                    b -= amount;
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }

            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.SepiaFilter].
         *
         * @memberOf webDoodling.SepiaFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.SepiaFilter]";
        }

    }, wd.Filter);

    wd.SepiaFilter = SepiaFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Circle Smear Filter
(function (wd) {
    "use strict";

    var CircleSmearFilter;

    /**
     * Represent the `webDoodling.CircleSmearFilter`.
     *
     * @class webDoodling.CircleSmearFilter
     *
     * @example
     * wd.Image({
     *   x: 0,
     *   y: 0,
     *   keepOriginal: true,
     *   source: "../(media)/img/boat.png",
     *   filters: [
     *     wd.CircleSmearFilter(3, 100, 100)
     *   ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    CircleSmearFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.CircleSmearFilter`, always returns 'CircleSmearFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.CircleSmearFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("CircleSmearFilter"),

        /**
         * Gets or sets the size of circle required for this filter.
         *
         * @field {number} size
         * @default 5
         * Range from 0 to 10
         *
         * @memberOf webDoodling.CircleSmearFilter
         * @public
         * @version 1.0
         **/
        size: wd.property({
            value: 5,
            get: function () {
                return this._size;
            },
            set: function (v) {
                this._size = Math.min(Math.max(v, 0), 10);
            }
        }),

        /**
         * Gets or sets the frequency required for this filter.
         *
         * @field {number} frequency
         * @default 50
         * Range from 0 to 100
         *
         * @memberOf webDoodling.CircleSmearFilter
         * @public
         * @version 1.0
         **/
        frequency: wd.property({
            value: 50,
            get: function () {
                return this._frequency;
            },
            set: function (v) {
                this._frequency = Math.min(Math.max(v, 0), 100);
            }
        }),

        /**
         * Gets or sets the mix capacity required for this filter.
         *
         * @field {number} mix
         * @default 50
         * Range from 0 to 100
         *
         * @memberOf webDoodling.CircleSmearFilter
         * @public
         * @version 1.0
         **/
        mix: wd.property({
            value: 50,
            get: function () {
                return this._mix;
            },
            set: function (v) {
                this._mix = Math.min(Math.max(v, 0), 100);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.CircleSmearFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var circleFilter1 = new webDoodling.CircleSmearFilter(4, 40, 30);
         *
         * // Initialize object.
         * var circleFilter2 = new webDoodling.CircleSmearFilter({
         *    id: 'circle-filter2',
         *    size: 4,
         *    frequency: 40,
         *    mix: 30,
         * });
         *
         * var circleFilter3 = new webDoodling.CircleSmearFilter();
         * circleFilter3.size = 4;
         * circleFilter3.frequency = 40;
         * circleFilter3.mix = 30;
         *
         * @constructor init(size, frequency, mix)
         * @param {number} size The size of the circle.
         * @param {number} frequency The frequency of the circle.
         * @param {number} mix The mixing of circle.
         *
         * @memberOf webDoodling.CircleSmearFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                len = arguments.length;

            this.base();

            this.serializables("size", "frequency", "mix");

            if (len === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                }
                else {
                    this.size = arg1;
                }
            }
            else if (len === 2) {
                this.size = arg1;
                this.frequency = arg2;
            }
            else if (len === 3) {
                this.size = arg1;
                this.frequency = arg2;
                this.mix = arg3;
            }
        },


        /**
         * Returs the filtered image data after processing for smooth noise effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the circle smear effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.CircleSmearFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                width = imageData.width,
                height = imageData.height,
                outData = [],
                radius = this.size + 1,
                radiusSqu = radius * radius,
                i, j, x, y, jLen, sx, sy,
                freq = this.frequency,
                mix = this.mix,
                numCircle, rgbData, rgbOutData, f, mixedRGB, r, g, b, a, index;

            freq /= 100;
            mix /= 100;
            numCircle = 2 * freq / 30 * width * height / 2;
            //numCircle = parseInt(2 * this.frequency / 30 * width * height / 2);

            for (j = 0, jLen = data.length; j < jLen; j++) {
                outData[j] = data[j];
            }

            for (i = 0; i < numCircle; i++) {
                sx = (Math.random() * Math.pow(2, 32) & 0x7fffffff) % width;
                sy = (Math.random() * Math.pow(2, 32) & 0x7fffffff) % height;
                rgbOutData = [data[((sy * width + sx) * 4)], data[((sy * width + sx) * 4) + 1], data[((sy * width + sx) * 4) + 2], data[((sy *                              width + sx) * 4) + 3]];
                for (x = sx - radius; x < sx + radius + 1; x++) {
                    for (y = sy - radius; y < sy + radius + 1; y++) {
                        f = (x - sx) * (x - sx) + (y - sy) * (y - sy);
                        if (x >= 0 && x < width && y >= 0 && y < height && f <= radiusSqu) {
                            rgbData = [outData[((y * width + x) * 4)], outData[((y * width + x) * 4) + 1], outData[((y * width + x) * 4) + 2],                                        outData[((y * width + x) * 4) + 3]];
                            mixedRGB = _fuseRGB(mix, rgbData, rgbOutData);
                            for (j = 0; j < 3; j++) {
                                outData[(y * width + x) * 4 + j] = mixedRGB[j];
                            }
                        }
                    }
                }
            }
            for (y = 0; y < height; y += 1) {
                for (x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    r = outData[index];
                    g = outData[index + 1];
                    b = outData[index + 2];
                    a = outData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
//                data[j] = outData[j];
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.CircleSmearFilter].
         *
         * @memberOf webDoodling.CircleSmearFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.CircleSmearFilter]";
        }

    }, wd.Filter);

    wd.CircleSmearFilter = CircleSmearFilter;

    function _fuseRGB(mix, rgbData, rgbOutData) {
        var r, g, b, a;
        r = _linearIntersect(mix, rgbData[0], rgbOutData[0]);
        g = _linearIntersect(mix, rgbData[1], rgbOutData[1]);
        b = _linearIntersect(mix, rgbData[2], rgbOutData[2]);
        a = _linearIntersect(mix, rgbData[3], rgbOutData[3]);
        return [r, g, b, a];
    }

    function _linearIntersect(t, a, b) {
        return a + t * (b - a);
    }
})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Oil Paint Filter
(function (wd) {
    "use strict";

    var OilPaintFilter;

    /**
     * Represent the `webDoodling.OilPaintFilter`.
     *
     * @class webDoodling.OilPaintFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.OilPaintFilter(5)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    OilPaintFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.OilPaintFilter`, always returns 'OilPaintFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.OilPaintFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("OilPaintFilter"),

        /**
         * Gets or sets the amount required for this filter.
         *
         * @field {number} amount
         * @default 3
         * Range from 0 to 5
         *
         * @memberOf webDoodling.OilPaintFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 3,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.min(Math.max(v, 0), 5);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.OilPaintFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var oilFilter1 = new webDoodling.OilPaintFilter(2);
         *
         * // Initialize object.
         * var oilFilter2 = new webDoodling.OilPaintFilter({
         *    id: 'oil-filter2',
         *    amount: 4
         * });
         *
         * var oilFilter3 = new webDoodling.OilPaintFilter();
         * oilFilter3.amount = 5;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of paint area for oil paint filter.
         *
         * @memberOf webDoodling.OilPaintFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for oil paint effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the oil paint effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.OilPaintFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                width = imageData.width,
                height = imageData.height,
                outData = [],
                amount = this.amount,
                index = 0,
                rHisto = [], gHisto = [], bHisto = [],
                rSum = [], gSum = [], bSum = [], l = 256,
                i, row, iY, iOffset, col, iX, r, g, b, ri, gi, bi, x, y, p, a;

            if (amount === 0) {
                return imageData;
            }

            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    p = (y * width + x) * 4;
                    for (i = 0; i < l; i++) {
                        rHisto[i] = gHisto[i] = bHisto[i] = rSum[i] = gSum[i] = bSum[i] = 0;
                    }
                    for (row = -amount; row <= amount; row++) {
                        iY = y + row;
                        if (0 <= iY && iY < height) {
                            iOffset = iY * width;
                            for (col = -amount; col <= amount; col++) {
                                iX = x + col;
                                if (0 <= iX && iX < width) {
                                    r = data[(iOffset + iX) * 4];
                                    g = data[(iOffset + iX) * 4 + 1];
                                    b = data[(iOffset + iX) * 4 + 2];
                                    ri = r * l / 256;
                                    gi = g * l / 256;
                                    bi = b * l / 256;
                                    rSum[ri] += r;
                                    gSum[gi] += g;
                                    bSum[bi] += b;
                                    rHisto[ri]++;
                                    gHisto[gi]++;
                                    bHisto[bi]++;
                                }
                            }
                        }
                    }
                    r = g = b = 0;
                    for (i = 1; i < l; i++) {
                        if (rHisto[i] > rHisto[r]) {
                            r = i;
                        }
                        if (gHisto[i] > gHisto[r]) {
                            g = i;
                        }
                        if (bHisto[i] > bHisto[r]) {
                            b = i;
                        }
                    }
                    r = rSum[r] / rHisto[r];
                    g = gSum[g] / gHisto[g];
                    b = bSum[b] / bHisto[b];
                    outData[p] = r;
                    outData[p + 1] = g;
                    outData[p + 2] = b;
                    outData[p + 3] = data[p + 3];
                }
            }
            for (y = 0; y < height; y += 1) {
                for (x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    r = outData[index];
                    g = outData[index + 1];
                    b = outData[index + 2];
                    a = outData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.OilPaintFilter].
         *
         * @memberOf webDoodling.OilPaintFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.OilPaintFilter]";
        }

    }, wd.Filter);

    wd.OilPaintFilter = OilPaintFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Vertical Flip
(function (wd) {
    "use strict";

    var VerticalFlip;

    /**
     * Represent the `webDoodling.VerticalFlip`.
     *
     * @class webDoodling.VerticalFlip
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.VerticalFlip()
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    VerticalFlip = wd.Class({
        /**
         * Returns the `type` of `webDoodling.VerticalFlip`, always returns 'VerticalFlip'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.VerticalFlip
         * @public
         * @version 1.0
         **/
        type: wd.type("VerticalFlip"),

        /**
         * Returs the filtered image data after processing for vertical flip.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the vertical flip.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.VerticalFlip
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                w = imageData.width,
                h = imageData.height,
                output = ctx.createImageData(w, h),
                x, y, dstIndex, index, r, g, b, a;

            for(x = 0; x < w; x++){
                for(y = 0; y < h; y++){
                    index = (y * w + x) * 4;
                    dstIndex = ((h - y - 1) * w + x) * 4;
                    r = data[index];
                    g = data[index + 1];
                    b = data[index + 2];
                    a = data[index + 3];
                    this.setPixel(dstIndex, r, g, b, a);
                }
            }
            return output;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.VerticalFlip].
         *
         * @memberOf webDoodling.VerticalFlip
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.VerticalFlip]";
        }

    }, wd.Filter);

    wd.VerticalFlip = VerticalFlip;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Vibrance Filter
(function (wd) {
    "use strict";

    var VibranceFilter;

    /**
     * Represent the `webDoodling.VibranceFilter`.
     *
     * @class webDoodling.VibranceFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.VibranceFilter(-100)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    VibranceFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.VibranceFilter`, always returns 'VibranceFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.VibranceFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("VibranceFilter"),

        /**
         * Gets or sets the amount required for this filter.
         *
         * @field {number} amount
         * @default 10
         * Range from -100 to 100
         *
         * @memberOf webDoodling.VibranceFilter
         * @public
         * @version 1.0
         **/
        amount: wd.property({
            value: 10,
            get: function () {
                return this._amount;
            },
            set: function (v) {
                this._amount = Math.max(Math.min(v, 100), -100);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.VibranceFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var vibranceFilter1 = new webDoodling.VibranceFilter(10);
         *
         * // Initialize object.
         * var vibranceFilter2 = new webDoodling.VibranceFilter({
         *    id: 'vibrance-filter2',
         *    amount: 10
         * });
         *
         * var vibranceFilter3 = new webDoodling.VibranceFilter();
         * vibranceFilter3.amount = 30;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of intensity for Vibrance filter.
         *
         * @memberOf webDoodling.VibranceFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for vibrance effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the vibrance effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.VibranceFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                amount = this.amount,
                r, g, b,
                x, y, max, avg, amt, index, a;

            amount = amount * -1;
            for (y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = data[index];
                    g = data[index + 1];
                    b = data[index + 2];
                    max = Math.max(r, g, b);
                    avg = (r + g + b) / 3;
                    amt = ((Math.abs(max - avg) * 2 / 255) * amount) / 100;
                    if(r != max) {
                        r += (max - data[index]) * amt;
                    }
                    if(g != max) {
                        g += (max - data[index + 1]) * amt;
                    }
                    if(b != max) {
                        b += (max - data[index + 2]) * amt;
                    }
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.VibranceFilter].
         *
         * @memberOf webDoodling.VibranceFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.VibranceFilter]";
        }

    }, wd.Filter);

    wd.VibranceFilter = VibranceFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The White Balance Filter
(function (wd) {
    "use strict";

    var WhiteBalanceFilter;

    /**
     * Represent the `webDoodling.WhiteBalanceFilter`.
     *
     * @class webDoodling.WhiteBalanceFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.WhiteBalanceFilter(150)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    WhiteBalanceFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.WhiteBalanceFilter`, always returns 'WhiteBalanceFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.WhiteBalanceFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("WhiteBalanceFilter"),

        /**
         * Gets or sets the amount of whiteness required for this filter.
         *
         * @field {number} amount
         * @default 10
         *
         * @memberOf webDoodling.WhiteBalanceFilter
         * @public
         * @version 1.0
         **/
        amount: wd.attribute(10),

        /**
         * Initializes the new instance of the `webDoodling.WhiteBalanceFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var whiteFilter1 = new webDoodling.WhiteBalanceFilter(10);
         *
         * // Initialize object.
         * var whiteFilter2 = new webDoodling.WhiteBalanceFilter({
         *    id: 'white-filter2',
         *    amount: 10
         * });
         *
         * var whiteFilter3 = new webDoodling.WhiteBalanceFilter();
         * whiteFilter3.amount = 30;
         *
         * @constructor init(amount)
         * @param {number} amount The amount of whiteness for white balance filter.
         *
         * @memberOf webDoodling.WhiteBalanceFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("amount");

            if (wd.is.number(arg)) {
                this.amount = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for white balance effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the white balance effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.WhiteBalanceFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                sw = imageData.width,
                sh = imageData.height,
                amount = this.amount,
                x, y, color, index, r, g, b, a;

            color = _colorTemprature(amount);
            for(y = 0; y < sh; y += 1) {
                for (x = 0; x < sw; x += 1) {
                    index = (y * sw + x) * 4;
                    r = data[index] * (255 / color.r);
                    g = data[index + 1] * (255 / color.g);
                    b = data[index + 2] * (255 / color.b);
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.WhiteBalanceFilter].
         *
         * @memberOf webDoodling.WhiteBalanceFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.WhiteBalanceFilter]";
        }

    }, wd.Filter);

    wd.WhiteBalanceFilter = WhiteBalanceFilter;

    function _colorTemprature(v) {
                //v /= 100;
        var r, g, b;
        if (v <= 66) {
            r = 255;
            g = Math.min(Math.max(((99.4708025861 * Math.log(v)) - 161.1195681661), 0), 255);
        }
        else {
            r = Math.min(Math.max(329.698727446 * Math.pow(v - 60, -0.1332047592), 0), 255);
            g = Math.min(Math.max(288.1221695283 * Math.pow(v - 60, -0.0755148492), 0), 255);
        }
        if (v >= 66) {
            b = 255;
        } else if (v <= 19) {
            b = 0;
        }else {
            b = v - 10;
            b = Math.min(Math.max(((138.5177312231 * Math.log(b)) - 305.0447927307), 0),255);
        }
        return {
            r: r,
            g: g,
            b: b
        };
    }


})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Superfast Blur Filter
(function (wd) {
    "use strict";

    var BlurFilter;

    /**
     * Represent the `webDoodling.BlurFilter`.
     *
     * @class webDoodling.BlurFilter
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *        wd.BlurFilter(50)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    BlurFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.BlurFilter`, always returns 'BlurFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.BlurFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("BlurFilter"),

        /**
         * Gets or sets the amount of radius required for this filter.
         *
         * @field {number} radius
         * @default 10
         * Range from 0 to 250
         *
         * @memberOf webDoodling.BlurFilter
         * @public
         * @version 1.0
         **/
        radius: wd.property({
            value: 10,
            get: function () {
                return this._radius;
            },
            set: function (v) {
                this._radius = Math.min(Math.max(v, 0), 250);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.BlurFilter` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var blurFilter1 = new webDoodling.BlurFilter(10);
         *
         * // Initialize object.
         * var blurFilter2 = new webDoodling.BlurFilter({
         *    id: 'blur-filter2',
         *    radius: 10
         * });
         *
         * var blurFilter3 = new webDoodling.BlurFilter();
         * blurFilter3.radius = 30;
         *
         * @constructor init(radius)
         * @param {number} radius The radius of area for blur filter.
         *
         * @memberOf webDoodling.BlurFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();

            var arg = arguments[0];

            this.serializables("radius");

            if (wd.is.number(arg)) {
                this.radius = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },

        /**
         * Returs the filtered image data after processing for blur effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the blur effect.
         * @param {context} ctx The 2D context of the canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.BlurFilter
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var data = imageData.data,
                width = imageData.width,
                height = imageData.height,
                mul = _mul,
                shg = _shg,
                radius = this.radius,
                mSum = mul[radius],
                sSum = shg[radius],
                wMinus = width - 1,
                hMinus = height - 1,
//                wh = width * height,
                div = radius + 1,
                r = [],
                g = [],
                b = [],
                a = [],
                vMin = [],
                vMax = [],
                iter = 1,
                rSum, gSum, bSum, aSum, x, y, i, p, p1, p2, yp, yi, yw, pa, dr, dg, db, da, index;

            while (iter-- > 0) {
                yw = yi = 0;
                for (y = 0; y < height; y++) {
                    rSum = data[yw] * div;
                    gSum = data[yw + 1] * div;
                    bSum = data[yw + 2] * div;
                    aSum = data[yw + 3] * div;
                    for (i = 1; i <= radius; i++) {
                        p = yw + (((i > wMinus ? wMinus : i)) << 2);
                        rSum += data[p++];
                        gSum += data[p++];
                        bSum += data[p++];
                        aSum += data[p];
                    }
                    for (x = 0; x < width; x++) {
                        r[yi] = rSum;
                        g[yi] = gSum;
                        b[yi] = bSum;
                        a[yi] = aSum;
                        if(y == 0) {
                            vMin[x] = ((p = x + div) < wMinus ? p : wMinus) << 2;
                            vMax[x] = ((p = x - radius) > 0 ? p << 2 : 0);
                        }
                        p1 = yw + vMin[x];
                        p2 = yw + vMax[x];
                        rSum += data[p1++] - data[p2++];
                        gSum += data[p1++] - data[p2++];
                        bSum += data[p1++] - data[p2++];
                        aSum += data[p1] - data[p2];
                        yi++;
                    }
                    yw += (width << 2);
                }
                for (x = 0; x < width; x++) {
                    yp = x;
                    rSum = r[yp] * div;
                    gSum = g[yp] * div;
                    bSum = b[yp] * div;
                    aSum = a[yp] * div;
                    for (i = 1; i <= radius; i++) {
                        yp += (i > hMinus ? 0 : width);
                        rSum += r[yp];
                        gSum += g[yp];
                        bSum += b[yp];
                        aSum += a[yp];
                    }
                    yi = x << 2;
                    for (y = 0; y < height; y++) {
                        data[yi + 3] = pa = (aSum * mSum) >>> sSum;
                        if (pa > 255) {
                            data[yi + 3] = 255;
                        }
                        if(pa > 0) {
                            pa = 255 / pa;
                            data[yi] = ((rSum * mSum) >>> sSum) * pa;
                            data[yi + 1] = ((gSum * mSum) >>> sSum) * pa;
                            data[yi + 2] = ((bSum * mSum) >>> sSum) * pa;

                        }
                        else {
                            data[yi] = data[yi + 1] = data[yi + 2] = 0;
                        }
                        if(x == 0) {
                            vMin[y] = ((p = y + div) < hMinus ? p : hMinus) * width;
                            vMax[y] = ((p = y - radius) > 0 ? p * width : 0);
                        }
                        p1 = x + vMin[y];
                        p2 = x + vMax[y];
                        rSum += r[p1] - r[p2];
                        gSum += g[p1] - g[p2];
                        bSum += b[p1] - b[p2];
                        aSum += a[p1] - a[p2];
                        yi += width << 2;
                    }
                }
            }
            for (y = 0; y < height; y += 1) {
                for (x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    dr = data[index];
                    dg = data[index + 1];
                    db = data[index + 2];
                    da = data[index + 3];
                    this.setPixel(index, dr, dg, db, da);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.BlurFilter].
         *
         * @memberOf webDoodling.BlurFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.BlurFilter]";
        }
    }, wd.Filter);

    wd.BlurFilter = BlurFilter;

    var _mul = [    1,57,41,21,203,34,97,73,227,91,149,62,105,45,39,137,241,107,3,173,39,71,65,238,219,101,187,87,81,151,141,133,249,117,221,209,197,187,177,169,5,153,73,139,133,127,243,233,223,107,103,99,191,23,177,171,165,159,77,149,9,139,135,131,253,245,119,231,224,109,211,103,25,195,189,23,45,175,171,83,81,79,155,151,147,9,141,137,67,131,129,251,123,30,235,115,113,221,217,53,13,51,50,49,193,189,185,91,179,175,43,169,83,163,5,79,155,19,75,147,145,143,35,69,17,67,33,65,255,251,247,243,239,59,29,229,113,111,219,27,213,105,207,51,201,199,49,193,191,47,93,183,181,179,11,87,43,85,167,165,163,161,159,157,155,77,19,75,37,73,145,143,141,35,138,137,135,67,33,131,129,255,63,250,247,61,121,239,237,117,29,229,227,225,111,55,109,216,213,211,209,207,205,203,201,199,197,195,193,48,190,47,93,185,183,181,179,178,176,175,173,171,85,21,167,165,41,163,161,5,79,157,78,154,153,19,75,149,74,147,73,144,143,71,141,140,139,137,17,135,134,133,66,131,65,129,1],

        _shg = [ 0,9,10,10,14,12,14,14,16,15,16,15,16,15,15,17,18,17,12,18,16,17,17,19,19,18,19,18,18,19,19,19,20,19,20,20,20,20,20,20,15,20,19,20,20,20,21,21,21,20,20,20,21,18,21,21,21,21,20,21,17,21,21,21,22,22,21,22,22,21,22,21,19,22,22,19,20,22,22,21,21,21,22,22,22,18,22,22,21,22,22,23,22,20,23,22,22,23,23,21,19,21,21,21,23,23,23,22,23,23,21,23,22,23,18,22,23,20,22,23,23,23,21,22,20,22,21,22,24,24,24,24,24,22,21,24,23,23,24,21,24,23,24,22,24,24,22,24,24,22,23,24,24,24,20,23,22,23,24,24,24,24,24,24,24,23,21,23,22,23,24,24,24,22,24,24,24,23,22,24,24,25,23,25,25,23,24,25,25,24,22,25,25,25,24,23,24,25,25,25,25,25,25,25,25,25,25,25,25,23,25,23,24,25,25,25,25,25,25,25,25,25,24,22,25,25,23,25,25,20,24,25,24,25,25,22,24,25,24,25,24,25,25,24,25,25,25,25,22,25,25,25,24,25,24,25,18];

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Stack Blur Filter
(function (wd) {
    "use strict";

    var StackBlur;

    /**
     * Represent the `webDoodling.StackBlur`.
     *
     * @class webDoodling.StackBlur
     *
     * @example
     * wd.Image({
     *    x: 0,
     *    y: 0,
     *    keepOriginal: true,
     *    source: "../(media)/img/boat.png",
     *    filters: [
     *       wd.StackBlur(25)
     *    ]
     * })
     *
     *
     * @extends wd.Filter
     * @public
     * @version 1.0
     **/
    StackBlur = wd.Class({
        /**
         * Returns the `type` of `webDoodling.StackBlur`, always returns 'StackBlur'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.StackBlur
         * @public
         * @version 1.0
         **/
        type: wd.type("StackBlur"),

        /**
         * Gets or sets the amount of radius required for this filter.
         *
         * @field {number} radius
         * @default 10
         * Range from 0 to 500
         *
         * @memberOf webDoodling.StackBlur
         * @public
         * @version 1.0
         **/
        radius: wd.property({
            value: 10,
            get: function () {
                return this._radius;
            },
            set: function (v) {
                this._radius = Math.min(Math.max(v, 0), 500);
            }
        }),

        /**
         * Initializes the new instance of the `webDoodling.StackBlur` with default or
         * specified parameters.
         *
         * @constructor init(o)
         * @param {object} The initialization object in JSON format.
         *
         * @example
         * var blurFilter1 = new webDoodling.StackBlur(10);
         *
         * // Initialize object.
         * var blurFilter2 = new webDoodling.StackBlur({
         *    id: 'blur-filter2',
         *    radius: 10
         * });
         *
         * var blurFilter3 = new webDoodling.StackBlur();
         * blurFilter3.radius = 30;
         *
         * @constructor init(radius)
         * @param {number} radius The radius of area for stack blur filter.
         *
         * @memberOf webDoodling.StackBlur
         * @public
         * @version 1.0
         **/
        init: function init() {
            var arg = arguments[0];

            this.base();
            this.serializables("radius");

            if (wd.is.number(arg)) {
                this.radius = arg;
            }
            else if(wd.is.plainObject(arg)) {
                this.deserialize(arg);
            }
        },


        /**
         * Returs the filtered image data after processing for stack blur effect.
         *
         * @function filter(ctx, imageData)
         * @param {number} imageData The image data to be proecessed for the stack blur effect.
         * @param {context} ctx The 2D context of canvas.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.StackBlur
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {
            var x, y, i, p, yp, yi, yw, rSum, gSum, bSum, aSum,
                rOutSum, gOutSum, bOutSum, aOutSum,
                rInSum, gInSum, bInSum, aInSum, pr, pg, pb, pa, rbs, r, g, b, a, index,
                data = imageData.data,
                width = imageData.width,
                height = imageData.height,
                radius = this.radius,
                mul = _mul,
                shg = _shg,
                div = (radius + radius) + 1,
                widthMinus = width - 1,
                heightMinus = height - 1,
                radiusPlus = radius + 1,
                sumFactor = radiusPlus * (radiusPlus + 1) / 2,
                stackStart = new _blurStack(),
                stackEnd = null,
                stack = stackStart,
                stackIn = null,
                stackOut = null,
                mSum = mul[radius],
                sSum = shg[radius];

            for (i = 1; i < div; i++) {
                stack = stack.next = new _blurStack();
                if(i === radiusPlus) {
                    stackEnd = stack;
                }
            }
            stack.next = stackStart;
            yw = yi = 0;
            for (y = 0; y < height; y++) {
                rInSum = gInSum = bInSum = aInSum = rSum = gSum = bSum = aSum = 0;
                rOutSum = radiusPlus * ( pr = data[yi] );
                gOutSum = radiusPlus * ( pg = data[yi + 1] );
                bOutSum = radiusPlus * ( pb = data[yi + 2] );
                aOutSum = radiusPlus * ( pa = data[yi + 3] );
                rSum += sumFactor * pr;
                gSum += sumFactor * pg;
                bSum += sumFactor * pb;
                aSum += sumFactor * pa;
                stack = stackStart;
                for (i = 0; i < radiusPlus; i++) {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack.a = pa;
                    stack = stack.next;
                }
                for (i = 1; i < radiusPlus; i++) {
                    p = yi + ((widthMinus < i ? widthMinus : i) << 2);
                    rSum += (stack.r = (pr = data[p])) * (rbs = radiusPlus - i);
                    gSum += (stack.g = (pg = data[p + 1])) * rbs;
                    bSum += (stack.b = (pb = data[p + 2])) * rbs;
                    aSum += (stack.a = (pa = data[p + 3])) * rbs;
                    rInSum += pr;
                    gInSum += pg;
                    bInSum += pb;
                    aInSum += pa;
                    stack = stack.next;
                }
                stackIn = stackStart;
                stackOut = stackEnd;
                for (x = 0; x < width; x++) {
                    data[yi + 3] = pa = (aSum * mSum) >> sSum;
                    if(pa != 0) {
                        pa = 255 / pa;
                        data[yi] = ((rSum * mSum) >> sSum) * pa;
                        data[yi + 1] = ((gSum * mSum) >> sSum) * pa;
                        data[yi + 2] = ((bSum * mSum) >> sSum) * pa;
                    }
                    else {
                        data[yi] = data[yi + 1] = data[yi + 2] = 0;
                    }
                    rSum -= rOutSum;
                    gSum -= gOutSum;
                    bSum -= bOutSum;
                    aSum -= aOutSum;

                    rOutSum -= stackIn.r;
                    gOutSum -= stackIn.g;
                    bOutSum -= stackIn.b;
                    aOutSum -= stackIn.a;

                    p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus ? p : widthMinus ) ) << 2;

                    rInSum += (stackIn.r = data[p]);
                    gInSum += (stackIn.g = data[p + 1]);
                    bInSum += (stackIn.b = data[p + 2]);
                    aInSum += (stackIn.a = data[p + 3]);

                    rSum += rInSum;
                    gSum += gInSum;
                    bSum += bInSum;
                    aSum += aInSum;

                    stackIn = stackIn.next;

                    rOutSum += (pr = stackOut.r);
                    gOutSum += (pg = stackOut.g);
                    bOutSum += (pb = stackOut.b);
                    aOutSum += (pa = stackOut.a);

                    rInSum -= pr;
                    gInSum -= pg;
                    bInSum -= pb;
                    aInSum -= pa;

                    stackOut = stackOut.next;

                    yi += 4;
                }
                yw += width;
            }
            for (x = 0; x < width; x++) {
                gInSum = bInSum = aInSum = rInSum = gSum = bSum = aSum = rSum = 0;
                yi = x << 2;
                rOutSum = radiusPlus * (pr = data[yi]);
                gOutSum = radiusPlus * (pg = data[yi + 1]);
                bOutSum = radiusPlus * (pb = data[yi + 2]);
                aOutSum = radiusPlus * (pa = data[yi + 3]);

                rSum += sumFactor * pr;
                gSum += sumFactor * pg;
                bSum += sumFactor * pb;
                aSum += sumFactor * pa;

                stack = stackStart;

                for(i = 0; i < radiusPlus; i++) {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack.a = pa;
                    stack = stack.next;
                }

                yp = width;

                for(i = 1; i <= radius; i++) {
                    yi = (yp + x) << 2;
                    rSum += (stack.r = (pr = data[yi])) * (rbs = radiusPlus - i);
                    gSum += (stack.g = (pg = data[yi + 1])) * rbs;
                    bSum += (stack.b = (pb = data[yi + 2])) * rbs;
                    aSum += (stack.a = (pa = data[yi + 3])) * rbs;
                    rInSum += pr;
                    gInSum += pg;
                    bInSum += pb;
                    aInSum += pa;
                    stack = stack.next;
                    if(i < heightMinus) {
                        yp += width;
                    }
                }
                yi = x;
                stackIn = stackStart;
                stackOut = stackEnd;
                for(y = 0; y < height; y++) {
                    p = yi << 2;
                    data[p + 3] = pa = (aSum * mSum) >> sSum;
                    if(pa > 0) {
                        pa = 255 / pa;
                        data[p] = ((rSum * mSum) >> sSum) * pa;
                        data[p + 1] = ((gSum * mSum) >> sSum) * pa;
                        data[p + 2] = ((bSum * mSum) >> sSum) * pa;
                    }
                    else {
                        data[p] = data[p + 1] = data[p + 2] = 0;
                    }
                    rSum -= rOutSum;
                    gSum -= gOutSum;
                    bSum -= bOutSum;
                    aSum -= aOutSum;
                    rOutSum -= stackIn.r;
                    gOutSum -= stackIn.g;
                    bOutSum -= stackIn.b;
                    aOutSum -= stackIn.a;

                    p = ( x + (( ( p = y + radiusPlus) < heightMinus ? p : heightMinus ) * width )) << 2;

                    rSum += (rInSum += (stackIn.r = data[p]));
                    gSum += (gInSum += (stackIn.g = data[p + 1]));
                    bSum += (bInSum += (stackIn.b = data[p + 2]));
                    aSum += (aInSum += (stackIn.a = data[p + 3]));

                    stackIn = stackIn.next;

                    rOutSum += (pr = stackOut.r);
                    gOutSum += (pg = stackOut.g);
                    bOutSum += (pb = stackOut.b);
                    aOutSum += (pa = stackOut.a);

                    rInSum -= pr;
                    gInSum -= pg;
                    bInSum -= pb;
                    aInSum -= pa;

                    stackOut = stackOut.next;

                    yi += width;
                }
            }
            for (y = 0; y < height; y += 1) {
                for (x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    r = data[index];
                    g = data[index + 1];
                    b = data[index + 2];
                    a = data[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.StackBlur].
         *
         * @memberOf webDoodling.StackBlur
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.StackBlur]";
        }
    }, wd.Filter);

    wd.StackBlur = StackBlur;

    var _mul = [512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
               454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
               482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
               437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
               497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
               320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
               446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
               329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
               505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
               399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
               324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
               268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
               451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
               385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
               332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
               289,287,285,282,280,278,275,273,271,269,267,265,263,261,259],
        _shg = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
               17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
               19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
               20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
               21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
               21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
               22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
               22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
               23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
               23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
               23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
               23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
               24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
               24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
               24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
               24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];

    function _blurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//BlendCore
(function (wd) {
    "use strict";

    /**
     * Represents the various states of assets.
     *
     * @class webDoodling.BlendMath
     *
     * @memberOf webDoodling.BlendMath
     * @public
     * @version 1.0
     **/
    wd.BlendMath = wd.Class({

        hard: function hard(a, b) {
            return (b < 128) ? (2 * a * b / 255) : (255 - 2 * (255 - a) * (255 - b) / 255);
        },

        subtract: function subtract(a, b) {
            return (a + b < 255) ? 0 : (a + b - 255);
        },

        linearBurn: function linearBurn(a, b) {
            return this.subtract(a, b);
        },

        dodge: function dodge(a, b) {
            return (b == 255) ? b : Math.min(255, ((a << 8) / (255 - b)));
        },

        burn: function burn(a, b) {
            return (b == 0) ? b : Math.max(0, (255 - ((255 - a) << 8) / b));
        },

        hardMix: function hardMix(a, b) {
            return this.vividLight(a, b) < 128 ? 0 : 255;
        },

        vividLight: function vividLight(a, b) {
            return (b < 128) ? this.burn(a, (2 * b)) : this.dodge(a, (2 * (b - 128)));
        },

        reflect: function reflect(a, b) {
            return (b == 255) ? b : Math.min(255, (a * a / (255 - b)));
        },

        phoenix: function phoenix(a, b) {
            return Math.min(a, b) - Math.max(a, b) + 255;
        },

        pinLight: function pinLight(a, b) {
            return (b < 128) ? Math.min(a, (2 * b)) : Math.max(a, (2 * (b - 128)));
        },

        add: function add(a, b) {
            return Math.min(255, (a + b));
        },

        linearLight: function linearLight(a, b) {
            return (b < 128) ? this.linearBurn(a, (2 * b)) : this.add(a, (2 * (b - 128)));
        }
    });

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd, undefined) {
    "use strict";

    var BlendFilter;

    /**
     * Provides the base class for Blends in `webDoodling.BlendFilter`.
     *
     * @class webDoodling.BlendFilter
     *
     * @extends webDoodling.Filter
     * @public
     * @version 1.0
     **/
    BlendFilter = wd.Class({
        /**
         * Returns the `type` of `webDoodling.BlendFilter`, always returns 'BlendFilter'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        type: wd.type("BlendFilter"),

        /**
         * Gets or sets the opacity of the current blend filter.
         *
         * @field {number} opacity value range from 0 to 1
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        opacity: wd.property({
            value: 1,
            get: function () {
                return this._opacity;
            },
            set: function (v) {
                this._opacity = Math.min(Math.max(v, 0), 1);
            }
        }),

        /**
         * Gets or sets the image which is going to be blended with current filter.
         *
         * @field {Canvas, webDoodling.Image, webDoodling.ImageSource} image
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        image: wd.imageSource(),

        /**
         * Gets or sets the x posistion of the blending image.
         *
         * @field {number} x
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * Gets or sets the y posistion of the blending image.
         *
         * @field {number} height
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Gets or sets the height of the blending image.
         *
         * @field {number} height
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        height: wd.attribute(),

        /**
         * Gets or sets the width posistion of the blending iamge.
         *
         * @field {number} width
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        width: wd.attribute(),

        /**
         * Initializes the new instance of the `webDoodling.BlendFilter` with default or
         * specified parameters.
         *
         * @constructor init(scale)
         * @param {number} scale The amout of dark required for brighting.
         *
         * @example
         *
         * var filter1 = new webDoodling.BlendFilter(scale);
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();

            var o = arguments[0],
                image = o;

            this.serializables("x", "y", "opacity", "height", "width", {
                key: "image",
                value: function () {
                    return this._imageSrc;
                }
            });

            if (wd.is.plainObject(o)) {
                this.deserialize(o);
            }
            else if (o !== undefined) {
                this.image = image;
            }
        },

        _calcIntersectionRegion: function _calcIntersectionRegion(baseHeight, baseWidth) {
            return wd.geometry.Rectangle.intersect(this.x, this.y, this.width, this.height, baseWidth, baseHeight);
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.BlendFilter].
         *
         * @memberOf webDoodling.BlendFilter
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.BlendFilter]";
        },

        _imageOnReady: function() {
            if (this.height === undefined) {
                this.height = this._imageHeight;
            }

            if (this.width === undefined) {
                this.width = this._imageWidth;
            }

        }


    }, wd.Filter);

    wd.BlendFilter = BlendFilter;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var DarkenBlend;

    /**
     * Represent the `webDoodling.DarkenBlend`.
     *
     * @class webDoodling.DarkenBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.DarkenBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    DarkenBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.DarkenBlend`, always returns 'DarkenBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.DarkenBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("DarkenBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.DarkenBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) +
                        (bData[index] > tData[index] ? tData[index] : bData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) +
                        (bData[index + 1] > tData[index + 1] ? tData[index + 1] : bData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) +
                        (bData[index + 2] > tData[index + 2] ? tData[index + 2] : bData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.DarkenBlend].
         *
         * @memberOf webDoodling.DarkenBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.DarkenBlend]";
        }
    }, wd.BlendFilter);

    wd.DarkenBlend = DarkenBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var ColorBurn;

    /**
     * Represent the `webDoodling.ColorBurn`.
     *
     * @class webDoodling.ColorBurn
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.ColorBurn({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    ColorBurn = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ColorBurn`, always returns 'ColorBurn'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ColorBurn
         * @public
         * @version 1.0
         **/
        type: wd.type("ColorBurn"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ColorBurn
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (c.burn(bData[index], tData[index])) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (c.burn(bData[index + 1], tData[index + 1])) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (c.burn(bData[index + 2], tData[index + 2])) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ColorBurn].
         *
         * @memberOf webDoodling.ColorBurn
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ColorBurn]";
        }
    }, wd.BlendFilter);

    wd.ColorBurn = ColorBurn;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var ColorDodge;

    /**
     * Represent the `webDoodling.ColorDodge`.
     *
     * @class webDoodling.ColorDodge
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.ColorDodge({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    ColorDodge = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ColorDodge`, always returns 'ColorDodge'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ColorDodge
         * @public
         * @version 1.0
         **/
        type: wd.type("ColorDodge"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ColorDodge
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (c.dodge(bData[index], tData[index])) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (c.dodge(bData[index + 1], tData[index + 1])) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (c.dodge(bData[index + 2], tData[index + 2])) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ColorDodge].
         *
         * @memberOf webDoodling.ColorDodge
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ColorDodge]";
        }
    }, wd.BlendFilter);

    wd.ColorDodge = ColorDodge;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var DifferenceBlend;

    /**
     * Represent the `webDoodling.DifferenceBlend`.
     *
     * @class webDoodling.DifferenceBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.DifferenceBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    DifferenceBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.DifferenceBlend`, always returns 'DifferenceBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.DifferenceBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("DifferenceBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.DifferenceBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + Math.abs((tData[index] - bData[index])) * alpha;
                    g = bData[index + 1] * (1 - alpha) + Math.abs((tData[index + 1] - bData[index + 1])) * alpha;
                    b = bData[index + 2] * (1 - alpha) + Math.abs((tData[index + 2] - bData[index + 2])) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.DifferenceBlend].
         *
         * @memberOf webDoodling.DifferenceBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.DifferenceBlend]";
        }
    }, wd.BlendFilter);

    wd.DifferenceBlend = DifferenceBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var ExclusionBlend;

    /**
     * Represent the `webDoodling.ExclusionBlend`.
     *
     * @class webDoodling.ExclusionBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.ExclusionBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    ExclusionBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ExclusionBlend`, always returns 'ExclusionBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ExclusionBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("ExclusionBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ExclusionBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (128 - 2 * (bData[index] - 128) * (tData[index] - 128) / 255) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (128 - 2 * (bData[index + 1] - 128) * (tData[index + 1] - 128) / 255) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (128 - 2 * (bData[index + 2] - 128) * (tData[index + 2] - 128) / 255) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ExclusionBlend].
         *
         * @memberOf webDoodling.ExclusionBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ExclusionBlend]";
        }
    }, wd.BlendFilter);

    wd.ExclusionBlend = ExclusionBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var HardlightBlend;

    /**
     * Represent the `webDoodling.HardlightBlend`.
     *
     * @class webDoodling.HardlightBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.HardlightBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    HardlightBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.HardlightBlend`, always returns 'HardlightBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.HardlightBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("HardlightBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.HardlightBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + c.hard(bData[index], tData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + c.hard(bData[index + 1], tData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + c.hard(bData[index + 2], tData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.HardlightBlend].
         *
         * @memberOf webDoodling.HardlightBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.HardlightBlend]";
        }
    }, wd.BlendFilter);

    wd.HardlightBlend = HardlightBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var HardmixBlend;

    /**
     * Represent the `webDoodling.HardmixBlend`.
     *
     * @class webDoodling.HardmixBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.HardmixBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    HardmixBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.HardmixBlend`, always returns 'HardmixBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.HardmixBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("HardmixBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.HardmixBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + c.hardMix(bData[index], tData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + c.hardMix(bData[index + 1], tData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + c.hardMix(bData[index + 2], tData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.HardmixBlend].
         *
         * @memberOf webDoodling.HardmixBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.HardmixBlend]";
        }
    }, wd.BlendFilter);

    wd.HardmixBlend = HardmixBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var LightenBlend;

    /**
     * Represent the `webDoodling.LightenBlend`.
     *
     * @class webDoodling.LightenBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.LightenBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    LightenBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.LightenBlend`, always returns 'LightenBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.LightenBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("LightenBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.LightenBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (tData[index] > bData[index] ? tData[index] : bData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (tData[index + 1] > bData[index + 1] ? tData[index + 1] : bData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (tData[index + 2] > bData[index + 2] ? tData[index + 2] : bData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.LightenBlend].
         *
         * @memberOf webDoodling.LightenBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.LightenBlend]";
        }
    }, wd.BlendFilter);

    wd.LightenBlend = LightenBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var LinearBurn;

    /**
     * Represent the `webDoodling.LinearBurn`.
     *
     * @class webDoodling.LinearBurn
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.LinearBurn({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    LinearBurn = wd.Class({
        /**
         * Returns the `type` of `webDoodling.LinearBurn`, always returns 'LinearBurn'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.LinearBurn
         * @public
         * @version 1.0
         **/
        type: wd.type("LinearBurn"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.LinearBurn
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (c.linearBurn(bData[index], tData[index])) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (c.linearBurn(bData[index + 1], tData[index + 1])) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (c.linearBurn(bData[index + 2], tData[index + 2])) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.LinearBurn].
         *
         * @memberOf webDoodling.LinearBurn
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.LinearBurn]";
        }
    }, wd.BlendFilter);

    wd.LinearBurn = LinearBurn;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var LinearLight;

    /**
     * Represent the `webDoodling.LinearLight`.
     *
     * @class webDoodling.LinearLight
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.LinearLight({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    LinearLight = wd.Class({
        /**
         * Returns the `type` of `webDoodling.LinearLight`, always returns 'LinearLight'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.LinearLight
         * @public
         * @version 1.0
         **/
        type: wd.type("LinearLight"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.LinearLight
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (c.linearLight(bData[index], tData[index])) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (c.linearLight(bData[index + 1], tData[index + 1])) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (c.linearLight(bData[index + 2], tData[index + 2])) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.LinearLight].
         *
         * @memberOf webDoodling.LinearLight
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.LinearLight]";
        }
    }, wd.BlendFilter);

    wd.LinearLight = LinearLight;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var MultiplyBlend;

    /**
     * Represent the `webDoodling.MultiplyBlend`.
     *
     * @class webDoodling.MultiplyBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.MultiplyBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    MultiplyBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.MultiplyBlend`, always returns 'MultiplyBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.MultiplyBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("MultiplyBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.MultiplyBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + ((tData[index] * bData[index]) / 255) * alpha;
                    g = bData[index + 1] * (1 - alpha) + ((tData[index + 1] * bData[index + 1]) / 255) * alpha;
                    b = bData[index + 2] * (1 - alpha) + ((tData[index + 2] * bData[index + 2]) / 255) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.MultiplyBlend].
         *
         * @memberOf webDoodling.MultiplyBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.MultiplyBlend]";
        }
    }, wd.BlendFilter);

    wd.MultiplyBlend = MultiplyBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var OverlayBlend;

    /**
     * Represent the `webDoodling.OverlayBlend`.
     *
     * @class webDoodling.OverlayBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.OverlayBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    OverlayBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.OverlayBlend`, always returns 'OverlayBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.OverlayBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("OverlayBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.OverlayBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    if (bData[index] > 128) {
                        r = bData[index] * (1 - alpha) + (255 - 2 * (255 - tData[index]) * (255 - bData[index]) / 255) * alpha;
                    } else {
                        r = bData[index] * (1 - alpha) + ((bData[index] * tData[index] * 2) / 255) * alpha;
                    }

                    if (bData[index + 1] > 128) {
                        g = bData[index + 1] * (1 - alpha) + (255 - 2 * (255 - tData[index + 1]) * (255 - bData[index + 1]) / 255) * alpha;
                    } else {
                        g = bData[index + 1] * (1 - alpha) + ((bData[index + 1] * tData[index + 1] * 2) / 255) * alpha;
                    }

                    if (bData[index + 2] > 128) {
                        b = bData[index + 2] * (1 - alpha) + (255 - 2 * (255 - tData[index + 2]) * (255 - bData[index + 2]) / 255)  * alpha;
                    } else {
                        b = bData[index + 2] * (1 - alpha) + ((bData[index + 2] * tData[index + 2] * 2) / 255) * alpha;
                    }
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.OverlayBlend].
         *
         * @memberOf webDoodling.OverlayBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.OverlayBlend]";
        }
    }, wd.BlendFilter);

    wd.OverlayBlend = OverlayBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var PhoenixBlend;

    /**
     * Represent the `webDoodling.PhoenixBlend`.
     *
     * @class webDoodling.PhoenixBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.PhoenixBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    PhoenixBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.PhoenixBlend`, always returns 'PhoenixBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.PhoenixBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("PhoenixBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.PhoenixBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + c.phoenix(bData[index], tData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + c.phoenix(bData[index + 1], tData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + c.phoenix(bData[index + 2], tData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.PhoenixBlend].
         *
         * @memberOf webDoodling.PhoenixBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.PhoenixBlend]";
        }
    }, wd.BlendFilter);

    wd.PhoenixBlend = PhoenixBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var PinlightBlend;

    /**
     * Represent the `webDoodling.PinlightBlend`.
     *
     * @class webDoodling.PinlightBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.PinlightBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    PinlightBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.PinlightBlend`, always returns 'PinlightBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.PinlightBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("PinlightBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.PinlightBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + c.pinLight(bData[index], tData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + c.pinLight(bData[index + 1], tData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + c.pinLight(bData[index + 2], tData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.PinlightBlend].
         *
         * @memberOf webDoodling.PinlightBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.PinlightBlend]";
        }
    }, wd.BlendFilter);

    wd.PinlightBlend = PinlightBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var ReflectBlend;

    /**
     * Represent the `webDoodling.ReflectBlend`.
     *
     * @class webDoodling.ReflectBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.ReflectBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    ReflectBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ReflectBlend`, always returns 'ReflectBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ReflectBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("ReflectBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ReflectBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + c.reflect(bData[index], tData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + c.reflect(bData[index + 1], tData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + c.reflect(bData[index + 2], tData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ReflectBlend].
         *
         * @memberOf webDoodling.ReflectBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ReflectBlend]";
        }
    }, wd.BlendFilter);

    wd.ReflectBlend = ReflectBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var ScreenBlend;

    /**
     * Represent the `webDoodling.ScreenBlend`.
     *
     * @class webDoodling.ScreenBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.ScreenBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    ScreenBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.ScreenBlend`, always returns 'ScreenBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ScreenBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("ScreenBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.ScreenBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (255 - ((255 - tData[index]) * (255 - bData[index])) / 255) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (255 - ((255 - tData[index + 1]) * (255 - bData[index + 1])) / 255) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (255 - ((255 - tData[index + 2]) * (255 - bData[index + 2])) / 255) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ScreenBlend].
         *
         * @memberOf webDoodling.ScreenBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ScreenBlend]";
        }
    }, wd.BlendFilter);

    wd.ScreenBlend = ScreenBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var SoftlightBlend;

    /**
     * Represent the `webDoodling.SoftlightBlend`.
     *
     * @class webDoodling.SoftlightBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.SoftlightBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    SoftlightBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.SoftlightBlend`, always returns 'SoftlightBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.SoftlightBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("SoftlightBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.SoftlightBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    if (bData[index] > 128) {
                        r = bData[index] * (1 - alpha) + (255 - ((255 - bData[index]) * (255 - (tData[index] - 128))) / 255) * alpha;
                    } else {
                        r = bData[index] * (1 - alpha) + ((bData[index] * (tData[index] + 128)) / 255) * alpha;
                    }

                    if (bData[index + 1] > 128) {
                        g = bData[index + 1] * (1 - alpha) + (255 - ((255 - bData[index + 1]) * (255 - (tData[index + 1] - 128))) / 255) * alpha;
                    } else {
                        g = bData[index + 1] * (1 - alpha) + ((bData[index + 1] * (tData[index + 1] + 128)) / 255) * alpha;
                    }

                    if (bData[index + 2] > 128) {
                        b = bData[index + 2] * (1 - alpha) + (255 - ((255 - bData[index + 2]) * (255 - (tData[index + 2] - 128))) / 255) * alpha;
                    } else {
                        b = bData[index + 2] * (1 - alpha) + ((bData[index + 2] * (tData[index + 2] + 128)) / 255) * alpha;
                    }
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.SoftlightBlend].
         *
         * @memberOf webDoodling.SoftlightBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.SoftlightBlend]";
        }
    }, wd.BlendFilter);

    wd.SoftlightBlend = SoftlightBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var VividlightBlend;

    /**
     * Represent the `webDoodling.VividlightBlend`.
     *
     * @class webDoodling.VividlightBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.VividlightBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends wd.BlendFilter
     * @public
     * @version 1.0
     **/
    VividlightBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.VividlightBlend`, always returns 'VividlightBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.VividlightBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("VividlightBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.VividlightBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity,
                c = new wd.BlendMath();

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + c.vividLight(bData[index], tData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + c.vividLight(bData[index + 1], tData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + c.vividLight(bData[index + 2], tData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.VividlightBlend].
         *
         * @memberOf webDoodling.VividlightBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.VividlightBlend]";
        }
    }, wd.BlendFilter);

    wd.VividlightBlend = VividlightBlend;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Blend Filter
(function (wd) {
    "use strict";

    var AddBlend;

    /**
     * Represent the `webDoodling.AddBlend`.
     *
     * @class webDoodling.AddBlend
     *
     * @example
     * wd.Image({
     *     x: 50,
     *     y: 50,
     *     draggable: true,
     *     source: assetManager.assets.get("paradise"),
     *     filters: [
     *         wd.AddBlend({
     *              x: 150,
     *              y: 50,
     *              image: assetManager.assets.get("smiley"),
     *              opacity: 1
     *        })
     *     ]
     * })
     *
     *
     * @extends webDoodling.BlendFilter
     * @public
     * @version 1.0
     **/
    AddBlend = wd.Class({
        /**
         * Returns the `type` of `webDoodling.AddBlend`, always returns 'AddBlend'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AddBlend
         * @public
         * @version 1.0
         **/
        type: wd.type("AddBlend"),

        /**
         * Returs the filtered image data after processing for darken effect.
         *
         * @function filter(imageData)
         * @param {number} imageData The image data to be proecessed for the bright effect.
         * @returns {[object]} Returns the array of filtered image data object.
         *
         * @memberOf webDoodling.AddBlend
         * @public
         * @version 1.0
         **/
        filter: function filter(ctx, imageData) {

            var imageCanvas, imageContext,
                region, bData, tData,
                alpha, y, x, index,
                r, g, b, a, setSource,
                width = imageData.width,
                height = imageData.height,
                image = this._imageMedia,
                opacity = this.opacity;

            region = this._calcIntersectionRegion(imageData.height, imageData.width);

            if(region === null) {
                return imageData;
            }

            bData = imageData.data;
            imageCanvas = document.createElement("canvas"),
            imageContext = imageCanvas.getContext("2d");
            imageCanvas.width = imageData.width;
            imageCanvas.height = imageData.height;
            imageContext.drawImage(image, region.x, region.y);
            tData = imageContext.getImageData(0, 0, width, height).data;

            for(y = 0; y < height; y += 1) {
                setSource = false;
                if (y < region.y  || y > region.y+region.height) {
                    setSource = true;
                }
                for(x = 0; x < width; x += 1) {
                    index = (y * width + x) * 4;
                    if (setSource === true|| x < region.x || x > region.x + region.width) {
                        this.setPixel(index, bData[index], bData[index + 1], bData[index + 2], bData[index + 3] );
                        continue;
                    }
                    alpha = tData[index + 3] / 255 * opacity;
                    r = bData[index] * (1 - alpha) + (bData[index] + tData[index]) * alpha;
                    g = bData[index + 1] * (1 - alpha) + (bData[index + 1] + tData[index + 1]) * alpha;
                    b = bData[index + 2] * (1 - alpha) + (bData[index + 2] + tData[index + 2]) * alpha;
                    a = bData[index + 3];
                    this.setPixel(index, r, g, b, a);
                }
            }
            return imageData;
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AddBlend].
         *
         * @memberOf webDoodling.AddBlend
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AddBlend]";
        }
    }, wd.BlendFilter);

    wd.AddBlend = AddBlend;

})(window.webDoodling);
(function (wd, undefined) {
    "use strict";

    var AudioSource;

    /**
     * Represents the class to check the type and set the source of the audio.
     *
     * @class webDoodling.AudioSource
     *
     * @memberOf webDoodling.AudioSource
     * @extends webDoodling.Serializable
     * @public
     * @version 1.0
     **/
    AudioSource = wd.Class({
        /**
         * Returns the `type` of `webDoodling.AudioSource`, always returns 'AudioSource'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.AudioSource
         * @public
         * @version 1.0
         **/
        type: wd.type("AudioSource"),

        /** Gets or Sets the browser supported source
          *
          * @field {string, Array(string)} source
          * @defualt ""
          *
          * @memberOf webDoodling.AudioSource
          * @public
          * @version 1.0
          **/
        source: wd.property({
            value: "",
            get: function () {
                return this._source;
            },
            set: function (value) {
                var i, iLen, support;

                if (wd.is.array(value)) {
                    for (i = 0, iLen = value.length; i < iLen; i++) {
                        support = wd.is.audioSupported(value[i]);
                        if (support !== "") {
                            if (support === "probably" || value.length === 1) {
                                this._source = value[i];
                                break;
                            }
                            this._source = value[i];
                        }
                    }
                }
                else {
                    if (!wd.is.string(value)) {
                        if (value instanceof Audio) {
                            support = wd.is.audioSupported(value.src);
                        }
                    }
                    else {
                        support = wd.is.audioSupported(value);
                    }
                    if (support !== "") {
                        this._source = value;
                    }
                    else {
                        throw new wd.Error("wd-audio-not-supported");
                    }
                }
                if (this._onSourceChanged !== undefined) {
                    this._onSourceChanged();
                }
            }
        }),

        /**
          * Initialize the audio source of the `webDoodling.AudioSource`.
          * -here we can check the browser support and also type support.
          *
          * @constructor init()
          *
          * @memberOf webDoodling.AudioSource
          * @public
          * @version 1.0
          **/
        init: function init() {
            this.base();
            this.serializables("source");
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.AudioSource].
         *
         * @memberOf webDoodling.AudioSource
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.AudioSource]";
        }
    }, wd.Serializable);

    wd.AudioSource = AudioSource;
})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The HTML5 Audio
(function (wd, undefined) {
    "use strict";

    var HTML5AudioSource;

    /**
     * Represents the `webDoodling.HTML5AudioSource` class which is used to play audio.
     *
     * @class webDoodling.HTML5AudioSource
     *
     * @example
     * var audio = new wd.HTML5AudioSource('../path/sound.mp3', true);
     *
     * var audio = new wd.HTML5AudioSource();
     * audio.source = '../path/sound.mp3';
     * audio.autoPlay = false;
     *
     * var audio = new wd.HTML5AudioSource({
     *      source: '../path/sound.mp3',
     *      autoPlay: false,
     *      startPosition: 3,
     *      stopPosition: 5
     * })
     *
     * @memberOf webDoodling
     * @extends webDoodling.AudioSource
     * @public
     * @version 1.0
     **/
    HTML5AudioSource = wd.Class({
        /**
         * Returns the `type` of `webDoodling.HTML5AudioSource`, always returns 'HTML5AudioSource'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        type: wd.type("HTML5AudioSource"),

        /**
         * Represents the callback function which is invoked
         * while audio is playing and change the currentTime.
         *
         * @callback onTimeUpdate(currentTime)
         * @param {number} currentTime
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        onTimeUpdate: wd.attribute(false),

        /**
         * Represents the callback function which is invoked
         * while audio is start playing.
         *
         * @callback onPlay()
         * @default false
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        onPlay: wd.attribute(false),

        /**
         * Represents the callback function which is invoked
         * while audio is in paused mode.
         *
         * @callback onPause()
         * @default false
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        onPause: wd.attribute(false),

        /**
         * Represents the callback function which is invoked
         * while audio is stopped.
         *
         * @callback onStop()
         * @default false
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        onStop: wd.attribute(false),

        /**
         * Represents the callback function which is invoked while audio file is load.
         * If the audio is start loading, onLoad is executed .
         *
         * @callback onLoad()
         * @default false
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        onLoad: wd.attribute(false),

        /**
         * Represents the callback function which is invoked while audio has some errors.
         * If the audio file has some error , onError is executed .
         *
         * @callback onError(error)
         * @param {string} error The error message.
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        onError: wd.attribute(false),

        /**
          * Returns the duration of the audio.
          *
          * @readonly {number} duration
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        duration: wd.readonly(0),

         /**
          * Get or Sets the `startPosition` of the `webDoodling.HTML5AudioSource`.
          * `startPosition` is used to set play Position of the audio.
          *
          * @field {number} startPosition.
          *
          * @example
          * var audio = new wd.HTML5AudioSource();
          * audio.startPosition = 2;
          * audio is started from 2 seconds.
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        startPosition: wd.property({
            value: 0,
            get: function () {
                return this._startPosition;
            },
            set: function (v) {
                if (this._startPosition !== v) {
                    this._startPosition = v;
                    if (this.ready === true) {
                        this._validateStartPosition(v);
                    }
                }
            }
        }),

        /**
          * Gets or Sets the `stopPosition` of the `webDoodling.HTML5AudioSource`.
          * -Stop position must be in range. Range is from startPosition to audio duration.
          *
          * @field {number} stopPosition
          *
          * @example
          * var audio = new wd.HTML5AudioSource();
          * audio.startPosition = 2;
          * audio.stopPosition = 5;
          * audio is started from 2 second and stopped at 5 seconds.
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        stopPosition: wd.property({
            get: function () {
                if (this._stopPosition !== undefined) {
                    return this._stopPosition;
                }
                else if (this._bufferData !== undefined) {
                    return this._bufferData.duration;
                }
                return 0;
            },
            set: function (v) {
                if (this._stopPosition !== v) {
                    this._stopPosition = v;
                    if (this.ready === true) {
                        this._validateStopPosition(v);
                    }
                }
            }
        }),

       /**
          * Returns playing status of audio.
          * If `isPlaying` returns true then audio is in playing mode.
          *
          * @readonly {boolean} isPlaying.
          * @default false
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        isPlaying: wd.property({
            value: false,
            get: function () {
                if (this._audio !== undefined) {
                    return !this._audio.paused;
                }
            }
        }),

        /**
          * Returns `currentTime` of the `webDoodling.HTML5AudioSource`
          *
          * @readonly {number} currentTime
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        currentTime: wd.readonly(),

        /**
          * Returns the buffer Duration of audio.
          *
          * @readonly {number} bufferDuration
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        bufferDuration: wd.readonly(),

        /**
          * Gets or Sets the `playbackRate` of the `webDoodling.HTML5AudioSource`.
          * -Sets the audio playing speed.
          * -If playbackRate is 2.0 then its playing audio with double speed.
          * -If playbackRate is 0.5 then its playing audio with half speed.
          * -Its only set when audio is not playing.
          *
          * @field {number} playbackRate
          * @default 1.0
          *
          * @example
          * var audio = new wd.HTML5AudioSource();
          * audio.playbackRate = 2.0;
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        playbackRate: wd.property({
            value: 1.0,
            get: function () {
                return this._playbackRate;
            },
            set: function (v) {
                if (!this.isPlaying) {
                    this._playbackRate = v;
                }
            }
        }),

        /**
          * Gets or Sets the `volume` of the `webDoodling.HTML5AudioSource`
          * -Volume must be in range. Range from 0 to  1.
          *
          * @field {number} volume
          * @default 1
          *
          * @example
          * var audio = new wd.HTML5AudioSource();
          * audio.volume = 0.5;
          * audio is playing with 50% volume.
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        volume: wd.property({
            value: 1,
            get: function () {
                return this._volume;
            },
            set: function (v) {
                this._volume = v;
                if (this._audio !== undefined) {
                    this._audio.volume = Math.min(Math.max(v, 0), 1);
                }
            }
        }),

         /**
          * Gets or Sets `loop` of the `webDoodling.HTML5AudioSource`
          * -If `loop` is `true` then audio is in loop mode.
          * -Its only set when audio is not playing.
          *
          * @field {boolean} loop
          * @default false
          *
          * @example
          * var audio = new wd.HTML5AudioSource();
          * audio.loop = true;
          * audio is playing in loop.
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        loop: wd.property({
            value: false,
            get: function () {
                return this._loop;
            },
            set: function (v) {
                if (!this.isPlaying) {
                    this._loop = v;
                }
            }
        }),

        /**
          * Gets or Sets `muted` of the `webDoodling.HTML5AudioSource`
          * If `muted` is true then audio has no sound.
          *
          * @field {boolean} muted
          * @default false
          *
          * @example
          * var audio = new wd.HTML5AudioSource();
          * audio.muted = true;
          * audio has no sound.
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        muted: wd.property({
            value: false,
            get: function () {
                return this._muted;
            },
            set: function (v) {
                this._muted = v;
                if (this._audio !== undefined) {
                    this._audio.muted = v;
                }
            }
        }),

        /**
          * Returns `true` or `false` to indicate
          * whether audio is ready to play or not.
          *
          * @readonly {boolean} ready
          * @default false
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        ready: wd.readonly(false),

        /**
          * Initialize the audio with the `webDoodling.HTML5AudioSource`.
          *
          * @constructor init()
          *
          * @constructor init(src, autoPlay)
          * @param {string} src The source of the audio file.
          * @param {boolean} autoPlay The source of the audio file.
          *
          * @constructor init(o)
          * @param {object} o The audio object.
          *
          * @example
          * var audio = new wd.HTML5AudioSource("../path/sound.mp3", false);
          *
          * var audio = new wd.HTML5AudioSource();
          * audio.source = "../path/sound.mp3";
          * audio.autoPlay = false;
          *
          * var audio = new wd.HTML5AudioSource({
          *   source: "../path/sound.mp3",
          *   autoPlay: false
          * });
          *
          * @memberOf webDoodling.HTML5AudioSource
          * @public
          * @version 1.0
          **/
        init: function init() {
            var arg1 = arguments[0],
                argLen = arguments.length;

            this.base();
            this.serializables("playbackRate", "startPosition", "stopPosition", "autoPlay", "loop", "muted", "volume");

            if (argLen === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                } else {
                    this.source = arg1;
                }
            }
            else {
                if (arg1 !== undefined) this.source = arg1;
            }
        },


        /**
         * Play the audio of the `webDoodling.HTML5AudioSource`
         *
         * @function play()
         *
         * @function play(position)
         * @param {[number]} position Play the audio from proper position.
         *
         * @example
         * var audio = new wd.HTML5AudioSource('../path/sound.mp3', false);
         * audio.play();
         *
         * var audio = new wd.HTML5AudioSource('../path/sound.mp3', false);
         * audio.play(3);
         * audio is play from 3 seconds.
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        play: function play(position) {
            var startTime = this.startPosition,
                self = this,
                stopTime = this.stopPosition,
                diff = startTime - stopTime;

            //If audio is undefined, if audio is not ready for playing,
            // if song is in playing mode then return
            if (this._audio === undefined || this.ready === false || this.isPlaying === true || diff === 0) {
                return;
            }

            //Set currentTime and loop. then play the audio.
            this._audio.currentTime = Math.min(Math.max(position || this._audio.currentTime, startTime), stopTime);
            this._currentTime = this._audio.currentTime;
            this._audio.play();
            this._audio.loop = this.loop;

            //timeupdate for calculating audio currenttime.
            this._audio.ontimeupdate = function () {
                var audio = self._audio,
                    loopRestarted = audio.currentTime < self.currentTime;

                self._currentTime = audio.currentTime;
                //if currentTime is greater than stopTime then set to start position.
                if (loopRestarted || self.currentTime >= stopTime) {
                    self._currentTime = startTime;
                    //If loop is true then set audio currentTime to startTime.
                    if (self.loop === true) {
                        audio.currentTime = startTime;
                    }
                    else {
                        //If loop is false then call stop function .
                        self.stop();
                    }
                }
                if (!isNaN(audio.currentTime)) {
                    audio.playbackRate = self.playbackRate;
                }
                //call timeupdate event callback.
                if (wd.is.func(self.onTimeUpdate)) {
                    self.onTimeUpdate(self.currentTime);
                }
            };
            //call play event callback.
            if (wd.is.func(this.onPlay)) {
                this.onPlay();
            }
        },

        /**
         * Pause the audio of the `webDoodling.HTML5AudioSource`.
         *
         * @function pause()
         *
         * @example
         * var audio = new wd.HTML5AudioSource('../path/sound.mp3', false);
         * audio.pause()
         * audio is paused at current position.
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            //If source is undefined then return.
            if (this._source === undefined) {
                return;
            }
            //If audio is pause then audio is stop.
            this._audio.pause();
            //If audio is paused then set the audio currentTime to currentTime.
            this._audio.currentTime = this.currentTime;
            //call the pause event callback
            if (wd.is.func(this.onPause)) {
                this.onPause();
            }
        },

        /**
         * Stop the audio of the `webDoodling.HTML5AudioSource`.
         *
         * @function stop()
         *
         * @example
         * var audio = new wd.HTML5AudioSource('../path/sound.mp3', false);
         * audio.stop()
         * audio is stopped from current position.
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        stop: function stop() {
            //If source is undefined then return.
            if (this._source === undefined) {
                return;
            }
            this._audio.pause();
            //If audio is stopped then set the audio currentTime to startPosition.
            this._audio.currentTime = this.startPosition || 0;
            //call the stop event callback.
            if (wd.is.func(this.onStop)) {
                this.onStop();
            }
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.HTML5AudioSource].
         *
         * @memberOf webDoodling.HTML5AudioSource
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.HTML5AudioSource]";
        },

        //To validate start position
        _validateStartPosition: function (value) {
            this._startPosition = Math.min(Math.max(value, 0), this.duration);
        },

        //To validate stop Position
        _validateStopPosition: function (value) {
            this._stopPosition = Math.min(Math.max(value, this.startPosition), this.duration);
        },

        //call when source changed.
        _onSourceChanged: function () {
            var self = this,
                source = this._source;

            //If source is htmlaudioelement
            if (source instanceof HTMLAudioElement) {
                this._audio = source;
            }
            else {
                this._audio = new Audio(source);
            }

            //assign values because when audio is create then only we can assign values
            this._audio.playbackRate = this.playbackRate;
            this._audio.volume = this.volume;
            this._audio.muted = this.muted;
            // this._audio.loop = this.loop;
            this._currentTime = this._audio.currentTime;

            //get duration when all meta data is completly loaded.
            this._audio.onloadedmetadata = function () {
                self._duration = self._audio.duration;
                self._bufferDuration = self._audio.buffered.end(0);
                self._validateStartPosition(self.startPosition);
                self._validateStopPosition(self.stopPosition);
                self._audio.currentTime = Math.min(Math.max(self._audio.currentTime, 0), self.duration);
                self._currentTime = Math.min(Math.max(self.currentTime, 0), self.duration);
                self._ready = true;
                if (wd.is.func(self.onLoad)) {
                    self.onLoad();
                }
            };

            //error callback
            this._audio.onerror = function () {
                var audio = self._audio;
                switch (audio.error.code) {
                case 1:
                    if (wd.is.func(self.onError)) {
                        self.onError(wd.errors.get("wd-audio-playback-aborted"));
                    }
                    break;
                case 2:
                    if (wd.is.func(self.onError)) {
                        self.onError(wd.errors.get("wd-audio-download-failed"));
                    }
                    break;
                case 3:
                    if (wd.is.func(self.onError)) {
                        self.onError(wd.errors.get("wd-audio-not-supported"));
                    }
                    break;
                case 4:
                    if (wd.is.func(self.onError)) {
                        self.onError(wd.errors.get("wd-audio-not-loaded"));
                    }
                    break;
                default:
                    if (wd.is.func(self.onError)) {
                        self.onError(wd.errors.get("wd-unknown-error"));
                    }
                }
            };
        }
    }, wd.AudioSource);

    wd.HTML5AudioSource = HTML5AudioSource;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Web Audio Loader
(function (wd) {
    "use strict";

    var WebAudioLoader;

    /**
     * Represents the class to load the web audio file of `webDoodling.WebAudioLoader`.
     *
     * @class webDoodling.WebAudioLoader
     *
     * @example
     * var audio = new webDoodling.WebAudioLoader(context, "../path/sound.mp3");
     *
     * @memberOf webDoodling
     * @public
     * @version 1.0
     **/
    WebAudioLoader = wd.Class({
        /**
         * Returns the `type` of `webDoodling.WebAudioLoader`, always returns 'WebAudioLoader'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.WebAudioLoader
         * @public
         * @version 1.0
         **/
        type: wd.type("WebAudioLoader"),

        /**
         * Represents the callback function which is invoked while audio file is load.
         * If the audio is start loading, onLoad is executed .
         *
         * @callback onLoad
         *
         * @memberOf webDoodling.WebAudioLoader
         * @public
         * @version 1.0
         **/
        onLoad: wd.attribute(false),

        /**
         * Represents the callback function which is invoked while audio has some errors.
         * If the audio file has some error , onError is executed .
         *
         * @callback onError
         *
         * @memberOf webDoodling.WebAudioLoader
         * @public
         * @version 1.0
         **/
        onError: wd.attribute(false),

        /**
         * Returns the decoded audio buffer data.
         *
         * @readonly {number} bufferData
         *
         * @memberOf webDoodling.WebAudioLoader
         * @public
         * @version 1.0
         **/
        bufferData: wd.readonly(),

        /**
          * Initialize the decode audio data with the `webDoodling.WebAudioLoader`.
          *
          * @constructor init(context, source)
          * @param {AudioContext} context The web audio context class.
          * @param {string} source The audio file.
          *
          * @example
          * var audio = new wd.WebAudioLoader(context, "../path/sound.mp3");
          *
          * @memberOf webDoodling.WebAudioLoader
          * @public
          * @version 1.0
          **/
        init: function init(context, source) {
            this._loader(context, source);
        },

        //decode audio data
        _loader: function (context, source) {
            var request,
                self = this;

            request = new XMLHttpRequest();
            request.open("GET", source, true);
            request.responseType = "arraybuffer";
            request.onload = function () {
                if (!context.decodeAudioData) {
                    self._bufferData = context.createBuffer();
                }
                else {
                    context.decodeAudioData(request.response, function (decodedData) {
                        if (!decodedData) {
                            if (wd.is.func(self.onError)) {
                                self.onError(wd.errors.get("wd-audio-not-supported"));
                            }
                        }
                        else {
                            self._bufferData = decodedData;
                            if (wd.is.func(self.onLoad)) {
                                self.onLoad();
                            }
                        }
                    });
                }
            };
            request.onerror = function (error) {
                if (wd.is.func(self.onError)) {
                    self.onError(error);
                }
            };
            //TODO: Test pending.
            // wd-xhr-timeout
            request.ontimeout = function () {
                if (wd.is.func(self.onError)) {
                    self.onError(wd.errors.get("wd-http-request-timeout"));
                }
            };
            //TODO: Test pending.
            // wd-xhr-abort
            request.onabort = function () {
                if (wd.is.func(self.onError)) {
                    self.onError(wd.errors.get("wd-http-request-aborted"));
                }
            };
            request.send();
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.WebAudioLoader].
         *
         * @memberOf webDoodling.WebAudioLoader
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.WebAudioLoader]";
        }
    });

    wd.WebAudioLoader = WebAudioLoader;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The Web Audio
(function (wd, undefined) {
    "use strict";

    var WebAudioSource,
        AudioContextClass,
        audioContext;

    AudioContextClass = (window.AudioContext ||
                         window.webkitAudioContext ||
                         window.mozAudioContext ||
                         window.msAudioContext ||
                         window.oAudioContext);

    /**
     * Represents the `webDoodling.WebAudioSource` class which is used to play audio.
     *
     * @class webDoodling.WebAudioSource
     *
     * @example
     * var audio = new wd.WebAudioSource('../path/sound.mp3', true);
     *
     * var audio = new wd.WebAudioSource();
     * audio.source = '../path/sound.mp3';
     * audio.autoPlay = false;
     *
     * var audio = new wd.WebAudioSource({
     *      source: '../path/sound.mp3',
     *      autoPlay: false,
     *      startPosition: 3,
     *      stopPosition: 5
     * });
     *
     * @memberOf webDoodling
     * @extends webDoodling.AudioSource
     * @public
     * @version 1.0
     **/
    WebAudioSource = wd.Class({
        /**
         * Returns the `type` of `webDoodling.WebAudioSource`, always returns 'WebAudioSource'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        type: wd.type("WebAudioSource"),

        /**
         * Represents the callback function which is invoked
         * while audio is playing and current time is changed.
         *
         * @callback onTimeUpdate
         * @param {number} currentTime The current time.
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        onTimeUpdate: wd.attribute(false),

        /**
         * Represents the callback function which is invoked
         * while audio is start playing.
         *
         * @callback onPlay
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        onPlay: wd.attribute(false),

        /**
         * Represents the callback function which is invoked
         * while audio is in paused mode.
         *
         * @callback onPause
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        onPause: wd.attribute(false),

        /**
         * Represents the callback function which is invoked
         * while audio is stopped.
         *
         * @callback onStop
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        onStop: wd.attribute(false),

        /**
          * Represents the callback function which is invoked
          * while audio is successfully loaded.
          *
          * @callback onLoad
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        onLoad: wd.attribute(false),

        /**
          * Represents the callback function which is invoked
          * while audio has some error.
          *
          * @callback onError
          * @param {string} error The error message.
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        onError: wd.attribute(false),

        /**
          * Returns the duration of audio.
          *
          * @readonly {number} duration.
          * @default 0
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        duration: wd.readonly(0),

        /**
          * Sets the playbackRate of the `webDoodling.WebAudioSource`.
          * -Sets the audio playing speed.
          * -If want pitch in audio then use `webDoodling.WebAudioSource`.
          * -If playbackRate is 2.0 then its playing audio with double speed.
          * -If playbackRate is 0.5 then its playing audio with half speed.
          * -Its only set when audio is not playing.
          *
          * @field {number} playbackRate
          * @default 1.0
          *
          * @example
          * var audio = new wd.WebAudioSource("../path/sound.mp3", false);
          * audio.playbackRate = 2.0;
          * audio is playing with double speed
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        playbackRate: wd.property({
            value: 1.0,
            get: function () {
                return this._playbackRate;
            },
            set: function (v) {
                if (!this.isPlaying) {
                    this._playbackRate = v;
                }
            }
        }),

        /**
          * Returns `true` or `false` to indicate
          * whether audio is ready to play or not.
          *
          * @readonly {number} ready
          * @default false
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        ready: wd.readonly(false),

        /**
          * Returns the buffer Duration of the `webDoodling.WebAudioSource`.
          *
          * @readonly {number} bufferDuration
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        bufferDuration: wd.readonly({
            get: function () {
                return this._bufferDuration;
            }
        }),

        /**
          * Returns the current Time of the `webDoodling.WebAudioSource`.
          *
          * @readonly {number} currentTime
          * @default 0
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        currentTime: wd.readonly(0),

        /**
          * Returns playing status of the `webDoodling.WebAudioSource`.
          * If `isPlaying` returns true then audio is in playing mode.
          *
          * @readonly {boolean} isPlaying.
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        isPlaying: wd.readonly({
            get: function () {
                return this._playState === "playing";
            }
        }),

        /**
          * Gets or Sets the `volume` of the `webDoodling.WebAudioSource`.
          * -Volume must be in range. Range from 0 to  1.
          *
          * @field {number} volume
          * @default 1
          *
          * @example
          * var audio = new wd.WebAudioSource("../path/sound.mp3", false);
          * audio.volume = 0.5;
          * audio is playing with 50% volume.
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        volume: wd.property({
            value: 1,
            get: function () {
                return this._volume;
            },
            set: function (v) {
                this._volume = v;
                if (this._gainNode !== undefined) {
                    this._gainNode.gain.value = Math.min(Math.max(v, 0), 1);
                }
            }
        }),

        /**
          * Gets or Sets `loop` of the `webDoodling.WebAudioSource`.
          * This property can only be set when audio is not playing (
          * `isPlaying` === false).
          * -If audio is playing and loop is true at that set the startPosition
          *  and stopPosition then audio is playing from startPosition.
          *
          * @field {boolean} loop
          * @default false
          *
          * @example
          * var audio = new wd.WebAudioSource("../path/sound.mp3", false);
          * audio.loop = true;
          * audio is playing in loop.
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        loop: wd.property({
            value: false,
            get: function () {
                return this._loop;
            },
            set: function (v) {
                if (!this.isPlaying) {
                    this._loop = v;
                }
            }
        }),

        /**
          * Gets or Sets `muted` of the `webDoodling.WebAudioSource`.
          * if `muted` is true then audio has no sound.
          *
          * @field {boolean} muted
          * @default false
          *
          * @example
          * var audio = new wd.WebAudioSource("../path/sound.mp3", false);
          * audio.muted = true;
          * audio has no sound.
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        muted: wd.property({
            value: false,
            get: function () {
                return this._muted;
            },
            set: function (v) {
                this._muted = v;
                if (this._gainNode !== undefined) {
                    if (this._muted === true) {
                        this._gainNode.gain.value = 0;
                    } else {
                        this._gainNode.gain.value = 1;
                    }
                }
            }
        }),

        /**
          * Gets or Sets the `startPosition` of the `webDoodling.WebAudioSource`.
          * `startPosition` is used to set play Position of audio.
          *
          * @field {number} startPosition.
          * @default 0
          *
          * @example
          * var audio = new wd.WebAudioSource("../path/sound.mp3", false);
          * audio.startPosition = 2;
          * audio is started from 2 seconds.
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        startPosition: wd.property({
            value: 0,
            get: function () {
                return this._startPosition;
            },
            set: function (v) {
                if (this._startPosition !== v) {
                    this._startPosition = v;
                    if (this.ready === true) {
                        this._validateStartPosition(v);
                    }
                }
            }
        }),

        /**
          * Gets or Sets the `stopPosition` of the `webDoodling.WebAudioSource`.
          * -Stop position must be in range. Range is from `startPosition` to audio duration.
          *
          * @field {number} stopPosition
          *
          * @example
          * var audio = new wd.WebAudioSource("../path/sound.mp3", false);
          * audio.startPosition = 2;
          * audio.stopPosition = 5;
          * audio is started from 2 second and stopped at 5 seconds.
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        stopPosition: wd.property({
            get: function () {
                if (this._stopPosition !== undefined) {
                    return this._stopPosition;
                }
                else if (this._bufferData !== undefined) {
                    return this._bufferData.duration;
                }
                return 0;
            },
            set: function (v) {
                if (this._stopPosition !== v) {
                    this._stopPosition = v;
                    if (this.ready === true) {
                        this._validateStopPosition(v);
                    }
                }
            }
        }),

        /**
          * Initialize the audio with the `webDoodling.WebAudioSource`.
          *
          * @constructor init()
          *
          * @constructor init("../path/sound.mp3", false)
          * @param {string} src The source of the audio file.
          * @param {boolean} autoPlay The source of the audio file.
          *
          * @constructor init(o)
          * @param {object} o The audio object
          *
          * @example
          * var audio = new wd.WebAudioSource("../path/sound.mp3", false);
          * var audio = new wd.WebAudioSource();
          * var audio = new wd.WebAudioSource({
          *     source: "../path/sound.mp3",
          *     autoPlay: false
          * });
          *
          * @memberOf webDoodling.WebAudioSource
          * @public
          * @version 1.0
          **/
        init: function init() {
            var arg1 = arguments[0],
                argLen = arguments.length;

            this.base();
            this.serializables("playbackRate", "startPosition", "autoPlay", "loop", "muted", "volume",
                {
                    key: "stopPosition",
                    value: function () {
                        return this._stopPosition;
                    }
                });

            if (argLen === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                } else {
                    this.source = arg1;
                }
            }
            else {
                if (arg1 !== undefined) this.source = arg1;
            }

            this._startOffset = 0;
            this._startTime = 0;
            this._playState = "stopped";
        },

        /**
         * Play the audio of the `webDoodling.WebAudioSource`.
         *
         * @function play()
         *
         * @function play(position)
         * @param {[number]} position Play the audio from proper position.
         *
         * @example
         * var audio = new wd.WebAudioSource('../path/sound.mp3', false);
         * audio.play();
         *
         * var audio = new wd.WebAudioSource('../path/sound.mp3', false);
         * audio.play(3);
         * audio is play from 3 seconds.
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        play: function play(position) {
            var startPos, stopPos, source,
                context = this._context,
                gainNode = this._gainNode,
                diff,
                lastProcessTime = this._getSystemTime(),
                self = this,
                elapsedTime = 0,
                timeGap = 0;

            if (this.ready === false || this.isPlaying === true) {
                return;
            }

            // Setup source
            source = context.createBufferSource();
            source.buffer = this._bufferData;
            source.playbackRate.value = this.playbackRate;
            this._bufferSource = source;

            if (source.buffer === undefined) {
                return;
            }

            //Set Startposition and Stopposition
            startPos = this.startPosition;
            stopPos = this.stopPosition;
            diff = startPos - stopPos;
            if (diff === 0) {
                return;
            }

            //Set startOffset value
            // if (this._playState !== "paused") {
                this._startOffset = Math.min(Math.max(startPos, position || this.currentTime), stopPos);
            // }

            // to check if loop is true and audio is not playing then reset startOffset.
            if (this.loop === true) {
                this._startOffset = Math.min(Math.max(startPos, this._startOffset), stopPos);
            }

            if (this._playState === "paused" || this.startPosition !== undefined) {
                elapsedTime = this._startOffset;
            }

            this._audioPlayTime = this._getSystemTime();

            //Calculate audio currentTime.
            //elapsedTime - its calculate the time difference from audio is not playing to
            //audio is start playing.
            //this._audioPlayTime - currenttime.
            function processAudioTime() {
                var currentTime = self._getSystemTime(),
                    timeDelta;
                if (self._playState === "playing") {
                    timeDelta = currentTime - lastProcessTime;
                    if (timeDelta > 100) {
                        lastProcessTime = currentTime;
                        self._currentTime = (((currentTime - self._audioPlayTime) / 1000) + elapsedTime);
                        //If currentTime is greater than Stoppos and loop is true then set to startposition.
                        if (self.currentTime > stopPos && self.loop === true) {
                            // Adjust time gap between current time and stop pos.
                            timeGap = self.currentTime - stopPos;
                            timeGap = timeGap % (stopPos - startPos);
                            // elapsedTime was change because when loop is true and currentTime reach the stopPosition.
                            // then need to set elapsed time to startPosition and plus time gap.
                            elapsedTime = startPos + timeGap;
                            self._audioPlayTime = currentTime;
                            self._currentTime = (((currentTime - self._audioPlayTime) / 1000) + elapsedTime);
                        }
                        //timeupdate event callback
                        if (wd.is.func(self.onTimeUpdate)) {
                            self.onTimeUpdate(self.currentTime);
                        }
                    }
                    window.requestAnimationFrame(processAudioTime, document.body);
                }
                else if (self._playState === "stopped") {
                    //If playState is stopped then set currentTime to startposition.
                    self._currentTime = startPos;
                    // if playstate is stopped then need to set elapsed time to start position.
                    elapsedTime = startPos;
                    self._audioPlayTime = currentTime;
                    if (wd.is.func(self.onTimeUpdate)) {
                        self.onTimeUpdate(self.currentTime);
                    }
                }
            }
            this._playState = "playing";
            //connect to gainNode.
            this._connectGainNode(gainNode);
            source.start(0, this._startOffset, stopPos - this._startOffset);
            //Setup Loop here because set the startOffset in setupLoop function
            this._setupLoop();
            source.onended = function () {
                if (self._playState !== "paused") {
                    self._startOffset = self.startPosition || 0;
                    self._playState = "stopped";
                }
            };
            //playing event callback.
            if (wd.is.func(this.onPlay)) {
                this.onPlay();
            }
            window.requestAnimationFrame(processAudioTime, document.body);
        },

        /**
         * Pause the audio of the `webDoodling.WebAudioSource`.
         *
         * @function pause()
         *
         * @example
         * var audio = new wd.WebAudioSource('../path/sound.mp3', false);
         * audio.pause()
         * audio is paused at current position.
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            if (this._bufferSource === undefined) {
                return;
            }

            this._playState = "paused";
            //to pause the audio
            this._bufferSource.stop(0);
            //relaese bufferSource
            delete this._bufferSource;
            //set startoffset to currentTime
            this._startOffset = this.currentTime;
            if (wd.is.func(this.onPause)) {
                this.onPause();
            }
        },

        /**
         * Stop the audio of the `webDoodling.WebAudioSource`.
         *
         * @function stop()
         *
         * @example
         * var audio = new wd.WebAudioSource('../path/sound.mp3', false);
         * audio.stop()
         * audio is stopped from current position.
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        stop: function stop() {
            if (this._bufferSource === undefined) {
                return;
            }
            //set startOffset to start posiiton
            this._startOffset = this.startPosition;
            //to stop audio.
            this._bufferSource.stop(0);
            this._playState = "stopped";
            //release buffer source.
            delete this._bufferSource;

            if (wd.is.func(this.onStop)) {
                this.onStop();
            }
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.WebAudioSource].
         *
         * @memberOf webDoodling.WebAudioSource
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.WebAudioSource]";
        },

        //Setup loopStart and loopEnd position.
        _setupLoop: function () {
            var source = this._bufferSource;

            if (this.loop === true) {
                source.loop = true;
                source.loopStart = this.startPosition;
                source.loopEnd = this.stopPosition;
            }
            else {
                source.loop = false;
                source.loopEnd = this.stopPosition;
            }
        },

        //To validate startPosition
        _validateStartPosition: function (value) {
            this._startPosition = Math.min(Math.max(value, 0), this.duration);
        },

        //To validate stopPosition
        _validateStopPosition: function (value) {
            this._stopPosition = Math.min(Math.max(value, this.startPosition), this.duration);
        },

        //To get system time with playbackrate.
        _getSystemTime: function () {
            return (new Date()).getTime() * this.playbackRate;
        },

        // Connect gain node, gain node manages volume of
        // the audio.
        _connectGainNode: function (gainNode) {
            var source = this._bufferSource,
                context = this._context;
            source.connect(gainNode);
            gainNode.connect(context.destination);
        },

        // Creates a gain node.
        _createGainNode: function () {
            var context = this._context;
            if (context.createGain === undefined) {
                return context.createGainNode();
            }
            else {
                return context.createGain();
            }
        },

        //when source changed autoLoad the audio.
        _onSourceChanged: function () {
            var source = this._source,
                self = this,
                webLoader;
            //Setup web audio context.
            this._context = wd.WebAudioSource.getAudioContext();
            //Load the audio file.
            webLoader = new wd.WebAudioLoader(this._context, source);
            webLoader.onLoad = function () {
                self._bufferData = webLoader.bufferData;
                self._duration = self._bufferData.duration;
                self._bufferDuration = self._bufferData.duration;
                self._validateStartPosition(self.startPosition);
                self._validateStopPosition(self.stopPosition);
                self._ready = true;
                //Audio load is complete without any error then load event callback is called.
                if (wd.is.func(self.onLoad)) {
                    self.onLoad();
                }
            };

            webLoader.onError = function (errorMsg) {
                //Audio load is not complete due to some error then error event callback is called.
                if (wd.is.func(self.onError)) {
                    self.onError(errorMsg);
                }
            };
            //create gain node.
            this._gainNode = this._createGainNode();
            //set the volume.
            this._gainNode.gain.value = this._volume;
            //set the mute
            if (this._muted === true) {
                this._gainNode.gain.value = 0;
            } else {
                this._gainNode.gain.value = 1;
            }
        }

    }, wd.AudioSource);

    /**
      * Returns the audio context for `webDoodling.WebAudioSource`.
      *
      * @function getAudioContext()
      *
      * @static
      * @memberOf webDoodling.WebAudioSource
      * @public
      * @version 1.0
      **/
    WebAudioSource.getAudioContext = function getAudioContext() {
        if (audioContext === undefined) {
            audioContext = new AudioContextClass();
        }
        return audioContext;
    };

    wd.WebAudioSource = WebAudioSource;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The HTML5 Audio
(function (wd, undefined) {
    "use strict";

    /**
     * Represents the `webDoodling.Audio` class. which is used to set
     * source of audio and play the audio which browser support.
     *
     * @class webDoodling.Audio
     *
     * @example
     * var audio = new wd.Audio('audio.mp3', true);
     *
     * var audio = new wd.Audio();
     * audio.source = 'audio.mp3';
     * audio.autoPlay = true;
     *
     * var audio = new wd.Audio({
     *     source: 'audio.mp3',
     *     autoPlay: true,
     *     startPosition: 3,
     *     stopPosition: 5
     * });
     *
     * @memberOf webDoodling
     * @extends webDoodling.Serializable
     * @public
     * @version 1.0
     **/
    wd.Audio = wd.Class({
        /**
         * Returns the `type` of `webDoodling.Audio`, always returns 'Audio'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        type: wd.type("Audio"),

        /**
         * Represents the `timeupdate` event, which is invoked when
         * `currentTime` changes.
         *
         * @event timeupdate(eventArgs)
         * @param {webDoodling.TimeUpdateEventArgs} eventArgs The current position of audio.
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        timeupdate: wd.event(),

        /**
         * Represents the `playing` event, which is invoked when
         * audio start playing.
         *
         * @event playing(eventArgs)
         * @param {webDoodling.EventArgs} eventArgs
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        playing: wd.event(),

        /**
         * Represents the `paused` event, which is invoked when
         * audio is paused.
         *
         * @event paused()
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        paused: wd.event(),

        /**
         * Represents the `stopped` event, which is invoked when
         * audio is stopped.
         *
         * @event stopped()
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        stopped: wd.event(),

        /**
         * Represents the `load` event, which is invoked when
         * audio is start loading.
         *
         * @event load()
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        load: wd.event(),

        /**
         * Represents the `error` event, which is invoked when
         * audio has some error.
         *
         * @event error(eventArgs)
         * @param {webDoodling.AudioErrorEventArgs} eventArgs The error message.
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        error: wd.event(),

        /**
          * Sets the speed of the `webDoodling.Audio`.
          * -If want pitch in audio then use `webDoodling.WebAudioSource`.
          * -If playbackRate is 2.0 then its playing audio with double speed.
          * -If playbackRate is 0.5 then its playing audio with half speed.
          * -Its only set when audio is not playing.
          *
          * @field {number} playbackRate
          * @default 1.0
          *
          * @example
          * var audio = new wd.Audio();
          * audio.playbackRate = 2.0;
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        playbackRate: wd.property({
            value: 1.0,
            get: function () {
                return this._playbackRate;
            },
            set: function (v) {
                if (!this.isPlaying) {
                    this._playbackRate = v;
                }
            }
        }),

        /**
          * Returns playing status of audio.
          * -If `isPlaying` returns true then audio is in playing mode otherwise return false.
          *
          * @readonly {boolean} isPlaying.
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        isPlaying: wd.property({
            get: function () {
                return this._sourceAudio.isPlaying;
            }
        }),

        /**
          * Returns the `currentTime` of the `webDoodling.Audio`
          *
          * @readonly {number} currentTime
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        currentTime: wd.property({
            get: function () {
                return this._sourceAudio.currentTime;
            }
        }),

        /**
          * Returns the `currentTime` of the `webDoodling.Audio`
          * which is in human reading format.
          *
          * @readonly {number} currentTimeHumanized
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        currentTimeHumanized: wd.property({
            get: function () {
                var date = new Date(null);
                date.setSeconds(this.currentTime);
                this._currentTimeHumanized = date.getUTCMinutes() + ":" + date.getUTCSeconds();
                return this._currentTimeHumanized;
            }
        }),

        /**
          * Returns the duration of the audio.
          *
          * @readonly {number} duration
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        duration: wd.readonly({
            get: function () {
                return this._sourceAudio.duration;
            }
        }),

        /**
          * Returns `true` or `false` to indicate
          * whether audio is ready to play or not.
          *
          * @readonly {boolean} ready
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        ready: wd.property({
            get: function () {
                return this._sourceAudio.ready;
            }
        }),

        /**
          * If we set it to `true` then its start playing automatically when
          * audio is fully loaded.
          *
          * @field {boolean} autoPlay.
          * @default false
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        autoPlay: wd.attribute(false),

         /**
          * Get or Sets the `startPosition` of the `webDoodling.Audio`.
          * `startPosition` is used to set play Position.
          *
          * @field {number} startPosition.
          * @default 0
          *
          * @example
          * var audio = new wd.Audio();
          * audio.startPosition = 2;
          * audio is started from 2 seconds.
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        startPosition: wd.property({
            value: 0,
            get: function () {
                return this._startPosition;
            },
            set: function (v) {
                this._startPosition = v;
            }
        }),

        /**
          * Gets or Sets the `stopPosition` of the `webDoodling.Audio`.
          * -Stop position must be in range. Range is from `startPosition` to audio duration.
          *
          * @field {number} stopPosition
          *
          * @example
          * var audio = new wd.Audio();
          * audio.startPosition = 2;
          * audio.stopPosition = 5;
          * audio is started from 2 second and stopped at 5 seconds.
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        stopPosition: wd.property({
            get: function () {
                return this._stopPosition;
            },
            set: function (v) {
                this._stopPosition = v;
            }
        }),

        /**
          * Gets or Sets `loop` of the `webDoodling.Audio`
          * -If `loop` is `true` then audio is in loop mode.
          * -Its only set when audio is not playing.
          *
          * @field {boolean} loop
          * @default false
          *
          * @example
          * var audio = new wd.Audio();
          * audio.loop = true;
          * audio is playing in loop.
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        loop: wd.property({
            value: false,
            get: function () {
                return this._loop;
            },
            set: function (v) {
                if (!this.isPlaying) {
                    this._loop = v;
                }
            }
        }),

        /**
          * Gets or Sets `muted` of the `webDoodling.Audio`
          * if `muted` is `true` then audio is playing without sound.
          *
          * @field {boolean} muted
          * @default false
          *
          * @example
          * var audio = new wd.Audio();
          * audio.muted = true;
          * audio is playing without sound.
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        muted: wd.property({
            value: false,
            get: function () {
                return this._muted;
            },
            set: function (v) {
                this._muted = v;
                if (this._sourceAudio instanceof wd.AudioSource) {
                    this._sourceAudio.muted = v;
                }
            }
        }),

        /**
          * Gets or Sets `volume` of the `webDoodling.Audio`.
          * -Volume must be in range. Range from 0 to  1.
          *
          * @field {number} volume
          * @default 1
          *
          * @example
          * var audio = new wd.Audio();
          * audio.volume = 0.5;
          * audio is playing with 50% sound.
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        volume: wd.property({
            value: 1,
            get: function () {
                return this._volume;
            },
            set: function (v) {
                this._volume = v;
                if (this._sourceAudio instanceof wd.AudioSource) {
                    this._sourceAudio.volume = v;
                }
            }
        }),

        /**
          * Returns the buffer Duration of audio.
          *
          * @readonly {number} bufferDuration
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        bufferDuration: wd.readonly({
            get: function () {
                return (this._sourceAudio instanceof wd.AudioSource) ? this._sourceAudio.bufferDuration : 0;
            }
        }),

        /**
          * Gets or Sets the `source` of the `webDoodling.Audio`.
          *
          * @field {string, webDoodling.WebAudioSource, webDoodling.HTML5AudioSource, webDoodling.Asset, Audio} source
          * @default " "
          *
          * @example
          * var audio = new wd.Audio();
          * audio.source = "../path/sound.mp3";
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        source: wd.property({
            value: " ",
            get: function () {
                return this._source;
            },
            set: function (v) {
                var self = this,
                    eventArgs;
                this._source = v;
                function  onAudioLoad() {
                    self.trigger("load", new wd.EventArgs("load"));
                    if (self.autoPlay === true) {
                        self.play();
                    }
                }
                if (wd.is.string(v)) {
                    if (wd.is.webAudio) {
                        this._sourceAudio = new wd.WebAudioSource(this._source);
                    }
                    else {
                        this._sourceAudio = new wd.HTML5AudioSource(this._source);
                    }
                }
                else if (v instanceof wd.HTML5AudioSource) {
                    this._sourceAudio = v;
                }
                else if (v instanceof wd.WebAudioSource) {
                    this._sourceAudio = v;
                    if (!wd.is.webAudio) {
                        throw new wd.Error("wd-browser-not-supported");
                    }
                }
                else if (v instanceof wd.AudioAsset) {
                    if (v.state === wd.AssetStates.READY) {
                        this._sourceAudio = v.media;
                    }
                    else {
                        v.success(function () {
                            self._sourceAudio = v.media;
                            onAudioLoad();
                        });
                    }
                }
                else if (v instanceof Audio) {
                    this._sourceAudio = new wd.HTML5AudioSource(v);
                }
                this._sourceAudio.volume = this._volume;
                this._sourceAudio.onLoad = onAudioLoad;
                this._sourceAudio.onError = function (error) {
                    self.trigger("error", new wd.AudioErrorEventArgs(error));
                };
                this._sourceAudio.onTimeUpdate = function (position) {
                    eventArgs = new wd.TimeUpdateEventArgs(position);
                    self.trigger("timeupdate", eventArgs);
                };
            }
        }),

        /**
          * Initialize the audio source of the `webDoodling.Audio`.
          * //here we can check the browser support and also type support.
          * //we can also give the autoload facility here.
          *
          * @constructor init()
          *
          * @constructor init(o)
          * @params {object} o The object of the audio.
          *
          * @constructor init(src, autoPlay)
          * @param {string} src The source of the audio file.
          * @param {boolean} autoPlay The autoPlay of the audio file.
          *
          * @example
          * var audio = new wd.Audio("../path/sound.mp3", false);
          *
          * var audio = new wd.Audio();
          * audio.autoPlay = false;
          * audio.source = "../path/sound.mp3";
          *
          * var audio = new wd.Audio({
          *   autoPlay: true,
          *   source: "../path/sound.mp3",
          *   playbackRate: 2.0
          * });
          *
          * @memberOf webDoodling.Audio
          * @public
          * @version 1.0
          **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                argLen = arguments.length;

            this.base();
            this.serializables(
                {
                    key: "source",
                    value: function () {
                        if (this.source instanceof wd.AudioSource) {
                            return this.source.source;
                        }
                        else if (wd.is.string(this.source)){
                            return this.source;
                        }
                    }
                }, "playbackRate", "startPosition", "stopPosition", "autoPlay", "loop", "muted", "volume");

            if (argLen === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                } else {
                    this.source = arg1;
                }
            } else {
                if (arg2 !== undefined) this.autoPlay = arg2;
                if (arg1 !== undefined) this.source = arg1;
            }
            if (this.autoPlay === true && this.source instanceof wd.AudioAsset && this.source.state === wd.AssetStates.READY) {
                this.play();
            }
        },

        /**
         * Play the audio of the `webDoodling.Audio`
         *
         * @function play()
         *
         * @function play(position)
         * @param {[number]} position The position use to play the audio from the proper position.
         *
         * @example
         * var audio = new wd.Audio();
         * audio.source = "../path/sound.mp3";
         * audio.play();
         *
         * var audio = new wd.Audio();
         * audio.source = "../path/sound.mp3";
         * audio.play(3);
         * audio is play from 3 seconds.
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        play: function play(position) {
            var self = this;

            if (this._setSourceProperties() === false)  {
                return;
            }

            this._sourceAudio.onPlay = function () {
                self.trigger("playing", new wd.EventArgs("playing"));
            };

            this._sourceAudio.play(position);
        },

        /**
         * Pause the audio of the `webDoodling.Audio`.
         *
         * @function pause()
         *
         * @example
         * var audio = new wd.Audio("../path/sound.mp3");
         * audio.play();
         * audio.pause();
         * audio is paused at current position.
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            var self = this;

            if (this._sourceAudio instanceof wd.AudioSource === false) {
                return;
            }

            this._sourceAudio.onPause = function () {
                self.trigger("paused", new wd.EventArgs("paused"));
            };

            this._sourceAudio.pause();
        },

        /**
         * Stop the audio of the `webDoodling.Audio`.
         *
         * @function stop()
         *
         * @example
         * var audio = new wd.Audio("../path/sound.mp3");
         * audio.play();
         * audio.stop();
         * audio is stopped from current position.
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        stop: function stop() {
            var self = this;

            if (this._sourceAudio instanceof wd.AudioSource === false) {
                return;
            }

            this._sourceAudio.onStop = function () {
                self.trigger("stopped", new wd.EventArgs("stopped"));
            };

            this._sourceAudio.stop();
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Audio].
         *
         * @memberOf webDoodling.Audio
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Audio]";
        },

        //private-area
        //This function is used to assign property to audio source
        _setSourceProperties: function () {
            //validate if audio source is available.
            if (this._sourceAudio instanceof wd.AudioSource === false) {
                return false;
            }

            this._sourceAudio._volume            = this.volume;
            this._sourceAudio._playbackRate      = this.playbackRate;
            this._sourceAudio._loop              = this.loop;
            this._sourceAudio._muted             = this.muted;
            this._sourceAudio._startPosition     = this.startPosition;
            this._sourceAudio._stopPosition      = this.stopPosition;
            return true;
        }
    }, wd.Serializable);

    /**
      * Converts the seconds into a human readable format.
      *
      * @function humanizeTime(sec)
      * @params {number} sec The seconds which want to convert into humanize time.
      *
      * @example
      * var audio = new wd.Audio("../path/sound.mp3"),
      *     time;
      * time = wd.Audio.humanizeTime(audio.duration);
      * //prints time such as "5:10"
      * console.log(time);
      *
      * @returns {string} The time of the given seconds
      *
      * @static
      * @memberOf webDoodling.Audio
      * @public
      * @version 1.0
      **/
    wd.Audio.humanizeTime = function humanizeTime(sec) {
        var date = new Date(null);
        date.setSeconds(sec);
        return date.getUTCMinutes() + ":" + date.getUTCSeconds();
    };

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//StyleableDisplayObject
(function (wd) {
    "use strict";

    var EMPTY_FN = function () {},
        StyleableDisplayObject;

    /**
     * Represents the `webDoodling.StyleableDisplayObject` DisplayObject.
     *
     * @class webDoodling.StyleableDisplayObject
     *
     * @example
     * // webDoodling.Rectangle is a StyleableDisplayObject which allows user to
     * // apply multiple layers of styles like Fill, Stroke, Shadow...
     * var rect = new webDoodling.Rectangle({
     *     x: 100,
     *     y: 200,
     *     width: 100,
     *     height: 100,
     *     // Addes `styles` to DisplayObject which allows styleable objects to
     *     // apply various styles. While rendering styles their order matters.
     *     styles: [
     *         new webDoodling.Fill('red'), // First, fills the rect with red color
     *         new webDoodling.Stroke('yellow', 10), // Second, strokes the rect with color yellow and width size 10
     *         new webDoodling.Stroke('orange', 5) // Third, strokes the rect with color orange and width size 5
     *     ]
     * });
     *
     * @extends webDoodling.DisplayObject
     * @public
     * @version 1.0
     **/
    StyleableDisplayObject = wd.Class({

         /**
         * Returns the `type` of `webDoodling.StyleableDisplayObject`, always returns StyleableDisplayObject'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.StyleableDisplayObject
         * @public
         * @version 1.0
         **/
        type: wd.type("StyleableDisplayObject"),

        /**
         * Represents the `styles` of `webDoodling.StyleableDisplayObject`.
         *
         * @readonly {webDoodling.StyleCollection} styles
         *
         * @memberOf webDoodling.StyleableDisplayObject
         * @public
         * @version 1.0
         **/
        styles: wd.readonly(),

         /**
          * Initializes the new instance of `webDoodling.Paragraph`.
          *
          * @constructor init(o)
          * @param {object} o The initialization options in JSON format.
          *
          * @memberOf webDoodling.StyleableDisplayObject
          * @public
          * @version 1.0
          **/
        init: function init(o) {
            var styles = new wd.StyleCollection(this);
            this._styles = styles;

            this.base();
            if (this.onDrawHitRegion === EMPTY_FN) {
                this.onDrawHitRegion = this.onDraw;
            }
            this.serializables("styles");
            if (o) this.deserialize(o);
        },

        onUpdate: function onUpdate(context, hitContext) {

            context.save();

            if (this.onBeforeUpdate) {
                this.onBeforeUpdate(context, hitContext);
            }

            var origin = this.absOrigin,
                originX = origin.x,
                originY = origin.y,
                clip = this.clip,
                x, y,
                hex;

            x = -originX;
            y = -originY;

            this._setContext(context, false, originX, originY);
            this.onDraw(context, x, y);
            this.onApplyStyles(context, x, y);
            context.restore();
            if (clip) {
                context.clip();
            }

            if (hitContext && this._pointers) {
                hex = this._hex;
                hitContext.save();
                this._setContext(hitContext, true, originX, originY);
                this.onDrawHitRegion(hitContext, x, y, hex);
                this.onApplyHitRegionStyles(hitContext, x, y, hex);
                hitContext.restore();
                if (clip) {
                    hitContext.clip();
                }
            }
        },

        onDraw: EMPTY_FN,

        onApplyStyles: function onApplyStyles(ctx) {
            var styles = this.styles._items,
                style;
            for (var i = 0, len = styles.length; i < len; i++) {
                style = styles[i];
                if (style.visible === false) {
                    continue;
                }
                style.onApplyStyle(ctx, this);
            }
        },

        onDrawHitRegion: function onDrawHitRegion(ctx, x, y, color) {

            var styles = this.styles.getHitRegionStyles(),
                style;

            this.onDraw(ctx, x, y);
            for (var i = 0, len = styles.length; i < len; i++) {
                style = styles[i];
                if (style.visible === false) {
                    continue;
                }
                if (style instanceof wd.Stroke) {
                    ctx.lineWidth = style.lineWidth;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }
                else if (style instanceof wd.Fill) {
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        },

        onApplyHitRegionStyles: function onApplyHitRegionStyles(ctx, x, y, color) {
            var styles = this.styles.getHitRegionStyles();
            for (var i = 0, len = styles.length; i < len; i++) {
                styles[i].onApplyStyle(ctx, this, color);
            }
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.StyleableDisplayObject].
         *
         * @memberOf webDoodling.StyleableDisplayObject
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.StyleableDisplayObject]";
        }

    }, wd.DisplayObject);

    wd.StyleableDisplayObject = StyleableDisplayObject;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Path DisplayObject
(function (wd) {
    "use strict";

    var Path;

    /**
     * Represents the `webDoodling.Path`.
     *
     * @class webDoodling.Path
     *
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Path = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.Path`.
         *
         * @field {string} type
         * @default path
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        type: wd.type("Path"),

        /**
         * Gets or sets the `segments` of the `webDoodling.Path`.
         *
         * @field {number} segments
         * @default 0
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        segments: wd.attribute(0),

        /**
         * Intializes the current instance of `webDoodling.Path`.
         *
         * @constructor init(o)
         * @param {object} o The initialization options in JSON format.
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            var segments = new wd.PathSegmentCollection();
            this.segments = segments;
            this.base();
            this.serializables("segments");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
//            ctx.lineCap = this.lineCap;
//            ctx.lineJoin = this.lineJoin;
//            ctx.miterLimit = this.miterLimit;

            var segments = this.segments;
            for (var i = 0, len = segments.length; i < len; i++) {
                segments.get(i).onDraw(ctx, x, y);
            }
        },

        /**
         * Adds the new `webDoodling.BeginPath` at the list of segments.
         *
         * @function beginPath([id])
         * @param {[string]} id The path segment identifier. This is an optional parameter.
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        beginPath: function beginPath(id) {
            var seg = new wd.BeginPath(id);
            this.segments.add(seg);
            return this;
        },

        /**
         * Adds the new `webDoodling.ClosePath` at the list of segments.
         *
         * @function closePath([id])
         * @param {[string]} id The path segment identifier. This is an optional parameter.
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        closePath: function closePath(id) {
            var seg = new wd.ClosePath(id);
            this.segments.add(seg);
            return this;
        },

        /**
         * Adds the new `webDoodling.MoveTo` at the list of segments.
         *
         * @function moveTo(x, y, [id])
         * @param {number} x Sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        moveTo: function moveTo(x, y, id) {
            var seg = new wd.MoveTo(x, y, id);
            this.segments.add(seg);
            return this;
        },

        /**
         * Adds the new `webDoodling.LineTo` at the list of segments.
         *
         * @function lineTo(x, y, [id])
         * @param {number} x Sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        lineTo: function lineTo(x, y, id) {
            var seg = new wd.LineTo(x, y, id);
            this.segments.add(seg);
            return this;
        },

        /**
         * Adds the new `webDoodling.QuadraticCurveTo` at the list of segments.
         *
         * @function quadraticCurveTo(x, y, cpx, cpy, [id])
         * @param {number} x Sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        quadraticCurveTo: function quadraticCurveTo(x, y, cpx, cpy, id) {
            var seg = new wd.QuadraticCurveTo(x, y, cpx, cpy, id);
            this.segments.add(seg);
            return this;
        },

        /**
         * Adds the new `webDoodling.BezierCurveTo` at the list of segments.
         *
         * @function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, [id])
         * @param {number} cp1x(x controlpoint1) Sets the cpx1(x controlpoint1) property of the current instance.
         * @param {number} cp1y(y controlpoint1) Sets the cpy1(y controlpoint1) property of the current instance.
         * @param {number} cp2x(x controlpoint2) Sets the cpx2(x controlpoint2) property of the current instance.
         * @param {number} cp2y(y controlpoint2) Sets the cpy2(y controlpoint2) property of the current instance.
         * @param {number} x Sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, id) {
            var seg = new wd.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, id);
            this.segments.add(seg);
            return this;
        },

        /**
         * Return the Array of the points to the path.
         *
         * @function toArray()
         * TODO: Add the description
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/

        toArray: function toArray() {

            var arr = [],
                lastX, lastY,
                closed = false,
                g = wd.geometry;

            this.segments.each(function (seg) {
                if (closed === true) {
                    return;
                }
                var x = seg.x,
                    y = seg.y,
                    points = null;

                if (seg instanceof wd.MoveTo) {
                    lastX = x;
                    lastY = y;
                }
                else if (seg instanceof wd.LineTo) {
                    points = g.Line.toArray(lastX, lastY, seg.x, seg.y);
                    lastX = x;
                    lastY = y;
                }
                else if (seg instanceof wd.QuadraticCurveTo) {
                    points = g.QuadraticCurve.toArray(lastX, lastY, seg.cpx, seg.cpy, seg.x, seg.y);
                    lastX = x;
                    lastY = y;
                }
                else if (seg instanceof wd.BezierCurveTo) {
                    points = g.BezierCurve.toArray(lastX, lastY, seg.cp1x, seg.cp1y,
                        seg.cp2x, seg.cp2y, seg.x, seg.y);
                    lastX = x;
                    lastY = y;
                }
                if (seg instanceof wd.ClosePath) {
                    x = arr[0].x;
                    y = arr[0].y;
                    points = g.Line.toArray(lastX, lastY, x, y);
                    closed = true;
                }
                if (points !== null) {
                    if (arr.length === 0) {
                        arr = arr.concat(points);
                    }
                    else {
                        arr = arr.concat(points.slice(1));
                    }
                }
            });

            return arr;

        },

        getBoundingBox: function getBoundingBox() {
            return wd.geometry.Path.getBoundingBox(this.segments);
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Path]
         *
         * @memberOf webDoodling.Path
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Path]";
        }

    }, wd.StyleableDisplayObject);

    wd.Path = Path;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Path DisplayObject
(function (wd) {
    "use strict";

    var PathSegment;

    /**
     * Represents the base class for all path segments classes like
     * `webDoodling.BeginPath`, `webDoodling.Moveto`, `webDoodling.LineTo` etc...
     *
     * @class webDoodling.PathSegment
     *
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.LineTo(300, 100),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     *
     * @extends webDoodling.PathSegment
     * @public
     * @version 1.0
     **/
    PathSegment = wd.Class({

        /**
         * Returns the type of `webDoodling.PathSegment`, always returns 'PathSegment'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.PathSegment
         * @public
         * @version 1.0
         **/
        type: wd.type("PathSegment"),

        /**
         * Gets or sets the `id` of the `webDoodling.PathSegment`.
         *
         * @field {string} id
         *
         * @memberOf webDoodling.PathSegment
         * @public
         * @version 1.0
         **/
        id: wd.attribute(),

        /**
         * Represents the tweenable members in current path segment.
         *
         * @readonly {webDoodling.tweenables} tweenables
         *
         * @memberOf webDoodling.PathSegment
         * @public
         * @version 1.0
         **/
        tweenables: wd.readonly(),

        /**
         * Initializes the new instance of `webDoodling.PathSegment`.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.PathSegment
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();
            this._tweenables = new wd.Tweenables(this);
            this.serializables("id");

            if (wd.is.plainObject(arguments[0])) {
                this.deserialize(arguments[0]);
            }
        },

        /**
         * Return the string representation of current instances.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.PathSegment]
         *
         * @extend webDoodling.PathSegment
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.PathSegment]";
        }

    }, wd.Serializable);

    wd.PathSegment = PathSegment;
})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Arc DisplayObject
(function (wd) {
    "use strict";

    var BeginPathSegment;

   /**
     * Represents the `webDoodling.BeginPath`.
     *
     * @class webDoodling.BeginPath
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.LineTo(300, 100),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     *
     * @extends webDoodling.BeginPath
     *
     * @member of webdoodling.BeginPath
     * @public
     * @version 1.0
     **/
    BeginPathSegment = wd.Class({

        /**
         * Returns the `type` of `webDoodling.BeginPath`, always returns 'BeginPath'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.BeginPath
         * @public
         * @version 1.0
         **/
        type: wd.type("BeginPath"),

       //Same as base class docs.
        onDraw: function onDraw(ctx) {
            ctx.beginPath();
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.BeginPath].
         *
         * @memberOf webDoodling.BeginPath
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.BeginPath]";
        }
    }, wd.PathSegment);

    wd.BeginPath = BeginPathSegment;

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Path DisplayObject
(function (wd) {
    "use strict";

    var ClosePathSegment;

   /**
     * Represents the `webDoodling.ClosePath`.
     *
     * @class webDoodling.ClosePath
     *
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.LineTo(300, 100),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     *
     * @extends webDoodling.PathSegment
     *
     * @memberOf webDoodling.ClosePath
     * @public
     * @version 1.0
     **/
    ClosePathSegment = wd.Class({

        /**
         * Returns the `type` of `webDoodling.ClosePath`, always returns 'ClosePath'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ClosePath
         * @public
         * @version 1.0
         **/
        type: wd.type("ClosePath"),

        //Same as base class docs.
        onDraw: function onDraw(ctx) {
            ctx.closePath();
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ClosePath].
         *
         * @memberOf webDoodling.ClosePath
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ClosePath]";
        }
    }, wd.PathSegment);

    wd.ClosePath = ClosePathSegment;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Path DisplayObject
(function (wd, undefined) {
    "use strict";

    var MoveToSegment;

   /**
     * Represents the `webDoodling.MoveTo`.
     *
     * @class webDoodling.MoveTo
     *
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.LineTo(300, 100),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     * @extends webDoodling.PathSegment
     *
     * @public
     * @version 1.0
     **/
    MoveToSegment = wd.Class({

        /**
         * Returns the `type` of `webDoodling.MoveTo`, always returns'MoveTo'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.MoveTo
         * @public
         * @version 1.0
         **/
        type: wd.type("MoveTo"),

        /**
         * Gets or sets the `x` property of the `webDoodling.MoveTo`.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.MoveTo
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * Gets or sets the `y` property of the `webDoodling.MoveTo`.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.MoveTo
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Intializes the current instance of `webDoodling.MoveTo`.
         *
         * @constructor init(x, y, [id])
         * @param {number} x Sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.MoveTo
         * @public
         * @version 1.0
         **/
        init: function init(x, y, id) {
            this.base();

            this._tweenables.register("number", "x", "y");
            this.serializables("x", "y");

            if (wd.is.plainObject(arguments[0])) {
                this.deserialize(arguments[0]);
            }
            else {
                if (x !== undefined) this.x = x;
                if (y !== undefined) this.y = y;
                if (id !== undefined) this.id = id;
            }


        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            ctx.moveTo(
                x + this.x,
                y + this.y
            );
        },

        /**
         * Returns the string representation of current instances
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.MoveTo]
         *
         * @memberOf webDoodling.MoveTo
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.MoveTo]";
        }
    }, wd.PathSegment);

    wd.MoveTo = MoveToSegment;

})(window.webDoodling);
 // Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Path DisplayObject
(function (wd, undefined) {
    "use strict";

    var LineToSegment;

   /**
     * Represents the `webDoodling.LineTo`.
     *
     * @class webDoodling.LineTo
     *
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.LineTo(300, 100),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     *
     * @extends webDoodling.PathSegment
     *
     * @public
     * @version 1.0
     **/
    LineToSegment = wd.Class({

        /**
         * Returns the `type` of `webDoodling.LineTo`, always returns 'LineTo'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.LineTo
         * @public
         * @version 1.0
         **/
        type: wd.type("LineTo"),

        /**
         * Gets or sets the `x` attribute of the `webDoodling.LineTo`.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.LineTo
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * Gets or sets the `y` attribute of the `webdoodlingLineTo`.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.LineTo
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Intializes the new instance of `webDoodling.LineTo`.
         *
         * @constructor init(x, y, [id])
         * @param {number} x sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.LineTo
         * @public
         * @version 1.0
         **/
        init: function init(x, y, id) {
            this.base();

            this._tweenables.register("number", "x", "y");
            this.serializables("x", "y");

            if (wd.is.plainObject(arguments[0])) {
                this.deserialize(arguments[0]);
            }
            else {
                if (x !== undefined) this.x = x;
                if (y !== undefined) this.y = y;
                if (id !== undefined) this.id = id;
            }
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            ctx.lineTo(
                x + this.x,
                y + this.y
            );
        },

        /**
         * Returns the string representation of current instances.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.LineTo].
         *
         * @memberOf webDoodling.LineTo
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.LineTo]";
        }
    }, wd.PathSegment);

    wd.LineTo = LineToSegment;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Path DisplayObject
(function (wd, undefined) {
    "use strict";

    var QuadraticCurveToSegment;

   /**
     * Represents the `webDoodling.QuadraticCurveTo`.
     *
     * @class webDoodling.QuadraticCurveTo
     *
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.QuadraticCurveTo(300, 300, 400, 150),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     *
     * @extends webDoodling.PathSegment
     *
     * @public
     * @version 1.0
     **/
    QuadraticCurveToSegment = wd.Class({

        /**
         * Returns the `type` of `webDoodling.QuadraticCurveTo`, always returns 'QuadraticCurveTo'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.QuadraticCurveTo
         * @public
         * @version 1.0
         **/
        type: wd.type("QuadraticCurveTo"),

        /**
         * Gets or sets the `x` property of the `webDoodling.QuadraticCurveTo`.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.QuadraticCurveTo
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * Gets or sets the `y` property of the `webDoodling.QuadraticCurveTo`.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.QuadraticCurveTo
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Gets or sets the `cpx` (x controlpoint) attribute of the `webDoodling.QuadraticCurveTo`.
         *
         * @field {number} cpx
         * @default 0
         *
         * @memberOf webDoodling.QuadraticCurveTo
         * @public
         * @version 1.0
         **/
        cpx: wd.attribute(0),

        /**
         * Gets or sets the `cpy` (y controlpoint) property of the `webDoodling.QuadraticCurveTo`.
         *
         * @field {number} cpy
         * @default 0
         *
         * @memberOf webDoodling.QuadraticCurveTo
         * @public
         * @version 1.0
         **/
        cpy: wd.attribute(0),

        /**
         * Intializes the current instance of `webDoodling.QuadraticCurveTo`.
         *
         * @constructor init(cpx, cpy, x, y, [id])
         * @param {number} cpx(x controlpoint) Sets the cpx(x controlpoint) property of the current instance.         *
         * @param {number} cpy(y controlpoint) Sets the cpy(y controlpoint) property of the current instance.
         * @param {number} x Sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.QuadraticCurveTo
         * @public
         * @version 1.0
         **/
        init: function init(cpx, cpy, x, y, id) {

            this.base();

            this._tweenables.register("number", "x", "y", "cpx", "cpy");
            this.serializables("x", "y", "cpx", "cpy");

            if (wd.is.plainObject(arguments[0])) {
                this.deserialize(arguments[0]);
            }
            else {
                if (id !== undefined) this.id = id;
                if (x !== undefined) this.x = x;
                if (y !== undefined) this.y = y;
                if (cpx !== undefined) this.cpx = cpx;
                if (cpy !== undefined) this.cpy = cpy;
            }
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {

            var _x = this.x + x;
            var _y = this.y + y;

            var cpx = this.cpx + x;
            var cpy = this.cpy + y;

            ctx.quadraticCurveTo(cpx, cpy, _x, _y);
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.QuadraticCurveTo].
         *
         * @memberOf webDoodling.QuadraticCurveTo
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.QuadraticCurveTo]";
        }

    }, wd.PathSegment);

    wd.QuadraticCurveTo = QuadraticCurveToSegment;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Path DisplayObject
(function (wd, undefined) {
    "use strict";

    var BezierCurveToSegment;

   /**
     * Represents the `webDoodling.BezierCurveTo`.
     *
     * @class webDoodling.BezierCurveTo
     *
     * @example
     * var path = webDoodling.Path({
     *      x:20,
     *      y:20,
     *      lineJoin: 'round',
     *      segments:[
     *          webDoodling.BeginPath(),
     *          webDoodling.MoveTo(100, 100),
     *          webDoodling.LineTo(200, 200),
     *          webDoodling.BezierCurveTo(450, 300, 550, 100, 600, 200),
     *          webDoodling.ClosePath()
     *      ],
     *      styles:[
     *          webDoodling.Stroke('red', 20),
     *          webDoodling.Fill('yellow')
     *      ]
     * });
     *
     * @extends webDoodling.PathSegment
     *
     * @public
     * @version 1.0
     **/
    BezierCurveToSegment = wd.Class({

        /**
         * Returns the `type` of `webDoodling.BezierCurve`, always returns 'BezierCurve'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        type: wd.type("BezierCurveTo"),

        /**
         * Gets or sets the `x` property of the `webDoodling.BezierCurveTo`.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),
        /**
         * Gets or sets the `y` property of the `webDoodling.BezierCurveTo`.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Gets or sets the `cp1x`(x controlpoint1) property of the `webDoodling.BezierCurveTo`.
         *
         * @field {number} cp1x
         * @default 0
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        cp1x: wd.attribute(0),

        /**
         * Gets or sets the `cp1y`(y controlpoint1) property of the `webDoodling.BezierCurveTo`.
         *
         * @field {number} cp1y
         * @default 0
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        cp1y: wd.attribute(0),

        /**
         * Gets or sets the `cp2x`(x controlpoint2) property of the `webDoodling.BezierCurveTo`.
         *
         * @field {number} cp2x
         * @default 0
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        cp2x: wd.attribute(0),

        /**
         * Gets or sets the `cp2y`(y controlpoint1) property of the `webDoodling.BezierCurveTo`.
         *
         * @field {number} cp2y
         * @default 0
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        cp2y: wd.attribute(0),

        /**
         * Intializes the current instance of webDoodling.BezierCurveTo.
         *
         * @constructor init(cp1x, cp1y, cp2x, cp2y, x, y, [id])
         * @param {number} cp1x(x controlpoint1) Sets the cpx1(x controlpoint1) property of the current instance.
         * @param {number} cp1y(y controlpoint1) Sets the cpy1(y controlpoint1) property of the current instance.
         * @param {number} cp2x(x controlpoint2) Sets the cpx2(x controlpoint2) property of the current instance.
         * @param {number} cp2y(y controlpoint2) Sets the cpy2(y controlpoint2) property of the current instance.
         * @param {number} x Sets the x property of the current instance.
         * @param {number} y Sets the y property of the current instance.
         * @param {[string]} id Sets the id of the current instance. This parameter is optional.
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        init: function init(cp1x, cp1y, cp2x, cp2y, x, y, id) {
            this.base();

            this._tweenables.register("number", "x", "y", "cp1x", "cp1y", "cp2x", "cp2y");
            this.serializables("x", "y", "cp1x", "cp1y", "cp2x", "cp2y");

            if (wd.is.plainObject(arguments[0])) {
                this.deserialize(arguments[0]);
            }
            else {
                if (id !== undefined) this.id = id;
                if (x !== undefined) this.x = x;
                if (y !== undefined) this.y = y;
                if (cp1x !== undefined) this.cp1x = cp1x;
                if (cp1y !== undefined) this.cp1y = cp1y;
                if (cp2x !== undefined) this.cp2x = cp2x;
                if (cp2y !== undefined) this.cp2y = cp2y;
            }

        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {

            var _x = this.x + x;
            var _y = this.y + y;

            var cp1x = this.cp1x + x;
            var cp1y = this.cp1y + y;

            var cp2x = this.cp2x + x;
            var cp2y = this.cp2y + y;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, _x, _y);
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.BezierCurveTo].
         *
         * @memberOf webDoodling.BezierCurveTo
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.BezierCurveTo]";
        }

    }, wd.PathSegment);

    wd.BezierCurveTo = BezierCurveToSegment;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Spline DisplayObject
(function (wd) {
    "use strict";

    var Spline;

    /**
     * Represents the `webDoodling.Spline` DisplayObject.
     *
     * @class webDoodling.Spline
     *
     * @example
     * wd.Spline({
     *      id: 'spline',
     *      tension: 0.1,
     *      draggable: true,
     *      lineCap: 'round',
     *      points: [
     *          wd.Point(100, 200),
     *          wd.Point(150, 100),
     *          wd.Point(200, 200),
     *          wd.Point(250, 100),
     *          wd.Point(300, 200),
     *          wd.Point(350, 100)
     *      ],
     *      styles: [
     *          wd.Stroke('red', 10),
     *          wd.Stroke('yellow', 5),
     *      ]
     * })
     *
     * @extends webDoodling.StyleableDisplayObject
     * @public
     * @version 1.0
     **/
    Spline = wd.Class({

        /**
         * Returns the type of `webDoodling.Spline`, always returns 'Spline'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Spline
         * @public
         * @version 1.0
         **/
        type: wd.type("Spline"),

        /**
         * Gets or sets the `closed` of the `webDoodling.Spline`.
         * if `closed` is  true then path is closed
         *
         * @memberOf webDoodling.Spline
         * @public
         * @version 1.0
         **/
        closed: wd.attribute(false),

        /**
         * Gets or sets the `points` of the `webDoodling.Spline`.
         *
         * @field {number} points
         * @default null
         *
         * @memberOf webDoodling.Spline
         * @public
         * @version 1.0
         **/
         //wd.attribute([{x: 10, y: 250}, {x: 50, y: 100}, {x: 70, y: 200}, {x: 100, y: 50}, {x: 130, y: 200}, {x: 160, y: 20}, {x:180, y: 225}, {x: 200, y: 10}, {x: 230, y: 100}, {x: 260, y: 150}, {x: 290, y: 50}, {x: 302, y: 200}])
        points: wd.property({
            value: null,
            get: function() {
                return this._points;
            },
            set: function(v) {
                if (wd.is.array(v)) {
                    this._points = wd.PointCollection.fromArray(v);
                }
                else if (v instanceof wd.PointCollection) {
                    this._points = v;
                }
            }
        }),

        /**
         * Gets or sets the `tension` of the `webDoodling.Spline`.
         *
         * @field {string} tension
         * @default 0
         *
         * @memberOf webDoodling.Spline
         * @public
         * @version 1.0
         **/
        tension: wd.property({
            value: 0,
            get: function () {
                return this._tension;
            },
            set: function (v) {
                this._tension = Math.max(Math.min(v, 1), -1);
            }
        }),

         /**
          * Initializes the new instance of `webDoodling.Spline`.
          *
          * @constructor init(o)
          * @param {object} o The initialization options in JSON format.
          *
          * @memberOf webDoodling.Spline
          * @public
          * @version 1.0
          **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "tension");
            this.serializables("tension", "closed", "points");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            //ctx.lineCap = lineCap;
            //ctx.lineCap = this.lineCap;
            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;

            _drawSpline(ctx, this.points, this._tension, this.closed, x, y);
        },

        /**
         * Returns an object of `webDoodling.Path` generated from current spline.
         *
         * @function toPath()
         * @returns {webDoodling.Path} The `webDoodling.Path object`.
         *
         * @memberOf webDoodling.Spline
         * @public
         * @version 1.0
         **/
        toPath: function toPath() {
            return _splineToPath(this.points, this._tension, this.closed, this.x, this.y);
        },

        getBoundingBox: function getBoundingBox() {
            var box = wd.geometry.Spline.getBoundingBox(this._points, this._tension, this.x, this.y);
            return box;
        },

         /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Spline].
         *
         * @memberOf webDoodling.Spline
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Spline]";
        }

    }, wd.StyleableDisplayObject);

    wd.Spline = Spline;

    function _drawSpline (ctx, points, tension, closed, x, y) {
        var i, iLen, cpx, cpy, cpx1, cpy1, cpx2, cpy2,
            previousX, previousY, nextX, nextY, currentX, currentY, startX, startY, positionX, positionY,
            controls = [];

        tension = tension || 0;
        closed  = closed || false;
        x       = x || 0;
        y       = y || 0;

        if (points instanceof wd.PointCollection) {
            points = points._items;
        }

        if (points.length === 0) {
            return;
        }

        if (points.length === 1) {
            return;
        }

        if (points.length === 2) {
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            return;
        }

        startX = points[0].x;
        startY = points[0].y;

        positionX = points[1].x;
        positionY = points[1].y;

        for (i = 1, iLen = points.length - 1; i < iLen; i += 1) {
            previousX = points[i - 1].x;
            previousY = points[i - 1].y;
            currentX = points[i].x;
            currentY = points[i].y;
            nextX = points[i + 1].x;
            nextY = points[i + 1].y;

            controls = controls.concat(
                _controlPoints(previousX, previousY,
                               currentX, currentY,
                               nextX, nextY, tension));
        }
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        cpx = controls[0];
        cpy = controls[1];
        ctx.quadraticCurveTo(cpx, cpy, positionX, positionY);
        for (i = 1, iLen = points.length - 1; i < iLen; i += 1) {
            cpx1 = controls[(2 * (i - 1) - 1) * 2];
            cpy1 = controls[(2 * (i - 1) - 1) * 2 + 1];
            cpx2 = controls[(2 * (i - 1)) * 2];
            cpy2 = controls[(2 * (i - 1)) * 2 + 1];
            positionX = points[i].x;
            positionY = points[i].y;
            ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, positionX, positionY);
        }
        cpx = controls[(2 * (i - 1) - 1) * 2];
        cpy = controls[(2 * (i - 1) - 1) * 2 + 1];
        positionX = points[i].x;
        positionY = points[i].y;

        ctx.quadraticCurveTo(cpx, cpy, positionX, positionY);

        if (closed === true) {
            ctx.closePath();
        }
    }

    function _splineToPath (points, tension, closed, x, y) {
        var i, iLen, cpx, cpy, cpx1, cpy1, cpx2, cpy2,
            path,
            previousX, previousY, nextX, nextY, currentX, currentY, startX, startY, positionX, positionY,
            controls = [];

        path = new wd.Path();

        tension = tension || 0;
        closed  = closed || false;
        x       = x || 0;
        y       = y || 0;

        if (points instanceof wd.PointCollection) {
            points = points._items;
        }

        if (points.length === 0) {
            return path;
        }

        if (points.length === 1) {
            startX = points[0].x;
            startY = points[0].y;
            path.segments.add(wd.BeginPath());
            path.segments.add(wd.MoveTo(startX, startY));
            return path;
        }

        if (points.length === 2) {
            path.segments.add(wd.BeginPath());
            path.segments.add(wd.MoveTo(points[0].x, points[0].y));
            path.segments.add(wd.LineTo(points[1].x, points[1].y));
            return path;
        }

        startX = points[0].x;
        startY = points[0].y;

        positionX = points[1].x;
        positionY = points[1].y;

        for (i = 1, iLen = points.length - 1; i < iLen; i += 1) {
            previousX = points[i - 1].x;
            previousY = points[i - 1].y;
            currentX = points[i].x;
            currentY = points[i].y;
            nextX = points[i + 1].x;
            nextY = points[i + 1].y;

            controls = controls.concat(
                _controlPoints(previousX, previousY,
                               currentX, currentY,
                               nextX, nextY, tension));
        }

        path.segments.add(wd.BeginPath());
        path.segments.add(wd.MoveTo(startX, startY));
        cpx = controls[0];
        cpy = controls[1];
        //ctx.quadraticCurveTo(cpx, cpy, positionX, positionY); // x y plu
        path.segments.add(wd.QuadraticCurveTo(cpx, cpy, positionX, positionY));

        for (i = 2, iLen = points.length - 1; i < iLen; i += 1) {
            cpx1 = controls[(2 * (i - 1) - 1) * 2];
            cpy1 = controls[(2 * (i - 1) - 1) * 2 + 1];
            cpx2 = controls[(2 * (i - 1)) * 2];
            cpy2 = controls[(2 * (i - 1)) * 2 + 1];
            positionX = points[i].x;
            positionY = points[i].y;
            //ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, positionX, positionY);
            path.segments.add(wd.BezierCurveTo(cpx1, cpy1, cpx2, cpy2, positionX, positionY));
        }
        cpx = controls[(2 * (i - 1) - 1) * 2];
        cpy = controls[(2 * (i - 1) - 1) * 2 + 1];
        positionX = points[i].x;
        positionY = points[i].y;
        //ctx.quadraticCurveTo(cpx, cpy, positionX, positionY);
        path.segments.add(wd.QuadraticCurveTo(cpx, cpy, positionX, positionY));
        if (closed === true) {
            //ctx.closePath();
            path.segments.add(wd.ClosePath());
        }
        return path;
    }

    function _distance(p, i, j) {
        return Math.sqrt(Math.pow(p[2 * i] - p[2 * j], 2) + Math.pow(p[2 * i + 1] - p[2 * j + 1], 2));
    }

    function _vector(p, i, j) {
        return [p[2 * j] - p[2 * i], p[2 * j + 1] - p[2 * i + 1]];
    }

    function _controlPoints(x1, y1, x2, y2, x3, y3, t) {
        var v = _vector(arguments, 0, 2),
            d01 = _distance(arguments, 0, 1),
            d12 = _distance(arguments, 1, 2),
            d012 = d01 + d12;
        return [x2 - v[0] * t * d01 / d012, y2 - v[1] * t * d01 / d012,
                x2 + v[0] * t * d12 / d012, y2 + v[1] * t * d12 / d012];
    }

    /**
     * Draws the Spline shape on given context.
     *
     * @function drawSpline(ctx, points, tension)
     * @param  {CanvasRenderingContext2D} ctx The context on which Spline is to be drawn.
     * @param  {number} points The points of Spline.
     * @param  {number} tension The tension of Spline.
     *
     * @static webDoodling.Spline
     * @public
     * @version 1.0
     **/
    wd.Spline.drawSpline = _drawSpline;

})(window.webDoodling);
// Copyright (c) 2010 - 2015 - Maniar Technologies Private Limited - India
// The SVG Source
(function (wd, undefined) {
    "use strict";

    var SVGSource;

    /**
      * TODO: Full Description
      *
      * @memberOf webDoodling.Audio
      * @public
      * @version 1.0
      **/
    SVGSource = wd.Class({
        /**
         * Returns the `type` of `webDoodling.SVGSource`, always returns 'SVGSource'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.SVGSource
         * @public
         * @version 1.0
         **/
        type: wd.type("SVGSource"),

        /** Gets or Sets the width of `webDoodling.SVGSource`.
          *
          * @memberOf webDoodling.SVGSource
          * @public
          * @version 1.0
          **/
        width: wd.property({
            value: 0,
            get: function () {
                return this._width;
            },
            set: function (v) {
                this._width = v;
                // if (this._source !== "") {
                //     this._width = v;
                // }
            }
        }),

        /** Gets or Sets the height of `webDoodling.SVGSource`.
          *
          * @memberOf webDoodling.SVGSource
          * @public
          * @version 1.0
          **/
        height: wd.property({
            value: 0,
            get: function () {
                return this._height;
            },
            set: function (v) {
                this._height = v;
                // if (this._source !== "") {
                //     this._height = v;
                // }
            }
        }),

        /** Gets or Sets the source of `webDoodling.SVGSource`.
          *
          * @memberOf webDoodling.SVGSource
          * @public
          * @version 1.0
          **/
        source: wd.property({
            value: " ",
            get: function () {
                return this._source;
            },
            set: function (v) {
                var img = new Image(),
                    ext = v.slice(-3);
                this._source = v;

                if (ext !== "svg" && v.substring(0, 4) !== "data") {
                    //if xml svg source is provided namespace is mandatory otherwise it will generate following error.
                    //The HTMLImageElement provided is in the 'broken' state.
                    this._source = "data:image/svg+xml;base64,"+btoa(v);
                }

                if (v === "" || v === null) {
                    this._image = null;
                }
                else {
                    // img.setAttribute("src", this._source);
                    // img.setAttribute("width", this.width);
                    // img.setAttribute("height", this.height);
                    img.src = this._source;
                    img.style.width = this.width;
                    img.style.height = this.height;
                    this._image = img;
                }
            }
        }),

        image: wd.readonly(null),

        /**
          * Initialize the svg source of the `webDoodling.SVGSource`.
          *
          * @param {string} src The source of the audio file.
          * @param {boolean} autoPlay The autoPlay of the audio file.
          *
          * var audio = new WebAudio(src, autoLoad, autoPlay)
          *
          * @memberOf webDoodling.SVGSource
          * @public
          * @version 1.0
          **/
        init: function init() {
            var arg1 = arguments[0],
                arg2 = arguments[1],
                arg3 = arguments[2],
                argLen = arguments.length;

            this.base();

            this.serializables("width", "height", "source");

            if (argLen === 1) {
                if (wd.is.plainObject(arg1)) {
                    this.deserialize(arg1);
                }
                else {
                    this._source = arg1;
                }
            }
            else {
                if (arg1 !== undefined) this._source = arg1;
                if (arg2 !== undefined) this._width = arg2;
                if (arg3 !== undefined) this._height = arg3;
            }
        },

        /**
         * Return the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.SVGSource].
         *
         * @memberOf webDoodling.SVGSource
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.SVGSource]";
        }
    }, wd.Serializable);

    wd.SVGSource = SVGSource;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Asset Collection
(function (wd) {
    "use strict";

    var PathSegmentCollection;

    /**
     * Represent the `webDoodling.PathCollection`.
     *
     * @class webDoodling.PathSegmentCollection
     *
     * @extends webDoodling.Collection
     * @public
     * @version 1.0
     **/
    PathSegmentCollection = wd.Class({

        /**
         * Returns the `type` of `webDoodling.PathSegmentCollection`,
         * always returns 'PathSegmentCollection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.PathSegmentCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("PathSegmentCollection"),

        /**
         * Initializes the new instance of `webDoodling.PathSegmentCollection`.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.PathSegmentCollection
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();
            this.onValidate = function (obj) {
                if (obj instanceof wd.PathSegment === false) {
                    throw new wd.Error("wd-invalid-argument", obj);
                }
                return null;
            };
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [webDoodling.PathSegmentCollection]
         *
         * @memberOf webDoodling.PathSegmentCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.PathSegmentCollection]";
        }

    }, wd.Collection);

    wd.PathSegmentCollection = PathSegmentCollection;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Line DisplayObject
(function (wd) {
    "use strict";

    var Line;
    /**
     * Represents the `webDoodling.Line` DisplayObject.
     *
     * @class webDoodling.Line
     *
     * @example
     * var line = new webDoodling.Line({
     *     x: 100,
     *     y: 100,
     *     x2: 300,
     *     y2: 300,
     *     lineCap: 'butt',
     *     styles: [
     *         new webDoodling.Stroke('red', 5)
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Line = wd.Class({
        /**
         * Returns the `type` of `webDoodling.Line`, always returns 'Line'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Line
         * @public
         * @version 1.0
         **/
        type: wd.type("Line"),

        /**
         * Gets or sets the `x` cordinates of the `webDoodling.Line`.
         *
         * @field {number} x2
         * @default 0
         *
         * @memberOf webDoodling.Line
         * @public
         * @version 1.0
         **/
        x2: wd.attribute(0),

        /**
         * Gets or sets the `y` cordinates of the `webDoodling.Line`.
         *
         * @field {number} y2
         * @default 0
         *
         * @memberOf webDoodling.Line
         * @public
         * @version 1.0
         **/
        y2: wd.attribute(0),

        /**
         * Initializes the new instance of `webDoodling.Line`.
         *
         * @constructor init(o)
         * @param  {type} o The initialization object.
         *
         * @memberOf webDoodling.Line
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "x2", "y2");
            this.serializables("x2", "y2");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {

            var dx = x - this.x;
            var dy = y - this.y;
            //console.log(this.x, x, dx);
            //console.log(this.y, y, dy);
            ctx.lineCap = this.lineCap;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(this.x2 + dx, this.y2 + dy);
        },

        getBoundingBox: function getBoundingBox() {
            var box = wd.geometry.Line.getBoundingBox(this.x, this.y, this.x2, this.y2);
            return box;
        },

         /**
          * Returns the string representation of current instance.
          *
          * @function toString()
          * @returns {string} Always returns [object webDoodling.Line].
          *
          * @memberOf webDoodling.Line
          * @public
          * @version 1.0
          **/
        toString: function toString() {
            return "[object webDoodling.Line]";
        }

    }, wd.StyleableDisplayObject);

    wd.Line = Line;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Rectangle DisplayObject
(function (wd) {
    "use strict";

    var Rectangle;

    /**
     * Represents the `webDoodling.Rectangle` DisplayObject, which has got the shape
     * of a Rectangle.
     *
     * @class webDoodling.Rectangle
     *
     * @example
     * var rectangle = webDoodling.Rectangle({
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 100,
     *     styles: [
     *         webDoodling.Stroke('green', 20),
     *         webDoodling.Stroke('blue', 10),
     *         webDoodling.Fill('black'),
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     * @public
     * @version 1.0
     **/
    Rectangle = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Rectangle`, always returns 'Rectangle'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Rectangle
         * @public
         * @version 1.0
         **/
        type: wd.type("Rectangle"),

        /**
         * Gets or sets the `width` of the `webDoodling.Rectangle`.
         *
         * @field {number} width
         * @default 0
         *
         * @memberOf webDoodling.Rectangle
         * @public
         * @version 1.0
         **/
        width: wd.attribute(0),

        /**
         * Gets or sets the `height` of the `webDoodling.Rectangle`.
         *
         * @field {number} height
         * @default 0
         *
         * @memberOf webDoodling.Rectangle
         * @public
         * @version 1.0
         **/
        height: wd.attribute(0),

        /**
         * Initializes the new instance of `webDoodling.Rectangle`.
         *
         * @constructor init(o)
         * @param  {object} o The initialization options in JSON format.
         *
         * @memberOf webDoodling.Rectangle
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "width", "height");
            this.serializables("width", "height");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;

            _drawRect(ctx, x, y, this.width, this.height);
        },

        getBoundingBox: function getBoundingBox() {
            return {x: this.x, y: this.y, width: this.width, height: this.height};
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Rectangle].
         *
         * @memberOf webDoodling.Rectangle
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Rectangle]";
        }

    }, wd.StyleableDisplayObject);

    wd.Rectangle = Rectangle;

    function _drawRect(ctx, x, y, width, height) {
        var r = x + width,
            b = y + height;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(r, y);
        ctx.lineTo(r, b);
        ctx.lineTo(x, b);
        ctx.closePath();
    }

    /**
     * Draws the rectangle on given context.
     *
     * @function drawRect(ctx, x, y, width, height)
     * @param  {CanvasRenderingContext2D} ctx The context on which rectangle is to be drawn.
     * @param  {number} x The x position of rectangle.
     * @param  {number} y The y position of rectangle.
     * @param  {number} width The width position of rectangle.
     * @param  {number} height The height position of rectangle.
     *
     * @static webDoodling.Rectangle
     * @public
     * @version 1.0
     **/
    wd.Rectangle.drawRect = _drawRect;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The RoundedRectangle DisplayObject
(function (wd) {
    "use strict";

    var RoundedRectangle;

    /**
     * Represents the `webDoodling.RoundedRectangle` DisplayObject, which has got the shape
     * of an RoundedRectangle.
     *
     * @class webDoodling.RoundedRectangle
     *
     * @example
     * var roundedRectangle = webDoodling.RoundedRectangle({
     *     x:200,
     *     y:200,
     *     width:200,
     *     height:100,
     *     corners:[10, 50, 30, 50],
     *     styles:[
     *        webDoodling.Stroke('red', 20),
     *        webDoodling.Stroke('blue', 10),
     *        webDoodling.Fill('yellow')
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     * @public
     * @version 1.0
     **/
    RoundedRectangle = wd.Class({

        /**
         * Gets the type of `webDoodling.RoundedRectangle`, always returns 'RoundedRectangle'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.RoundedRectangle
         * @public
         * @version 1.0
         **/
        type: wd.type("RoundedRectangle"),


        /**
         * Gets or sets the `width` of the `webDoodling.RoundedRectangle`.
         *
         * @field {number} width
         * @default 0
         *
         * @memberOf webDoodling.RoundedRectangle
         * @public
         * @version 1.0
         **/
        width: wd.attribute(0),

        /**
         * Gets or sets the `height` of the `webDoodling.RoundedRectangle`.
         *
         * @field {number} height
         * @default 0
         *
         * @memberOf webDoodling.RoundedRectangle
         * @public
         * @version 1.0
         **/
        height: wd.attribute(0),

        /**
         * Gets or sets the `corners` of the `webDoodling.RoundedRectangle`.
         *
         * @field {number} corners
         * @default 0
         *
         * @memberOf webDoodling.RoundedRectangle
         * @public
         * @version 1.0
         **/
        corners: wd.property({
            value: [0, 0, 0, 0],
            get: function () {
                return this._corners;
            },
            set: function (v) {
                this._corners = _getNormalizedCorners(v);
            }
        }),

         /**
          * Initializes the new instance of `webDoodling.RoundedRectangle`.
          *
          * @constructor init(o)
          * @param {object} o The initialization options in JSON format.
          *
          * @memberOf webDoodling.RoundedRectangle
          * @public
          * @version 1.0
          **/
        init: function init(o) {
            this.base();
            // TODO #48: Make all corners of webDoodling.RoundedRectangle display object separately tweenable.
            this._tweenables.register("number", "width", "height", "corners");
            this.serializables("width", "height", "corners");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            _drawRoundedRectangle(ctx, x, y, this.width, this.height, this.corners, true);
        },

        getBoundingBox: function getBoundingBox() {
            return {x: this.x, y: this.y, width: this.width, height: this.height};
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.RoundedRectangle].
         *
         * @memberOf webDoodling.RoundedRectangle
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.RoundedRectangle]";
        }

    }, wd.StyleableDisplayObject);

    wd.RoundedRectangle = RoundedRectangle;

    function _getNormalizedCorners(corners) {
        if (wd.is.array(corners)) {
            if (corners.length === 4) {
                return corners;
            }
            else if (corners.length === 2) {
                return [corners[0], corners[1], corners[0], corners[1]];
            }
            else {
                return [corners[0], corners[0], corners[0], corners[0]];
            }
        }
        else if (wd.is.number(corners)) {
            return [corners, corners, corners, corners];
        }
        throw new wd.Error("wd-invalid-argument", "corners");
    }

    function _drawRoundedRectangle(ctx, x, y, width, height, corners, normalized) {
        var r = x + width,
            b = y + height,
            cr = corners;

        if (!normalized) {
            cr = _getNormalizedCorners(corners);
        }

        ctx.beginPath();
        ctx.moveTo(x + cr[0], y);
        // Top
        ctx.lineTo(r - cr[1], y);
        ctx.quadraticCurveTo(r, y, r, y + cr[1]);

        //Right
        ctx.lineTo(r, b - cr[2]);
        ctx.quadraticCurveTo(r, b, r - cr[2], b);

        //Bottom
        ctx.lineTo(x + cr[3], b);
        ctx.quadraticCurveTo(x, b, x, b - cr[3]);

        //Left
        ctx.lineTo(x, y + cr[0]);
        ctx.quadraticCurveTo(x, y, x + cr[0], y);
        ctx.closePath();
    }

    /**
     * Draws the rounded rectangle on given context.
     *
     * @function drawRect(ctx, x, y, width, height, corners)
     * @param  {CanvasRenderingContext2D} ctx The drawing context.
     * @param  {number} x The x position of RoundedRectangle.
     * @param  {number} y The y position of RoundedRectangle.
     * @param  {number} width The width of RoundedRectangle.
     * @param  {number} height The height of RoundedRectangle.
     * @param  {Array, number} corners The corners of RoundedRectangle.
     *
     * @static webDoodling.RoundedRectangle
     * @public
     * @version 1.0
     **/
    wd.RoundedRectangle.drawRoundedRectangle = _drawRoundedRectangle;


})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Text DisplayObject
(function (wd, undefined) {
    "use strict";

    var Text;

    /**
     * Represents the `webDoodling.Text` DisplayObject.
     *
     * @class webDoodling.Text
     *
     * @example
     * var text = webDoodling.text({
     *     x: 200,
     *     y: 200,
     *     text:'Hello\nWorld',
     *     font:"50px arial",
     *     lineJoin:'round',
     *     styles:[
     *         webDoodling.Stroke('yellow', 10),
     *         webDoodling.Fill('red'),
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Text = wd.Class({

        /**
         * Returns the type of `webDoodling.Text`, always returns 'Text'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Text
         * @public
         * @version 1.0
         **/
        type: wd.type("Text"),

        /**
         * Gets or sets the `text` of the `webDoodling.Text`.
         *
         * @field {number} text
         * @default 0
         *
         * @memberOf webDoodling.Text
         * @public
         * @version 1.0
         **/
        text: wd.attribute(0),

        /**
         * Gets or sets the `font` of the `webDoodling.Text`.
         *
         * @field {number} font
         * @default 10px
         *
         * @memberOf webDoodling.Text
         * @public
         * @version 1.0
         **/
        font: wd.attribute("10px sans-serif"), // (default 10px sans-serif)

        /**
         * Gets or sets the `textAlign` of the `webDoodling.Text`.
         *
         * @field {string} textAlign
         * @default start
         *
         * @memberOf webDoodling.Text
         * @public
         * @version 1.0
         **/
        textAlign: wd.attribute("start"), // "start", "end", "left", "right", "center" (default: "start")

        /**
         * Gets or sets the `textBaseline` of the `webDoodling.Text`. The valid values are...
         * - top
         * - hanging
         * - middle
         * - alphabetic
         * - ideographic
         * - bottom
         *
         * @field {string} textBaseline
         * @default top
         *
         * @memberOf webDoodling.Text
         * @public
         * @version 1.0
         **/
        textBaseline: wd.attribute("top"),

        /**
         * Initializes the new instance of `webDoodling.Text`.
         *
         * @constructor init(o)
         * @param {object} o The initialization options in JSON format.
         *
         * @memberOf webDoodling.Text
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this.serializables("text", "font", "textAlign", "textBaseline");
            if (o) this.deserialize(o);
        },

        /**
         * This function is responsible for applying style.
         *
         * @function  onApplyStyles(ctx, x, y)
         * @param {2DContext} ctx The drawing context.
         * @param {number} x The x coordinate.
         * @param {number} y the y coordinate.
         *
         * @memberOf webDoodling.Text
         * @protected This function should not be called directly.
         * @version 1.0
         **/
        onApplyStyles: function onApplyStyles(ctx, x, y) {
            var styles = this.styles.toArray(),
                text = this.text,
                i, iLen;

            //ctx.lineJoin = this.lineJoin;
            ctx.textAlign = this.textAlign;
            ctx.textBaseline = this.textBaseline;
            ctx.font = this.font;
            for (i = 0, iLen = styles.length; i < iLen; i++) {
                styles[i].onApplyTextStyle(ctx, text, x, y, this);
            }
        },

        /**
         * Gets invoked when hit region needs to be pained.
         *
         * @function onApplyHitRegionStyles(ctx, x, y, color)
         * @param {CanvasRenderingContext2D} ctx The context on which text is to be drawn.
         * @param {number} x The x position of text.
         * @param {number} y The y position of text.
         * @param {string} color The color of text.
         *
         * @memberOf webDoodling.Text
         * @protected
         * @version 1.0
         **/
        onApplyHitRegionStyles: function onApplyHitRegionStyles(ctx, x, y, color) {
            var styles = this.styles.getHitRegionStyles(),
                text = this.text,
                style,
                i, iLen;

            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;
            ctx.textAlign = this.textAlign;
            ctx.textBaseline = this.textBaseline;
            ctx.font = this.font;

            for (i = 0, iLen = styles.length; i < iLen; i++) {
                style = styles[i];
                style.onApplyTextStyle(ctx, text, x, y, this, color);
            }
        },

        getBoundingBox: function getBoundingBox() {
            var ctx, box;
            if (this.scene === undefined) {
                return {x: 0, y: 0, height: 0, width: 0};
            }
            ctx = this.scene.getExtraContext();
            box = wd.geometry.Text.getBoundingBox(ctx, this.x, this.y, this.font, this.textAlign, this.textBaseline, this.text);
            return box;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Text].
         *
         * @memberOf webDoodling.Text
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Text]";
        }

    }, wd.StyleableDisplayObject);

    wd.Text = Text;

    //wd.TypeRegistry.register('rectangle', wd.Rectangle);

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Paragraph DisplayObject
(function (wd, undefined) {
    "use strict";

    var Paragraph, ParagraphContext;

    /**
     * Represents the `webDoodling.Paragraph` DisplayObject.
     *
     * @class webDoodling.Paragraph
     *
     * @example
     * var paragraph = new webDoodling.Paragraph({
     *     x: 100,
     *     y: 200,
     *     text: 'Lorem ipsum dolor sit amet consectetur adipisicing elit. Sed do eiusmod tempor incididunt ut
     *            labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris
     *            nisi ut aliquip ex ea commodo consequat.',
     *     styles:[
     *          new wd.Stroke('blue', 5),
     *          new wd.Fill('white')
     *    ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject     *
     * @public
     * @version 1.0
     **/
    Paragraph = wd.Class({

        /**
         * Returns the type of `webDoodling.Paragraph`, always returns 'Paragraph'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        type: wd.type("Paragraph"),

        /**
         * Gets or sets the `text` of the `webDoodling.Paragraph`.
         *
         * @field {string} text
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        text: wd.property({
            value: "",
            get: function() {
                return this._text;
            },
            set: function(v) {
                this._text = v;
                this._dirty = true;
                this._para = this._text;
            }
        }),

        /**
         * Gets or sets the `font` of the `webDoodling.Paragraph`.
         *
         * @field {string} font
         * @default 10px sans-serif
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        font: wd.property({
            value: "10px sans-serif",
            get: function() {
                return this._font;
            },
            set: function(v) {
                this._font = v;
                this._dirty = true;
                this._para = this._text;
            }
        }), // (default 10px sans-serif)

        /**
         * Gets or sets the `width` of the `webDoodling.Paragraph`.
         * When set to auto, paragraph only wraps at newline '\n'
         * character.
         *
         * @field {number} width
         * @default auto
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        width: wd.property({
            value: "auto",
            get: function() {
                return this._width;
            },
            set: function(v) {
                this._width = v;
                this._dirty = true;
                this._para = this._text;
            }
        }),

        /**
         * Gets the absolute width of the `webDoodling.Paragraph`.
         * If width is set to auto returns the calculated width
         * otherwise return width. Returns 0 if paragraph has just
         * changed its fields not yet rendered.
         *
         * @field {number} width
         * @default auto
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        absWidth: wd.readonly({
            get: function () {
                if (this.width === "auto") {
                    if (this._dirty === false) {
                        return this._absWidth;
                    }
                    return 0;
                }
                return this._width;
            }
        }),

        /**
         * Gets or sets the `textAlign` of the `webDoodling.Paragraph`. The valid values are...
         * - left
         * - right
         * - center
         *
         * @field {string} textAlign
         * @default left
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        textAlign: wd.property({
            value: "left",
            get: function () {
                return this._textAlign;
            },
            set: function(v) {
                this._textAlign = v;
                this._dirty = true;
                this._para = this._text;
            }
        }), //"left", "right", "center" (default: "left")

        /**
         * Gets or sets the `lineHeight` of the `webDoodling.Paragraph`.
         *
         * @field {number, auto} lineHeight
         * @default auto
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        lineHeight: wd.property({
            value: "auto",
            get: function() {
                return this._lineHeight;
            },
            set: function(v) {
                this._lineHeight = v;
                this._dirty = true;
                this._para = this._text;
            }
        }),


        /**
         * If `lineHeight` property is set to `auto` returns the calcuated
         * height else returns the value of lineHeight. Returns -1 if `lineHeight`
         * property is set to `auto` and it is not yet calculated.
         *
         * @readonly {number} lineHeightAbs
         * @default -1
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        lineHeightAbs: wd.readonly({
            value: -1,
            get: function () {
                return this._lineHeightAbs;
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.Paragraph`.
         *
         * @constructor init(o)
         * @param {object} o The initialization options in JSON format.
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._dirty = true;
            this._para = this._text;
            this.serializables("text", "font", "width", "textAlign", "lineHeight");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx) {
            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;
            ctx.textAlign = this.textAlign;
            ctx.textBaseline = "top";
            ctx.font = this.font;

            if (this._dirty) {
                this._updateParaInfo(ctx);
            }
        },

        /**
         * TODO: Complete the description
         * This function is responsible for applying style.
         *
         * @function onApplyStyles(ctx, x, y)
         * @param {2DContext} ctx The drawing context.
         * @param {number} x The x coordinate.
         * @param {number} y The y coordinate.
         *
         * @memberOf webDoodling.Paragraph
         * @protected This function should not be called directly.
         * @version 1.0
         **/
        onApplyStyles: function onApplyStyles(ctx, x, y) {
            var styles = this.styles.toArray(),
                text, style,
                //lineWidth,
                lineY = 0,
                lineHeight = this._lineHeightAbs,
                textAlign = this._textAlign,
                width = this._width,
                i, iLen,
                j, jLen;

            if (textAlign === "right") {
                x = x + width;
            }
            else if (textAlign === "center") {
                x = x + (width / 2);
            }

            for (i = 0, iLen = styles.length; i < iLen; i++) {
                style = styles[i];
                //lineWidth = style.lineWidth;
                lineY = 0;
                for (j = 0, jLen = this._para.length; j < jLen; j += 1) {

                    text = this._para[j];
                    style.onApplyTextStyle(ctx, text, x, y + lineY, this);
                    lineY += lineHeight;
                }
            }
        },

        /**
         * This function is responsible for painting hit regions.
         *
         * @function onApplyHitRegionStyles(ctx, x, y, color)
         * @param {ParagraphContext} ctx The drawing context.
         * @param {number} x The x coordinate.
         * @param {number} y The y coordinate.
         * @param {string} color The color value is in CSS format.
         *
         * @memberOf webDoodling.Paragraph
         * @protected This function should not be called directly.
         * @version 1.0
         **/
        onApplyHitRegionStyles: function onApplyHitRegionStyles(ctx, x, y, color) {
            var styles = this.styles.getHitRegionStyles(),
                text, style,
                lineY = 0,
                lineHeight = this._lineHeightAbs,
                textAlign = this._textAlign,
                width = this._width,
                i, iLen,
                j, jLen;

            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;
            ctx.textAlign = this.textAlign;
            ctx.textBaseline = "top";
            ctx.font = this.font;

            if (textAlign === "right") {
                x = x + width;
            }
            else if (textAlign === "center") {
                x = x + (width / 2);
            }

            for (i = 0, iLen = styles.length; i < iLen; i++) {
                style = styles[i];
                lineY = 0;
                for (j = 0, jLen = this._para.length; j < jLen; j += 1) {

                    text = this._para[j];
                    style.onApplyTextStyle(ctx, text, x, y + lineY, this, color);
                    lineY += lineHeight;
                }
            }
        },

        getBoundingBox: function getBoundingBox() {
            var ctx;
            if (this.scene === undefined) {
                return {x: 0, y: 0, width: 0, height: 0};
            }
            if (this._dirty) {
                ctx = this.scene.getExtraContext();
                this._updateParaInfo(ctx);
            }
            return {x: this.x, y: this.y, width: this.absWidth, height: this._para.length * this._lineHeightAbs};
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Paragraph]
         *
         * @memberOf webDoodling.Paragraph
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Paragraph]";
        },

        //Private Members

        _updateParaInfo: function (ctx) {
            var text = this._text,
                font = this._font,
                breaks = [],
                width = this._width,
                absWidth, maxWidth = 0,
                lines = [],
                mHeight,
                spaceWidth = 0,
                measureText = wd.geometry.Text.measureText,
                i, iLen;

            spaceWidth = measureText(ctx, " ", font).width;

            //Calculate lineHeight if it is set to auto
            if (this._lineHeight === "auto") {
                mHeight = measureText(ctx, "ABCxyz", font).height;
                this._lineHeightAbs = mHeight;
            }
            else {
                this._lineHeightAbs = this._lineHeight;
            }

            function getLines(l) {
                var wordWidth = 0, lineWidth = 0,
                    words = [], word,
                    complete = false, isLast,
                    line = "", lines = [];
                words = l.split(" ");

                for (var i = 0, iLen = words.length; i < iLen; i += 1) {
                    word = words[i];
                    wordWidth = measureText(ctx, word, font).width;
                    complete = false;
                    isLast = i === iLen - 1;

                    //if (width === 0) debugger;

                    if (lineWidth + wordWidth < width) {
                        line += word + " ";
                        lineWidth += wordWidth + spaceWidth;
                    }
                    else {
                        if (line.length !== 0) {
                            lines.push(line.substring(0, line.length - 1));
                        }

                        line = word + " ";
                        lineWidth = wordWidth + spaceWidth;

                        if (isLast) {
                            complete = false;
                        }
                        else {
                            complete = true;
                        }
                    }
                }

                if (complete === false) {
                    lines.push(line.substring(0, line.length - 1));
                }
                return lines;
            }

            breaks = text.split("\n");
            if (width === "auto") {
                lines = breaks;
            }
            else {
                for (i = 0, iLen = breaks.length; i < iLen; i += 1) {
                    lines = lines.concat(getLines(breaks[i]));
                }
            }

            if (width === "auto") {
                for (i = 0, iLen = lines.length; i < iLen; i += 1) {
                    absWidth = ctx.measureText(lines[i]).width;
                    maxWidth = absWidth > maxWidth ? absWidth : maxWidth;
                }
                this._absWidth = maxWidth;
            }

            this._para = lines;
            this._dirty = false;
        }

    }, wd.StyleableDisplayObject);

        /**
         * Represents the `webDoodling.ParagraphContext` which contains vital information
         * required for rendering paragraphs on `webDooding.Scene`.
         *
         * @class webDoodling.ParagraphContext
         *
         * @public
         * @version 1.0
         **/
    ParagraphContext = wd.Class({

        /**
         * Returns the type of `webDoodling.ParagraphContext`, always returns 'ParagraphContext'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ParagraphContext
         * @public
         * @version 1.0
         **/
        type: wd.type("ParagraphContext"),

        /**
         * Gets the array of `lines` (`string`) calculated from the associated
         * paragrapgh considering other members like `width`, `lineHeight` and `spaceWidth`.
         *
         * @readonly {Array(string)} lines
         *
         * @memberOf webDoodling.ParagraphContext
         * @public
         * @version 1.0
         **/
        lines: wd.readonly(),

        /**
         * Gets the `spaceWidth` of the `webDoodling.ParagraphContext`.
         *
         * @readonly {Number} spaceWidth
         *
         * @memberOf webDoodling.ParagraphContext
         * @public
         * @version 1.0
         **/
        spaceWidth: wd.readonly(),

        /**
         * Gets the `context` on which paragrahs needs to be rendered.
         *
         * @readonly {2DContext} context
         *
         * @memberOf webDoodling.ParagraphContext
         * @public
         * @version 1.0
         **/
        context: wd.readonly(),

        /**
         * Gets the `lineHeight` of the `webDoodling.ParagraphContext`.
         *
         * @readonly {number} lineHeight
         *
         * @memberOf webDoodling.ParagraphContext
         * @public
         * @version 1.0
         **/
        lineHeight: wd.readonly(),

        /**
         * Gets the `width` of the `webDoodling.ParagraphContext`.
         *
         * @readonly {number} width
         *
         * @memberOf webDoodling.ParagraphContext
         * @public
         * @version 1.0
         **/
        width: wd.readonly(),

        /**
         * Initializes the new instance of `webDoodling.ParagraphContext`. This class is
         * intended to be initialized by `webDoodling.Paragraph.getParagraphContext`
         * method and hence should not be used directly.
         *
         * @constructor init(context, lines, spaceWidth, lineHeight, width)
         * @param {context} context The context.
         * @param {lines} lines The line.
         * @param {spaceWidth} spaceWidth The spacewidth.
         * @param {lineHeight} lineHeight The lineHeight.
         * @param {width} width The width.
         *
         * @memberOf webDoodling.ParagraphContext
         * @public
         * @version 1.0
         **/

        init: function init(context, lines, spaceWidth, lineHeight, width) {
            this._context = context;
            this._lines = lines;
            this._spaceWidth = spaceWidth;
            this._lineHeight = lineHeight;
            this._width = width;
        }
    });

    /**
     * Spilts the text into the array of string which is required by
     * `webDoodling.Paragraph.drawParagraph` function to draw wrapped paragraphs.
     * This function requires context to be set with respective styles before the call.
     *
     * @function getParagraphContext(context, text, width)
     * @param {2DContext} context The 2DContext to which text will be drawn.
     * @param {string} text The text which needs to be split.
     * @param {number} width The width of the paragraph.
     *
     * @returns {webDoodling.ParagraphContext} The paragraph context, which contains information
     * for drawing paragraphs.
     *
     * @static webDoodling.ParagraphContext
     * @public
     * @version 1.0
     **/
    Paragraph.getParagraphContext = function getParagraphContext(context, text, width) {

        var breaks = [],
            lines = [],
            spaceWidth = 0, lineHeight,
            absWidth, maxWidth = 0,
            measureText = wd.geometry.Text.measureText,
            font = this._font,
            i, iLen;

        width = width || "auto";
        spaceWidth = measureText(context, " ", font).width;
        lineHeight = measureText(context, text, font).height;

        function getLines(t) {
            var wordWidth = 0, totalWidth = 0,
                complete = false, isLast,
                line = "", lines = [],
                word, words = t.split(" ");

            for (var i = 0, iLen = words.length; i < iLen; i += 1) {
                word = words[i];
                wordWidth = measureText(context, word, font).width;
                complete = false;
                isLast = i === iLen - 1;

                if (totalWidth + wordWidth - spaceWidth < width) {
                    line += word + " ";
                    totalWidth += wordWidth + spaceWidth;
                }
                else {
                    if (line.length != 0) {
                        lines.push(line.substring(0, line.length - 1));
                    }
                    line = word + " ";
                    totalWidth = wordWidth + spaceWidth;

                    if (isLast) {
                        complete = false;
                    }
                    else {
                        complete = true;
                    }
                }
            }
            if (complete == false) {
                lines.push(line.substring(0, line.length - 1));
            }
            return lines;
        }

        breaks = text.split("\n");
        if (width === "auto") {
            lines = breaks;
        }
        else {
            for (i = 0, iLen = breaks.length; i < iLen; i += 1) {
                lines = lines.concat(getLines(breaks[i]));
            }
        }

        if (width === "auto") {
            for (i = 0, iLen = lines.length; i < iLen; i += 1) {
                absWidth = context.measureText(lines[i]).width;
                maxWidth = absWidth > maxWidth ? absWidth : maxWidth;
            }
            width = maxWidth;
        }
        return new ParagraphContext(context, lines, spaceWidth, lineHeight, width);
    };


    /**
     * Strokes the paragraph using specified paragraph context.
     *
     * @function strokeParagraph(paragraphContext, x, y, lineHeight)
     * @param {paragraphContext} paragraphContext The context to which text will be drawn.
     * @param {number} x The x co-ordinate.
     * @param {number} y The y co-ordinate.
     * @param {number} lineHeight The lineHeight of the paragraph.
     *
     * @returns {webDoodling.strokeParagraph} The paragraph context, which contains information
     * for drawing paragraphs.
     *
     * @static webDoodling.ParagraphContext
     * @public
     * @version 1.0
     **/
    Paragraph.strokeParagraph = function strokeParagraph(paragraphContext, x, y, lineHeight) {
        var i, iLen, line,
            lineX = x,
            lineY = y,
            lines = paragraphContext.lines,
            lHeight = (lineHeight === undefined) ? paragraphContext.lineHeight : lineHeight,
            width = paragraphContext.width,
            ctx = paragraphContext.context,
            textAlign = ctx.textAlign;

        if (textAlign === "right") {
            lineX = lineX + width;
        }
        else if (textAlign === "center") {
            lineX = lineX + (width / 2);
        }

        for (i = 0, iLen = lines.length; i < iLen; i += 1) {
            line = lines[i];
            ctx.strokeText(line, lineX, lineY);
            lineY += lHeight;
        }
    };

    /**
     * Fills the paragraph using specified paragraph context.
     *
     * @function fillParagraph(paragraphContext, x, y, lineHeight)
     * @param {paragraphContext} paragraphContext The context to which text will be drawn.
     * @param {number} x The x co-ordinate.
     * @param {number} y The y co-ordinate.
     * @param {number} lineHeight The lineHeight of the paragraph.
     * @returns {webDoodling.fillParagraph} The paragraph context, which contains information
     * for drawing paragraphs.
     *
     * @static webDoodling.ParagraphContext
     * @public
     * @version 1.0
     **/
    Paragraph.fillParagraph = function fillParagraph(paragraphContext, x, y, lineHeight) {
        var i, iLen, line,
            lineX = x,
            lineY = y,
            lines = paragraphContext.lines,
            lHeight = (lineHeight === undefined) ? paragraphContext.lineHeight : lineHeight,
            width = paragraphContext.width,
            ctx = paragraphContext.context,
            textAlign = ctx.textAlign;

        if (textAlign == "right") {
            lineX = lineX + width;
        }
        else if (textAlign == "center") {
            lineX = lineX + (width / 2);
        }

        for (i = 0, iLen = lines.length; i < iLen; i += 1) {
            line = lines[i];
            ctx.fillText(line, lineX, lineY);
            lineY += lHeight;
        }
    };

    wd.Paragraph = Paragraph;
    wd.ParagraphContext = ParagraphContext;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The DrawingBoard DisplayObject
(function (wd, undefined) {
    "use strict";

    var DrawingBoard;

    /**
     * Represents the `webDoodling.DrawingBoard` DisplayObject which
     * can be used to draw using pure HTML5 2D drawing API.
     *
     * @class webDoodling.DrawingBoard
     *
     * @example
     * var drawingBoard = webDoodling.DrawingBoard({
     *     width: 500,
     *     height: 500
     * });
     *
     * // Get the drawing context of drawing board.
     * var drawingContext = drawingBoard.context;
     *
     * // Draw an Arc shape.
     * drawingContext.arc(250, 250, 100, 0, 90, true);
     * drawingContext.lineWidth = 10;
     * drawingContext.strokeStyle = 'red';
     * drawingContext.stroke();
     *
     * @extends webDoodling.DisplayObject
     *
     * @public
     * @version 1.0
     **/
    DrawingBoard = wd.Class({

        /**
         * Returns the `type` of `webDoodling.DrawingBoard`, always returns 'DrawingBoard'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        type: wd.type("DrawingBoard"),

        /**
         * Gets or sets the `width` of the `webDoodling.DrawingBoard`.
         *
         * @field {number} width
         * @default 0
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        width: wd.attribute(0),

        /**
         * Gets or sets the `height` of the `webDoodling.DrawingBoard`.
         *
         * @field {number} height
         * @default 0
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        height: wd.attribute(0),

        /**
         * Gets the `context` of the `webDoodling.DrawingBoard`.
         *
         * @readonly {CanvasRenderingContext2D} context
         * @default null
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        context: wd.readonly(null),

        /**
         * Initializes the new instance of `webDoodling.DrawingBoard`.
         *
         * @constructor init(o)
         * @param {type} o The initialization object.
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        init: function init(o) {
//            if (o) {
//                this.base(o);
//                this._initialize();
//            }
            this.base();
            this.serializables("width", "height");
            if (o) {
                this.deserialize(o);
                this._initialize();
            }
        },

        /**
         * Clears the drawing board canvas.
         *
         * @function clear()
         * @returns {webDoodling.DrawingBoard} The current object, useful for chaining.
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        clear: function clear() {
            this._context.clearRect(0, 0, this.width, this.height);
            return this;
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            if (this._initialized) {
                ctx.drawImage(this._canvas, x, y);
            }
        },

        /**
         * This function is invoked when the DisplayObject is attached to the
         * container `webDoodling.Scene` object.
         *
         * @function onSceneAttached(scene)
         *
         * @memberOf webDoodling.DrawingBoard
         * @protected This function should not be called directly.
         * @version 1.0
         **/
        onSceneAttached: function onSceneAttached() {
            this._initialize();
        },


        /**
         * TODO: Description remaining
         *
         * @function resize(width,height)
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        resize: function resize(width, height) {
            this.width = this._canvas.width = width;
            this.height = this._canvas.height = height;
            return this;
        },

        getBoundingBox: function getBoundingBox() {
            return {x: this.x, y: this.y, width: this.width, height: this.height};
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.DrawingBoard].
         *
         * @memberOf webDoodling.DrawingBoard
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.DrawingBoard]";
        },

        //Initializes current instance of drawingboard.
        _initialize: function () {

            if (this._initialized || this.scene === undefined) {
                return;
            }

            var scene = this.scene,
                canvas = window.document.createElement("canvas"),
                context,
                sceneWidth = (scene) ? scene._canvas.width : 0,
                sceneHeight = (scene) ? scene._canvas.height : 0;

            this._canvas = canvas;



            this.resize(this.width || sceneWidth, this.height || sceneHeight);

            context = canvas.getContext("2d");
            //document.getElementsByTagName('body')[0].appendChild(canvas);
            this._context = context;
            this._initialized = true;

        }

    }, wd.DisplayObject);

    wd.DrawingBoard = DrawingBoard;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Image DisplayObject
(function (wd, undefined) {
    "use strict";

    var Image;

    /**
     * Represents the `webDoodling.Image` display-object.
     *
     * @class webDoodling.Image
     *
     * @example
     *
     * var image = new wd.Image({
     *     x: 150,
     *     y: 300,
     *     source: url('image name')
     * });
     *
     * @extends webDoodling.DisplayObject
     *
     * @public
     * @version 1.0
     **/
    Image = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Image`, always returns 'Image'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        type: wd.type("Image"),

        /**
         * Gets the `mediaHeight` of the `webDoodling.Image` which is the original height of a Image.
         * If it is `undefined` means image not yet loaded.
         *
         * @readonly {number} mediaHeight
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        mediaHeight: wd.readonly(),

        /**
         * Gets the `mediaWidth` of the `webDoodling.Image` which is the original width of a Image.
         * If it is `undefined` means image not yet loaded.
         *
         * @readonly {number} mediaWidth
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        mediaWidth: wd.readonly(),

        /**
         * Gets or sets the `width` of the `webDoodling.Image`. If not set, the value is automatically
         * calculated after image is loaded.
         *
         * @field {number} width
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        width: wd.attribute(),

        /**
         * Gets or sets the `height` of the `webDoodling.Image`. If not set, the value is automatically
         * calculated after image is loaded.
         *
         * @field {number} height
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        height: wd.attribute(),

        /**
         * Gets or sets the `sourceX` of the `webDoodling.Image`.
         *
         * @field {number} sourceX
         * @default 0
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        offsetX: wd.attribute(0),

        /**
         * Gets or sets the `sourceY` of the `webDoodling.Image`.
         *
         * @field {number} sourceY
         * @default 0
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        offsetY: wd.attribute(0),

        /**
         * Gets or sets the `width` of the `webDoodling.Image`. If not set, the value is automatically
         * calculated after image is loaded.
         *
         * @field {number} width
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        offsetWidth: wd.attribute(),

        /**
         * Gets or sets the `height` of the `webDoodling.Image`. If not set, the value is automatically
         * calculated after image is loaded.
         *
         * @field {number} height
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        offsetHeight: wd.attribute(),

        /**
         * Gets or sets the `source` of the `webDoodling.Image`.
         *
         * @field {string, HTMLCanvasElement, webDoodling.ImageAsset, webDoodling.ImageSource} source
         * @default null
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        source: wd.imageSource(),

        /**
         * Represents the filters for current image.
         *
         * @field {webDoodling.ImageFilterCollection} filters
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        filters: wd.readonly(),

        /**
         * Represents the `smoothingEnabled` attribute of `webDoodling.Image` which
         * defines whether image needs to be smoothed (default true) or not (false).
         *
         * @field {boolean} smoothingEnabled
         * @default true
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        smoothingEnabled: wd.attribute(true),

        /**
         * Initializes the new instance of `webDoodling.Image`.
         *
         * @constructor init(o)
         * @param  {type} o The initialization object.
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            var self = this;
                //scene = this.scene;
            this._filters = new wd.FilterCollection(this);
            this.filters.onUpdate = function (image) {
                self._sourceMedia = image;
                self._updateScene();
            };

            this.base();
            this._tweenables.register("number", "width", "height", "offsetWidth", "offsetHeight", "offsetX", "offsetY");
            this.serializables("width", "height", "offsetX", "offsetY", "offsetWidth", "offsetHeight", "smoothingEnabled", "filters",
                {
                    key: "source",
                    value: function () {
                        return this._sourceSrc;
                    }
                });
            if (o) this.deserialize(o);
            //this.filters.apply();
        },

       //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            var w = this.width,
                h = this.height,
                oW = this.offsetWidth,
                oH = this.offsetHeight,
                oX = this.offsetX,
                oY = this.offsetY,
                smoothingEnabled = this.smoothingEnabled;

            if (this._sourceIsReady) {
                if (!smoothingEnabled) {
                    if (ctx.imageSmoothingEnabled === undefined) {
                        ctx.oImageSmoothingEnabled = false;
                        ctx.mozImageSmoothingEnabled = false;
                        ctx.msImageSmoothingEnabled = false;
                        ctx.webkitImageSmoothingEnabled = false;
                    }
                    else {
                        ctx.imageSmoothingEnabled = false;
                    }
                }
                ctx.drawImage(this._sourceMedia, oX, oY, oW, oH, x, y, w, h);
            }
        },

        getBoundingBox: function getBoundingBox() {
            return {x: this.x, y: this.y, width: this.width, height: this.height};
        },

        /**
         * Gets invoked when touch region need to be painted.
         *
         * @function onDrawHitRegion(ctx, x, y, color)
         * @param {2DContext} ctx The drawing context.
         * @param {Object} x The calculated x position of `webDoodling.Image`.
         * @param {Object} y The calculated y position of `webDoodling.Image`.
         *
         * @memberOf webDoodling.Image
         * @protected
         * @version 1.0
         **/
        onDrawHitRegion: function onDrawHitRegion(ctx, x, y, color) {
            var r = x + this.width,
                b = y + this.height;

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(r, y);
            ctx.lineTo(r, b);
            ctx.lineTo(x, b);
            ctx.closePath();

            ctx.fillStyle = color;
            ctx.fill();
        },

        onSceneAttached: function onSceneAttached() {
            this._updateFilters();
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Image].
         *
         * @memberOf webDoodling.Image
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Image]";
        },

          // Private

          // Invoked when source is ready.
        _sourceOnReady: function() {
            if (this.width === undefined) {
                //this.width = this._sourceWidth - this.sourceX;
                this.width = this._sourceWidth - this.offsetX;
            }

            if (this.height === undefined) {
                //this.height = this._sourceHeight - this.sourceY;
                this.height = this._sourceHeight - this.offsetY;
            }

            if (this.offsetWidth === undefined) {
                this.offsetWidth = this.width;
            }

            if (this.offsetHeight === undefined) {
                this.offsetHeight = this.height;
            }

            this.filters.source = this._sourceMedia;

            if (this.source instanceof wd.ImageSource) {
                this.source.onUpdate = this._imageSourceUpdated;
            }

            this._updateFilters();
            this._updateScene();
        },

        _updateScene: function () {
            if (this.scene) {
                this.scene.update();
            }
        },

        _updateFilters: function() {
            if (this._sourceIsReady && this.scene !== undefined && this.filters.length > 0) {
                this.filters.apply();
            }
        },

        _imageSourceUpdated: function () {
            this.filters.source = this._sourceMedia;
            this._updateFilters();
            this._updateScene();
        }

    }, wd.DisplayObject);

    wd.Image = Image;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Sprite DisplayObject
(function (wd, undefined) {
    "use strict";

    var Frameset, FramesetCollection, Sprite;

    /**
     * Represents `webDoodling.Frameset` which manages frames information required by
     * `webDoodling.Sprite` object.
     *
     * @class webDoodling.Frameset
     * @extends webDoodling.DisplayObject
     *
     * @public
     * @version 1.0
     **/
    Frameset = wd.Class({

        /**
        * Returns the `type` of `webDoodling.Frameset`, always returns 'Frameset'.
        *
        * @field {string} type
        *
        * @memberOf webDoodling.Frameset
        * @public
        * @version 1.0
        **/
        type: wd.type("Frameset"),

        /**
         * Represents the id of `webDoodling.Frameset`.
         *
         * @field {string} id
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        id: wd.attribute(),

        /**
         * The x coordinate of frameset's start position.
         *
         * @field {number} x
         * @default 0
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * The y coordinate of frameset's start position.
         *
         * @field {number} y
         * @default 0
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * The number of columns in which sprite has been spread.
         *
         * @field {number} columns
         * @default 1
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version
         **/
        columns: wd.attribute(1),

        /**
         * The number of rows in which sprite has been spread.
         *
         * @field {number} rows
         * @default 1
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version
         **/
        rows: wd.attribute(1),

        /**
         * Gets or sets whether sprite frames be iterated over columns first or row.
         * If `true` iterates over columns first.
         * TODO: Give example here.
         *
         * @field {boolean} columnFirst
         * @default true
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version
         **/
        columnFirst: wd.attribute(true),

        /**
         * The total number of frames in frameset.
         *
         * @field {number} length
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        length: wd.attribute(),

        /**
         * Gets the current frame index within frameset.
         *
         * @readonly {number} index
         * @default 0
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        index: wd.readonly(0),

        /**
         * The paddingX in frameset.
         *
         * @field {number} paddingX
         * @default 0
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        paddingX: wd.attribute(0),

        /**
         * The paddingY in frameset.
         *
         * @field {number} paddingY
         * @default 0
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        paddingY: wd.attribute(0),

        /**
         * Returns an object which contains following members required for
         * drawing image at current index.       *
         * - x {number} The x position.
         * - y {number} The y position.
         * - width {width} The width.
         * - height {height} The height.
         *
         * @readonly {object} position
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         */
        position: wd.readonly({
            get: function () {
                return this._positions[this._index];
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.Frameset`.
         *
         * @constructor init(o)
         * @param {object} o The initialization object in JSON format.
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         */
        init: function init(o) {
            this.base();
            this._positions = [];
            this._index = 0;
            this.serializables("id", "x", "y", "columns", "rows", "columnFirst",
                               "length", "paddingX", "paddingY");

            if (o) {
                this.deserialize(o);
            }
            if (!this.length) {
                this.length = this.columns * this.rows;
            }
        },

        /**
         * Regenerates the frames, this method is called by sprite object when
         * its height or width is changed.
         *
         * @function update(width, height)
         * @param  {number} width The frame width.
         * @param  {number} height The frame height.
         * @returns {webDoodling.Frameset} The current object, useful for chaining.
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         */
        update: function update(width, height) {
            var col,
                cols = this.columns,
                row,
                rows = this.rows,
                positions = this._positions,
                x = this.x,
                y = this.y,
                framesetLength = this.length,
                count = 1,
                doBreak = false,
                paddingX = this.paddingX,
                paddingY = this.paddingY;

            positions.length = 0;

            if (this.columnFirst) {
                for(row=0; row < rows && doBreak === false; row++) {
                    for(col=0; col < cols; col++) {
                        positions.push({
                            x: x + ((width + paddingX) * col),
                            y: y + ((height + paddingY) * row),
                            width: width,
                            height: height
                        });
                        count += 1;
                        if (count > framesetLength) {
                            doBreak = true;
                            break;
                        }
                    }
                }
            }
            else {
                for(col=0; col < cols; col++) {
                    for(row=0; row < rows && doBreak === false; row++) {
                        positions.push({
                            x: x + ((width + paddingX) * col),
                            y: y + ((height + paddingY) * row),
                            width: width,
                            height: height
                        });
                        count += 1;
                        if (count > framesetLength) {
                            doBreak = true;
                            break;
                        }
                    }
                }
            }
            return this;
        },

        /**
         * Sets the current index to next.
         *
         * @function next()
         * @returns {webDoodling.Frameset} The current object, useful for chaining.
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        next: function next() {
            this._index =  (this._index + 1) % this.length;
            return this;
        },

        /**
         * Reset the current index to zero.
         *
         * @function reset()
         * @returns {webDoodling.Frameset} The current object, useful for chaining.
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         */
        reset: function reset() {
            this._index = 0;
            return this;
        },

        /**
         * Returns the string representation of  current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Frameset].
         *
         * @memberOf webDoodling.Frameset
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Frameset]";
        }

    }, wd.Serializable);

    wd.Frameset = Frameset;

    // TODO:Need to add description
    /**
     *
     * @class webDoodling.FramesetCollection
     * @extends webDoodling.ObservableMapList
     *
     * @public
     * @version 1.0
     **/
    FramesetCollection = wd.Class({

        /**
         * Returns the `type` of `webDoodling.FramesetCollection`, always returns 'FramesetCollection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.FramesetCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("FramesetCollection"),

        /**
         * Updates the frames in all associated frameset.
         *
         * @function update(width, height)
         * @param  {number} width The sprite width.
         * @param  {number} height The sprite height.
         * @returns {webDoodling.FramesetCollection} The current object, useful for chaining.
         *
         * @memberOf webDoodling.FramesetCollection
         * @public
         * @version 1.0
         **/
        update: function update(width, height) {
            this.each(function(frameset){
                frameset.update(width, height);
            });
            return this;
        },

        /**
         * Gets invoked when an object is required to be validated before it
         * is pushed into the collection.
         *
         * @function onValidate(obj)
         * @params TODO:
         *
         * @memberOf webDoodling.FramesetCollection
         * @protected
         * @version 1.0
         **/
        onValidate: function onValidate(obj) {
            if (obj instanceof wd.Frameset === false) {
                throw new wd.Error("wd-invalid-argument", obj);
            }
            return null;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.FramesetCollection].
         *
         * @memberOf webDoodling.FramesetCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.FramesetCollection]";
        }

    }, wd.Collection);

    wd.FramesetCollection = FramesetCollection;

    /**
     * Represents the `webDoodling.Sprite` DisplayObject
     *
     * @class webDoodling.Sprite
     *
     * @example
     * var sprite = webDoodling.Sprite({
     *      x:50,
     *      y:50,
     *      width: 39,
     *      height: 39,
     *      source: '..',
     *      frames:[
     *          webDoodling.frameset({
     *              y: 50,
     *              x: 6,
     *              columns: 4,
     *              rows: 1,
     *              length: 4,
     *          })
     *     ]
     * });
     *
     * @extends webDoodling.DisplayObject
     *
     * @public
     * @version 1.0
     **/
    Sprite = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Sprite`, always returns 'Sprite'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        type: wd.type("Sprite"),

        /**
         * Gets or sets the `width` of the `webDoodling.Sprite`.
         *
         * @field {number} width
         * @default 0
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        width: wd.property({
            value: 0,
            get: function () {
                return this._width;
            },
            set: function (v) {
                if (this._width !== v) {
                    this._width = v;
                    this._frames.update(this._width, this._height);
                }
            }
        }),

        /**
         * Gets or sets the `height` of the `webDoodling.Sprite`.
         *
         * @field {number} height
         * @default 0
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        height: wd.property({
            value: 0,
            get: function () {
                return this._height;
            },
            set: function (v) {
                if (this._height !== v) {
                    this._height = v;
                    this._frames.update(this._width, this._height);
                }
            }
        }),

        /**
         * Gets or sets the `source` of the `webDoodling.Sprite`.
         *
         * @field {string, HTMLCanvasElement, webDoodling.ImageAsset, webDoodling.ImageSource} source
         * @default null
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        source: wd.imageSource(),

        /**
         * Returns the underlaying frames collection object.
         *
         * @readonly {webDoodling.FramesCollection} frames
         *
         * @memberOf webDoodling.Sprite
         * @pulbic
         * @version 1.0
         **/
        frames: wd.readonly(),

        /**
         * The field `autoPlay` can be set during object initialization. If it is set to `true`
         *
         * @field {boolean} autoPlay
         * @default true
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        autoPlay: wd.attribute(true),

        /**
         * Returns `true` is sprite is currently being played otherwise `false`.
         *
         * @readonly {Boolean} isPlaying
         * @default true
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        isPlaying: wd.readonly(true),

        /**
         * Gets or sets the `deceleration` of the `webDoodling.Sprite`. Represent
         * the deceleration rate. If it is 2 sprite frame it will be changed on every 2
         * animation frame, if it is 3 it will be changed on every 3 animation frame.
         *
         * @field {number} deceleration
         * @default 1
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        deceleration: wd.attribute(1),

        /**
         * Represents the `smoothingEnabled` attribute of `webDoodling.Sprite` which
         * defines whether image needs to be smoothed (default true) or not (false).
         *
         * @field {boolean} smoothingEnabled
         * @default true
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        smoothingEnabled: wd.attribute(true),

        /**
         * Gets or sets the id or index of current frameset.
         *
         * @field {string, number} current
         * @default 0
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        current: wd.property({
            value: 0,
            get: function () {
                return this._current;
            },
            set: function (v) {
                var fs;
                if (this._current !== v) {
                    fs = this._frames.get(this._current || 0);
                    if (fs) {
                        fs.reset();
                    }
                    this._current = v;
                }
            }
        }),

        /**
         * Initializes the new instance of `webDoodling.Sprite`.
         *
         * @constructor init(o)
         * @param {object} o The initialization options in JSON format.
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._frames = new wd.FramesetCollection();

            if (o) this.deserialize(o);

            this._frames.update(this._width, this._height);
            this._isPlaying = this.autoPlay;

            this.serializables("width", "height", "deceleration", "frames",
                {
                    key: "source",
                    value: function () {
                        return this._sourceSrc;
                    }
                });
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            var fs = this._frames.get(this.current || 0),
                w = this.width,
                h = this.height,
                pos = fs.position,
                sx = pos.x,
                sy = pos.y,
                smoothingEnabled = this.smoothingEnabled;

            if (this._sourceIsReady) {
                if (!smoothingEnabled) {
                    if (ctx.imageSmoothingEnabled === undefined) {
                        ctx.oImageSmoothingEnabled = false;
                        ctx.mozImageSmoothingEnabled = false;
                        ctx.msImageSmoothingEnabled = false;
                        ctx.webkitImageSmoothingEnabled = false;
                    }
                    else {
                        ctx.imageSmoothingEnabled = false;
                    }
                }
                ctx.drawImage(this._sourceMedia, sx, sy, w, h, x, y, w, h);
            }
        },

        /**
         * Plays the sprite animation if it is not currently paused.
         *
         * @function play()
         * @returns {webDoodling.Sprite} Current object useful for chaining.
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        play: function play() {
            this._isPlaying = true;
            return this;
        },

        /**
         * Pauses the sprite animation, which can be resumed by `play` method.
         *
         * @function pause()
         * @returns {webDoodling.Sprite} Current object useful for chaining.
         *
         * @memberOf webDoodling.Sprite
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            this._isPlaying = false;
            return this;
        },

        /**
         * Invoked when scene is attached to current display object.
         *
         * @function onSceneAttached()
         *
         * @memberOf webDoodling.Sprite
         * @protected
         * @version 1.0
         **/
        onSceneAttached: function onSceneAttached() {
            var scene = this.scene,
                self = this,
                deceleration = this.deceleration,
                counter = 0;

            scene.animationLoop(function spriteLoop () {
                counter += 1;
                if (self._isPlaying === false || counter % deceleration !== 0) {
                    return;
                }
                var frames = self._frames,
                    frameset;
                if (frames.length > 0) {
                    frameset = self._frames.get(self.current || 0);
                    frameset.next();
                }
                scene.update();
            });
        },

        getBoundingBox: function getBoundingBox() {
            return {x: this.x, y: this.y, width: this.width, height: this.height};
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Sprite].
         *
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Sprite]";
        },

        _sourceOnReady: function () {
            if (this.scene) {
                this.scene.update();
            }
        }

    }, wd.DisplayObject);

    wd.Sprite = Sprite;

})(window.webDoodling);

// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Tile DisplayObject
(function (wd, undefined) {
    "use strict";

    var Tile;

    /**
     * Represents the `webDoodling.Tile` display-object.
     *
     * @class webDoodling.Tile
     *
     * @example
     * var tile = webDoodling.Tile({
     *     x: 50,
     *     y: 50,
     *     width: 600,
     *     height: 250,
     *     source: '...',
     *     styles:[
     *         webDoodling.Stroke('red', 2)
     *     ]
     * });
     *
     * @extends webDoodling.DisplayObject
     *
     * @public
     * @version 1.0
     **/
    Tile = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Tile`, always returns 'Tile'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        type: wd.type("Tile"),

        /**
         * Gets the `mediaHeight` of the `webDoodling.Tile`,which is the original height of the Tile.
         * If it is an `undefined` means image not yet loaded.
         *
         * @readonly {number} mediaHeight
         * @default 0
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        mediaHeight: wd.readonly(0),

        /**
         * Gets the `mediaWidth` of the `webDoodling.Tile`, which is the original width of the Tile.
         * If it is  an `undefined` means image not yet loaded.
         *
         * @readonly {number} mediaWidth
         * @default 0
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        mediaWidth: wd.readonly(0),

        /**
         * Gets or sets the `width` of the `webDoodling.Tile`. If not set,
         * the width is automatically calculated after the image is loaded.
         *
         * @field {number} width
         * @default 0
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        width: wd.attribute(),

        /**
         * Gets or sets the `height` of the `webDoodling.Tile`. If not set,
         * the height is automatically calculated after the image is loaded.
         *
         * @field {number} height
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        height: wd.attribute(),

        /**
         * Gets or sets the `offsetX` of the `webDoodling.Tile`.
         *
         * @field {number} offsetX
         * @default 0
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        offsetX: wd.attribute(0),

        /**
         * Gets or sets the `offsetY` of the `webDoodling.Tile`.
         *
         * @field {number} offsetY
         * @default 0
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        offsetY: wd.attribute(0),

        /**
         * Gets or sets the `paddingX` of the `webDoodling.Tile`.
         *
         * @field {number} paddingX
         * @default 0
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        paddingX: wd.attribute(0),

        /**
         * Gets or sets the `paddingY` of the `webDoodling.Tile`.
         *
         * @field {number} paddingY
         * @default 0
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        paddingY: wd.attribute(0),

        /**
         * Gets or sets the `source` of the `webDoodling.Tile`.
         * @field {string, HTMLCanvasElement, webDoodling.ImageAsset, webDoodling.ImageSource} source
         *
         * @default null
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        source: wd.imageSource(),

         /**
         * Represents the `smoothingEnabled` attribute of `webDoodling.Tile` which
         * defines whether image needs to be smoothed (default true) or not (false).
         *
         * @field {boolean} smoothingEnabled
         * @default true
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        smoothingEnabled: wd.attribute(true),

        /**
         * Initializes the new instance of `webDoodling.Tile`.
         *
         * @constructor init(o)
         * @param  {type} o The initialization object in JSON format.
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "width", "height", "offsetX", "offsetY");
            this.serializables("width", "height", "offsetX", "offsetY", "paddingX", "paddingY",
                {
                    key: "source",
                    value: function () {
                        return this._sourceSrc;
                    }
                });
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            var offsetX, offsetY,
                smoothingEnabled = this.smoothingEnabled;

            if (this._dirty === true) {
                this._updatePatterns(ctx);
            }
            if (!smoothingEnabled) {
                if (ctx.imageSmoothingEnabled === undefined) {
                    ctx.oImageSmoothingEnabled = false;
                    ctx.mozImageSmoothingEnabled = false;
                    ctx.msImageSmoothingEnabled = false;
                    ctx.webkitImageSmoothingEnabled = false;
                }
                else {
                    ctx.imageSmoothingEnabled = false;
                }
            }
            offsetX = this.offsetX;
            offsetY = this.offsetY;
            ctx.translate(offsetX, offsetY);
            ctx.fillStyle = this._pattern;
            ctx.fillRect(x - offsetX, y - offsetY, this.width, this.height);
        },

        /**
         * Gets invoked when touch region need to be painted.
         *
         * @function onDrawHitRegion(ctx, x, y, color)
         * @param {2DContext} ctx The drawing context.
         * @param {Object} x The calculated x position of `webDoodling.Tile`.
         * @param {Object} y The calculated y position of `webDoodling.Tile`.
         *
         * @memberOf webDoodling.Tile
         * @protected
         * @version 1.0
         **/
        onDrawHitRegion: function onDrawHitRegion(ctx, x, y, color) {
            var r = x + this.width,
                b = y + this.height;

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(r, y);
            ctx.lineTo(r, b);
            ctx.lineTo(x, b);
            ctx.closePath();

            ctx.fillStyle = color;
            ctx.fill();
        },

        getBoundingBox: function getBoundingBox() {
            return {x: this.x, y: this.y, width: this.width, height: this.height};
        },

         /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Tile].
         *
         * @memberOf webDoodling.Tile
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Tile]";
        },

        _sourceOnReady: function () {
            var context;
            this._canvas = document.createElement("canvas");
            context = this._canvas.getContext("2d");
            if (this.width === undefined) {
                this.width = this._sourceWidth;
            }

            if (this.paddingX < 0) {
                this.paddingX = 0;
            }
            this._canvas.width = this._sourceWidth + this.paddingX;
            if (this.height === undefined) {
                this.height = this._sourceHeight;
            }
            if (this.paddingY < 0) {
                this.paddingY = 0;
            }
            this._canvas.height = this._sourceHeight + this.paddingY;
            context.drawImage(this._sourceMedia, 0, 0);
            this._dirty = true;
            if (this.scene) {
                this.scene.update();
            }
        },

        _updatePatterns: function (ctx) {
            this._pattern = ctx.createPattern(this._canvas, "repeat");
            this._dirty = false;
        }

    }, wd.DisplayObject);

    wd.Tile = Tile;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Arc DisplayObject
(function (wd) {
    "use strict";

    var Arc;

    /**
     * Represents the `webDoodling.Arc` DisplayObject, which has got the shape
     * of an arc.
     *
     * @class webDoodling.Arc
     *
     * @example
     * var arc = webDoodling.Arc({
     *     x: 100,
     *     y: 100,
     *     radius: 50,
     *     startAngle: 45,
     *     endAngle: 95,
     *     styles: [
     *         webDoodling.Stroke('red', 5)
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Arc = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Arc`, always returns 'Arc'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Arc
         * @public
         * @version 1.0
         **/
        type: wd.type("Arc"),

        /**
         * Gets or sets the `radius` of the `webDoodling.Arc`.
         *
         * @field  {number} radius
         * @default 0
         *
         * @memberOf webDoodling.Arc
         * @public
         * @version 1.0
         **/
        radius: wd.attribute(0),

        /**
         * Gets or sets the `startAngle` of the `webDoodling.Arc`.
         *
         * @field {number} startAngle
         * @default 0
         *
         * @memberOf webDoodling.Arc
         * @public
         * @version 1.0
         **/
        startAngle: wd.attribute(0),

        /**
         * Gets or sets the `endAngle` of the `webDoodling.Arc`.
         *
         * @field {number} endAngle
         * @default 0
         *
         * @memberOf webDoodling.Arc
         * @public
         * @version 1.0
         **/
        endAngle: wd.attribute(0),

        /**
         * Gets or sets whether the object needs to be drawn clockwise or anticlockwise.
         * If true, it is drawn anticlockwise otherwise clockwise.
         *
         * @field {boolean} anticlockwise
         * @default false
         *
         * @memberOf webDoodling.Arc
         * @public
         * @version 1.0
         **/
        anticlockwise: wd.property(false),

        /**
         * Initializes the new instance of `webDoodling.Arc`.
         *
         * @constructor init(o)
         * @param  {type} o The initialization object.
         *
         * @memberOf webDoodling.Arc
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "radius", "startAngle", "endAngle");
            this.serializables("radius", "startAngle", "endAngle", "anticlockwise");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            var radius = this.radius,
                startAngle = this.startAngle * Math.PI / 180,
                endAngle = this.endAngle * Math.PI / 180,
                anticlockwise = this.anticlockwise;

            //ctx.lineCap = this.lineCap;
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);

        },

        getBoundingBox: function getBoundingBox() {
            var box = wd.geometry.Arc.getBoundingBox(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
            return box;
        },

       /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Arc].
         *
         * @memberOf webDoodling.Arc
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Arc]";
        }


    }, wd.StyleableDisplayObject);

    wd.Arc = Arc;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Pie DisplayObject
(function (wd) {
    "use strict";

    var Pie;

    /**
     * Represents the `webDoodling.Pie` DisplayObject, which has got the shape
     * of pie.
     *
     * @class webDoodling.Pie
     *
     * @expamle
     * var pie = webDoodling.Pie({
     *     x: 350,
     *     y: 175,
     *     startAngle: 0,
     *     endAngle:45,
     *     radius:100,
     *     styles:[
     *      new webDoodling.Fill('green')
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Pie = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Pie`, always returns 'Pie'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Pie
         * @public
         * @version 1.0
         **/
        type: wd.type("Pie"),

        /**
         * Gets or sets the `radius` of the `webDoodling.Pie`.
         *
         * @field  {number} radius
         * @default 0
         *
         * @memberOf webDoodling.Pie
         * @public
         * @version 1.0
         **/
        radius: wd.attribute(0),

        /**
         * Gets or sets the `startAngle` of the `webDoodling.Pie`.
         *
         * @field {number} startAngle
         * @default 0
         *
         * @memberOf webDoodling.Pie
         * @public
         * @version 1.0
         **/
        startAngle: wd.attribute(0),

        /**
         * Gets or sets the `endAngle` of the `webDoodling.Pie`.
         *
         * @field {number} endAngle
         * @default 0
         *
         * @memberOf webDoodling.Pie
         * @public
         * @version 1.0
         **/
        endAngle: wd.attribute(0),

        /**
         * TODO: Correct the description
         * Gets or sets whether the object needs to be drawn clockwise or anticlockwise.
         * If true, it is drawn anticlockwise otherwise clockwise.
         *
         * @field {boolean} anticlockwise
         * @default false
         *
         * @memberOf webDoodling.Pie
         * @public
         * @version 1.0
         **/
        anticlockwise: wd.property(false),

        /**
         * Initializes the new instance of `webDoodling.Paragraph`.
         *
         * @constructor init(o)
         * @param {object} o The initialization options in JSON format.
         *
         * @memberOf webDoodling.Pie
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "radius", "startAngle", "endAngle");
            this.serializables("radius", "startAngle", "endAngle", "anticlockwise");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;

            _drawPie(ctx, x, y, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
        },

        getBoundingBox: function getBoundingBox() {
            var box = wd.geometry.Pie.getBoundingBox(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
            return box;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Pie].
         *
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Pie]";
        }


    }, wd.StyleableDisplayObject);

    wd.Pie = Pie;

    function _drawPie(ctx, x, y, radius, startAngle, endAngle, anticlockwise) {
        startAngle = startAngle * Math.PI / 180;
        endAngle = endAngle * Math.PI / 180;
        anticlockwise = anticlockwise === true;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
        ctx.closePath();
    }

    /**
     * Draws the pie shape on given context.
     *
     * @function drawPie(ctx, x, y, radius, sides, startAngle[, anticlockwise])
     * @param  {CanvasRenderingContext2D} ctx The context on which pie is to be drawn.
     * @param  {number} x The x position of pie.
     * @param  {number} y The y position of pie.
     * @param  {number} radius The radius of pie.
     * @param  {number} sides The number of sides in pie.
     * @param  {number} startAngle The start angle of pie.
     * @param  {boolean} anticlockwise (optional)
     *
     * @static webDoodling.Pie
     * @public
     * @version 1.0
     **/
    wd.Pie.drawPie = _drawPie;


})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Circle DisplayObject
(function (wd) {
    "use strict";

    var Circle;

    /**
     * Represents the `webDoodling.Circle` DispalyObject which can be used to
     * create a circle on the `webDoodling.Scene`.
     *
     * @class webDoodling.Circle
     *
     * @example
     * var circle = webDoodling.Circle({
     *     x: 100,
     *     y: 100,
     *     radius: 40,
     *     styles:[
     *         new webDoodling.Fill('green')
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Circle = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Circle`, always returns 'Circle'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Circle
         * @public
         * @version 1.0
         **/
        type: wd.type("Circle"),

        /**
         * Gets or sets the `radius` of the `webDoodling.Circle`.
         *
         * @field {number} radius
         * @default 10
         *
         * @memberOf webDoodling.Circle
         * @public
         * @version 1.0
         **/
        radius: wd.attribute(10),

        /**
         * Initializes the new instance of `webDoodling.Circle`.
         *
         * @constructor init(o)
         * @param  {type} o The initialization object in JSON format.
         *
         * @memberOf webDoodling.Circle
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "radius");
            this.serializables("radius");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            ctx.beginPath();
            ctx.arc(x, y, this.radius, 0, 2 * Math.PI, false);
            ctx.closePath();
        },

        getBoundingBox: function getBoundingBox() {
            var box = wd.geometry.Circle.getBoundingBox(this.x, this.y, this.radius);
            return box;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Circle].
         *
         * @memberOf webDoodling.Circle
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Circle]";
        }

    }, wd.StyleableDisplayObject);

    wd.Circle = Circle;

    /**
     * Draws a circle path on a given context.
     *
     * @function drawCircle(context, x, y, radius)
     * @param {2DContext} context The 2dContext.
     * @param {number} x The x coordinate.
     * @param {number} y The y coordinate.
     * @param {number} radius The circle radius.
     *
     * @static webDoodling.Circle
     * @public
     * @version 1.0
     **/
    wd.Circle.drawCircle = function drawCircle(context, x, y, radius) {
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, radius, 0, 2 * Math.PI, false);
        context.closePath();
    };

    //wd.TypeRegistry.register('rectangle', wd.Rectangle);

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Ellipse DisplayObject
(function (wd) {
    "use strict";

    var Ellipse;

    /**
     * Represents the `webDoodling.Ellipse` DispalyObject, which has got the shape
     * of an ellipse.
     *
     * @class webDoodling.Ellipse
     *
     * @example
     * var ellipse = webDoodling.Ellipse({
     *     x:200,
     *     y:200,
     *     width:200,
     *     height:100,
     *     styles:[
     *         new dooling.stroke('green',20),
     *         new dooling.fill('yellow')
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Ellipse = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Ellipse`, always returns 'Ellipse'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Ellipse
         * @public
         * @version 1.0
         **/
        type: wd.type("Ellipse"),

        /**
         * Gets or sets the `width` of the `webDoodling.Ellipse`.
         *
         * @field {number} width
         * @default 0
         *
         * @memberOf webDoodling.Ellipse
         * @public
         * @version 1.0
         **/
        width: wd.attribute(0),

        /**
         * Gets or sets the `height` of the `webDoodling.Ellipse`.
         *
         * @field {number} height
         * @default 0
         *
         * @memberOf webDoodling.Ellipse
         * @public
         * @version 1.0
         **/
        height: wd.attribute(0),

        /**
         * Initializes the new instance of `webDoodling.Ellipse`.
         *
         * @constructor init(o)
         * @param {type} o The initialization object.
         *
         * @memberOf webDoodling.Ellipse
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "width", "height");
            this.serializables("width", "height");
            if (o) this.deserialize(o);
        },


       //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            _drawEllipse(ctx, x, y, this.width, this.height);
        },

        getBoundingBox: function getBoundingBox() {
            return {x: this.x, y: this.y, width: this.width, height: this.height};
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Ellipse].
         *
         * @memberOf webDoodling.Ellipse
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Ellipse]";
        }

    }, wd.StyleableDisplayObject);

    wd.Ellipse = Ellipse;

     //Reference: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-scene
    // Thank you very much Steve Tranby
    function _drawEllipse(ctx, x, y, width, height) {
        var w = width,
            h = height;

        var kappa = 0.5522848,
            ox = (w / 2) * kappa, // control point offset horizontal
            oy = (h / 2) * kappa, // control point offset vertical
            xe = x + w, // x-end
            ye = y + h, // y-end
            xm = x + w / 2, // x-middle
            ym = y + h / 2;       // y-middle

        ctx.beginPath();
        ctx.moveTo(x, ym);
        ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        ctx.closePath();
    }

    /**
     * Draws an `Ellipse` shape on given context.
     *
     * @function drawEllipse(ctx, x, y, width, height)
     * @param  {2dContext} ctx The context on which ellipse should be drawn.
     * @param  {number} x The x position of the ellipse.
     * @param  {number} y The y poisition of the ellipse.
     * @param  {number} width The width of the ellipse.
     * @param  {number} height The height of the ellipse.
     * @remark This function begins and closes path.
     *
     * @static webDoodling.Ellipse
     * @public
     * @version 1.0
     **/
    wd.Ellipse.drawEllipse = _drawEllipse;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Polygon DisplayObject
(function (wd) {
    "use strict";

    var Polygon;

    /**
     * Represents the `webDoodling.Polygon` DisplayObject.
     *
     * @class webDoodling.Polygon
     *
     * @example
     * var polygon = webDoodling.Polygon({
     *     x: 200,
     *     y: 200,
     *     sides: 6,
     *     raduis: 100,
     *     styles:[
     *         webDoodling.Stroke('red', 10),
     *         webDoodling.Fill('blue')
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     * @public
     * @version 1.0
     **/
    Polygon = wd.Class({

        /**
         * Returns the type of `webDoodling.Polygon`, always returns 'Polygon'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Polygon
         * @public
         * @version 1.0
         **/
        type: wd.type("Polygon"),

        /**
         * Gets or sets the `sides` of the `webDoodling.Polygon`.
         *
         * @field {number} sides
         * @default 3
         *
         * @memberOf webDoodling.Polygon
         * @public
         * @version 1.0
         **/
        sides: wd.attribute(3),

        /**
         * Gets or sets the `radius` of the `webDoodling.Polygon`.
         *
         * @field {number} radius
         * @default 50
         *
         * @memberOf webDoodling.Polygon
         * @public
         * @version 1.0
         **/
        radius: wd.attribute(50),

        /**
         * Gets or sets the `startAngle` of the `webDoodling.Polygon`.
         *
         * @field {number} startAngle
         * @default 0
         *
         * @memberOf webDoodling.Polygon
         * @public
         * @version 1.0
         **/
        startAngle: wd.attribute(0),

         /**
          * Initializes the new instance of `webDoodling.Polygon`.
          *
          * @constructor init(o)
          * @param {object} o The initialization options in JSON format.
          *
          * @memberOf webDoodling.Polygon
          * @public
          * @version 1.0
          **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "radius", "startAngle", "sides");
            this.serializables("radius", "sides", "startAngle");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;
            _drawPolygon(ctx, x, y, this.radius, this.sides, this.startAngle);
        },

        getBoundingBox: function getBoundingBox() {
            var box = wd.geometry.Polygon.getBoundingBox(this.x, this.y, this.radius, this.sides);
            return box;
        },

         /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Polygon].
         *
         * @memberOf webDoodling.Polygon
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Polygon]";
        }

    }, wd.StyleableDisplayObject);

    wd.Polygon = Polygon;

    function _drawPolygon(ctx, x, y, radius, sides, startAngle) {

        radius = radius || 50;
        sides = Math.round(sides) || 3;
        startAngle = startAngle || 0;

        var delta_theta = 2.0 * Math.PI / sides,
            theta = 0,
            points = [];

        ctx.beginPath();

        for (var i = 0; i < sides; i++) {

            var x2 = (radius * Math.cos(theta));
            var y2 = (radius * Math.sin(theta));

            var offsetX = x + x2;
            var offsetY = y + y2;
            points.push([offsetX, offsetY]);
            theta += delta_theta;
        }

        for (var idx = 0, idxLen = points.length; idx < idxLen; idx++) {
            if (idx === 0) {
                ctx.moveTo(points[idx][0], points[idx][1]);
            }
            else {
                ctx.lineTo(points[idx][0], points[idx][1]);
            }
        }
        ctx.closePath();
    }

    /**
     * Draws the polygon shape on given context.
     *
     * @function drawPolygon(ctx, x, y, radius, sides, startAngle)
     * @param  {CanvasRenderingContext2D} ctx The context on which polygon is to be drawn.
     * @param  {number} x The x position of polygon.
     * @param  {number} y The y position of polygon.
     * @param  {number} radius The radius of polygon.
     * @param  {number} sides The number of sides in polygon.
     * @param  {number} startAngle The start angle of polygon.
     *
     * @static webDoodling.Polygon
     * @public
     * @version 1.0
     **/
    wd.Polygon.drawPolygon = _drawPolygon;




})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Star DisplayObject
(function (wd) {
    "use strict";

    var Star;

    /**
     * Represents the `webDoodling.Star` DisplayObject, which has got the shape
     * of an Star.
     *
     * @class webDoodling.Star
     *
     * @example
     * var star = webDoodling.Star({
     *     x: 200,
     *     y: 200,
     *     sides: 20,
     *     radius: 100,
     *     styles:[
     *         webDoodling.stroke('white',2),
     *         webdoolding.fill('blue')
     *     ]
     * });
     *
     * @extends webDoodling.StyleableDisplayObject
     *
     * @public
     * @version 1.0
     **/
    Star = wd.Class({

        /**
         * Returns the type of `webDoodling.Star`, always returns Star.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Star
         * @public
         * @version 1.0
         **/
        type: wd.type("Star"),

        /**
         * Gets or sets the `sides` of the `webDoodling.Star`.
         *
         * @field {number} sides
         * @default 5
         *
         * @memberOf webDoodling.Star
         * @public
         * @version 1.0
         **/
        sides: wd.attribute(5),

        /**
         * Gets or sets the `radius` of the `webDoodling.Star`.
         *
         * @field {number} radius
         * @default 0
         *
         * @memberOf webDoodling.Star
         * @public
         * @version 1.0
         **/
        radius: wd.attribute(0),

        /**
         * Gets or sets the `startAngle` of the `webDoodling.Star`.
         *
         * @field {number} startAngle
         * @default 0
         *
         * @memberOf webDoodling.Star
         * @public
         * @version 1.0
         **/
        startAngle: wd.attribute(0),

         /**
          * Initializes the new instance of `webDoodling.Star`.
          *
          * @constructor init(o)
          * @param {object} o The initialization obejct in JSON format.
          *
          * @memberOf webDoodling.Star
          * @public
          * @version 1.0
          **/
        init: function init(o) {
            this.base();
            this._tweenables.register("number", "radius", "startAngle", "sides");
            this.serializables("radius", "sides", "startAngle");
            if (o) this.deserialize(o);
        },

        //Same as base class docs.
        onDraw: function onDraw(ctx, x, y) {
            //ctx.lineJoin = this.lineJoin;
            //ctx.miterLimit = this.miterLimit;

            _drawStar(ctx, x, y, this.radius, this.sides, this.startAngle);
        },

        getBoundingBox: function getBoundingBox() {
            var box = wd.geometry.Star.getBoundingBox(this.x, this.y, this.radius, this.sides);
            return box;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Star].
         *
         * @memberOf webDoodling.Star
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Star]";
        }

    }, wd.StyleableDisplayObject);

    wd.Star = Star;

    function _drawStar(ctx, x, y, radius, sides, startAngle) {

        sides = sides || 5;
        radius = radius || 0;
        startAngle = startAngle || -90;

        var i,
            delta_theta = 2.0 * Math.PI / sides,
            theta = 2.0 * Math.PI / 8,
            innerPoints = [],
            finalPoints = [],
            x2, y2, offsetX, offsetY,
            idx, idxLen,
            points = [];

        ctx.beginPath();

        for (i = 0; i < sides; i++) {

            x2 = (radius * Math.cos(theta));
            y2 = (radius * Math.sin(theta));
            offsetX = x + x2;
            offsetY = y + y2;
            points.push([offsetX, offsetY]);
            theta += delta_theta;
        }

        theta += delta_theta / 2;

        for (i = 0; i < sides; i++) {
            x2 = ((radius / 2) * Math.cos(theta));
            y2 = ((radius / 2) * Math.sin(theta));

            offsetX = x + x2;
            offsetY = y + y2;

            innerPoints.push([offsetX, offsetY]);
            theta += delta_theta;
        }

        for (i = 0; i < sides; i += 1) {
            finalPoints.push(points[i]);
            finalPoints.push(innerPoints[i]);
        }

        for (idx = 0, idxLen = finalPoints.length; idx < idxLen; idx += 1) {
            //console.log([finalPoints[idx][0], finalPoints[idx][1]]);
            if (idx === 0) {
                ctx.moveTo(finalPoints[idx][0], finalPoints[idx][1]);
            }
            else {
                ctx.lineTo(finalPoints[idx][0], finalPoints[idx][1]);
            }
        }
        ctx.closePath();
    }

    /**
     * Draws a star shape on given context.
     *
     * @function drawStar(ctx, x, y, radius, sides, startAngle)
     * @param  {CanvasRenderingContext2D} ctx The context on which star is to be drawn.
     * @param  {number} x The x position of star.
     * @param  {number} y The y position of star.
     * @param  {number} radius The radius of star.
     * @param  {number} sides The number of sides in star.
     * @param  {number} startAngle The start angle of star.
     *
     * @static webDoodling.Star
     * @public
     * @version 1.0
     **/
    wd.Star.drawStar = _drawStar;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Group DisplayObject
(function (wd) {
    "use strict";

    var Group;

    /**
     * Represents the `webDoodling.Group` DisplayObject. The Group provides
     * containment properties which can be very useful if more than one
     * objects are required to be coupled together, moved or transformed.
     *
     * @class webDoodling.Group
     *
     * @example
     * var scene = new wd.Scene({
     *     children:[
     *         new wd.Group({
     *             id: 'group1',
     *             children:[
     *                 new wd.Circle({
     *                     x: 100,
     *                     y: 100,
     *                     radius: 40,
     *                 }),
     *                 new wd.Circle({
     *                     x: 200,
     *                     y: 200,
     *                     radius: 40,
     *                 }),
     *                 new wd.Circle({
     *                     x: 300,
     *                     y: 300,
     *                     radius: 40,
     *                 })
     *             ]
     *         })
     *     ]
     * })
     *
     * @extends webDoodling.DisplayObject
     *
     * @public
     * @version 1.0
     **/
    Group = wd.Class({

        /**
         * Returns the type of `webDoodling.Group`, always returns 'Group'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Group
         * @public
         * @version 1.0
         **/
        type: wd.type("Group"),

        /**
         * Represents the `children` of  `webDoodling.Group`.
         *
         * @readonly {webDoodling.DisplayObjectCollection} children
         *
         * @memberOf webDoodling.Group
         * @public
         * @version 1.0
         **/
        children: wd.readonly(),

        /**
         * Initializes the new instance of `webDoodling.Group`.
         *
         * @constructor init(o)
         * @param {type} o The initialization object.
         *
         * @memberOf webDoodling.Group
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            var children = new wd.DisplayObjectCollection(),
                self = this;

            this.base();
            this.serializables("children");
            this._children = children;
            children.itemAdd(function (args) {
                //console.log(this);
                var item = args.item;
                //Check if new object has pointers enabled, if yes, enable it for group too.
                if (item.pointers === true) {
                    self.pointers = true;
                }
                //Associated newly added display object with current scene if it is
                //available.
                if (self.scene) {
                    self.scene.associateDisplayObject(item);
                }
                item._parent = self;
                item.resetParents();
            });
            children.itemRemoved(function(e) {
                e.item.resetParents();
            });

            if (o) {
                this.deserialize(o);
            }
        },

        /**
         * TODO: Add description
         *
         * @function onUpdate(context)
         * @params {context} TODO: Add description
         *
         * @function onUpdate(hitContext)
         * @params {hitContext} TODO: Add description
         *
         * @memberOf webDoodling.Group
         * @public
         * @version 1.0
         */
        onUpdate: function onUpdate(context, hitContext) {

            context.save();

            if (this.onBeforeUpdate) {
                this.onBeforeUpdate(context, hitContext);
            }

            var origin = this.absOrigin,
                originX = origin.x,
                originY = origin.y,
                objects = this.children._items,
                object, i, iLen;

            this._setContext(context, false, originX, originY);
            context.translate(-this.originX, -this.originY);
            for (i = 0, iLen = objects.length; i < iLen; i++) {
                object = objects[i];
                if (object.visible === false) {
                    continue;
                }
                if (hitContext) {
                    hitContext.save();
                    this._setContext(hitContext, true, originX, originY);
                    hitContext.translate(-this.originX, -this.originY);

                    object.onUpdate(context, hitContext);
                    if (object.clip) {
                        context.clip();
                        hitContext.clip();
                    }
                    hitContext.restore();
                }
                else {
                    object.onUpdate(context, hitContext);
                    if (object.clip) {
                        context.clip();
                    }
                }
            }
            context.restore();
        },

        /**
         * Returns the child display object having specified id or index.
         *
         * @function get(index)
         * @param {number} index The displayObject index.
         *
         * @function get(id)
         * @param {string} id The displayObject id.
         *
         * @returns {webDoodling.DisplayObject} The display object if found, otherwise `undefined`.
         *
         * @memberOf webDoodling.Group
         * @public
         * @version 1.0
         **/
        get: function get(indexOrId) {
            return this._children.get(indexOrId);
        },

        /**
         * Finds the display object in children heirarchy. TODO: Complete the description
         *
         * @function find(Key)
         * @param  {string} key The dot (.) separated keys(ids) of display object.
         * @example
         * // This example searches rect in child-group.
         *      var childRect = scene.find("child-group.rect");
         * @returns {webDoodling.DisplayObject} The webDoodling.DisplayObject if found, else undefined.
         *
         * @memberOf webDoodling.Group
         * @public
         * @version 1.0
         */
        find: function find(key) {
            return this.children.find(key);
        },

        /**
         * This function is invoked when the DisplayObject is attached to the
         * container `webDoodling.Scene` object.
         *
         * @function onSceneAttached(scene)
         *
         * @memberOf webDoodling.Group
         * @protected This function should not be called directly.
         * @version 1.0
         **/
        onSceneAttached: function onSceneAttached(scene) {
            var children = this.children._items;

            this.children._scene = scene;

            for (var i = 0, iLen = children.length; i < iLen; i++) {
                var item = children[i];
                scene.associateDisplayObject(item);
            }
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Group].
         *
         * @memberOf webDoodling.Group
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Group]";
        },

        // Resets the parents
        // @protected
        resetParents: function() {
            this.base();

            // Reset Childern's parents
            this.children.each(function(object) {
                object.resetParents();
            });
        }

    }, wd.DisplayObject);

    wd.Group = Group;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Movie DisplayObject
(function (wd) {
    "use strict";

    var Movie;

    /**
     * Represents the `webDoodling.Movie` DisplayObject
     *
     * @class webDoodling.Movie
     *
     * @example
     * var AnimatedCircleMovie = webDoodling.Class({
     *     init: function (o) {
     *          this.base(o);
     *              var circle = new wd.Circle({
     *                  radius:50,
     *                   pointers:true,
     *                   styles:[
     *                       new wd.Fill('red')
     *                  ],
     *                   pointerenter:function () {
     *                      this.styles.get(0).fill = 'yellow';
     *                   },
     *                  pointerleave:function () {
     *                       this.styles.get(0).fill = 'red';
     *                   }
     *               });
     *               this.children.add(circle);
     *               this.timeline.repeat = 0;
     *               this.timeline.add([
     *                   new wd.Tween(circle, "radius", 100, 1, 50),
     *                   new wd.Tween(circle, "radius", 50, 51, 50)
     *               ]);
     *     }
     * }, wd.Movie);
     *
     *     var scene = new webDoodling.Scene(canvasElm, {
     *           backgroundColor:'rgba(0, 0, 0, 1)',
     *           children:[
     *               new AnimatedCircleMovie({ x:250, y:175 }),
     *               new AnimatedCircleMovie({ x:450, y:175 })
     *            ]
     *       });
     *
     * @extends webDoodling.Group
     *
     * @public
     * @version 1.0
     **/

    Movie = new wd.Class({

        /**
         * Returns the type of `webDoodling.Movie`, always returns 'Movie'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        type: wd.type("Movie"),

        /**
         * Movie timeline
         * TODO: Add Description
         *
         * @readonly {webDoodling.Timeline} timeline
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        timeline: wd.readonly(),

        /**
         * The field `autoPlay` can be set during object initialization. If it is set to `true`
         * movie starts playing immediately otherwise it remains in paused state.
         *
         * @field {boolean} autoPlay
         * @default true
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        autoPlay: wd.attribute(true),

        /**
         * Returns `true` if movie is currently playing otherwise `false`.
         *
         * @readonly {Boolean} isPlaying
         * @default null
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        isPlaying: wd.readonly(true),

        /**
         * Predefine the structure of the `webDoodling.Movie`.
         * @field {Object} structure
         * @default false
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         */
        structure: wd.attribute(null),

        /**
         * Initializes the new instance of `webDoodling.Movie`.
         *
         * @constructor init(o)
         * @param  {type} o The initialization object.
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        init: function init(o) {
            this.base();
            this.serializables("structure");

            this._timeline = new wd.Timeline();
            this._timeline._parent = this;

            if (this.structure) {
                this.deserialize(this.structure);
            }

            if (o) this.deserialize(o);
        },

        /**
         * Plays the movie if it is not currently paused.
         *
         * @function play()
         * @returns {webDoodling.Movie} Current object useful for chaining.
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        play: function play() {
            this._isPlaying = true;
            return this;
        },

        /**
         * Pauses the timeline animation, which can be resumed by `play` method.
         *
         * @function pause()
         * @returns {webDoodling.Movie} The current object useful for chaining.
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        pause: function pause() {
            this._isPlaying = false;
            return this;
        },

        /**
         * This function is invoke when the `DisplayObject` is attached to 'onSceneAttached'.
         *
         * @function onSceneAttached(scene)
         * @param {webDoodling.Scene} scene The scene to which the current `DisplayObject` is attached.
         *
         * @memberOf webDoodling.Movie
         * @protected This function should not be called directly.
         * @version 1.0
         **/
        onSceneAttached: function onSceneAttached() {
            var self = this,
                scene = this.scene;

            var timeline = this._timeline;
            this._timeline._scene = scene;
            this._timeline._container = this;

            scene.animationLoop(function movieLoop() {
                if (self._isPlaying) {
                    if (timeline.update()) {
                        scene.update();
                    }
                }
            });
            this.base(scene);
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.Movie].
         *
         * @memberOf webDoodling.Movie
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Movie]";
        }

    }, wd.Group);

    wd.Movie = Movie;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//CachedImageSource
(function (wd, undefined) {
    "use strict";

    var ImageSource;

    /**
     * Facilitates display object caching and update. This class is
     * internally used by `webDoodling.DisplayObject.toImageSource`
     * function.
     *
     * @class webDoodling.ImageSource
     * @example
     *
     * var star = new webDoodling.Star({
     *     radius: 50,
     *     styles:[
     *         new webDoodling.Stroke('yellow', 10),
     *         new webDoodling.Fill('red'),
     *     ]
     * });
     *
     * // Here cachedStar object is an instance of webDoodling.ImageSource,
     * // which can be used as source to any image such as `webDoodling.Image`.
     * var cachedStar = star.toImageSource(120, 120);
     *
     * new webDoodling.Image({
     *     x: 350,
     *     y: 100,
     *     source: cachedStar // <- Use cached star as image source.
     * });
     *
     * // Change the star radius to 20.
     * star.radius = 20;
     *
     * // When the source changes, update the cache.
     * cachedStar.update();
     *
     * @public
     * @version 1.0
     **/
    ImageSource = wd.Class({

        /**
         * Returns the `type` of the `webDoodling.ImageSource`, always returns 'ImageSource'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        type: wd.type("ImageSource"),

        /**
         * Returns the associated display object which has been cached to be
         * used as `ImageSource`.
         *
         * @readonly {webDoodling.DisplayObject} object
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        object: wd.readonly(),

        /**
         * Returns the width of the image source.
         *
         * @readonly {number} width
         * @default null
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        width: wd.readonly(),

        /**
         * Returns the height of the image source.
         *
         * @readonly {number} height
         * @default null
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        height: wd.readonly(),

        /**
         * Returns the `offsetX` of the image source.
         *
         * @readonly {number} offsetX
         * @default 0
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        offsetX: wd.readonly(0),

        /**
         * Returns the `offsetY` of the image source.
         *
         * @readonly {number} offsetY
         * @default 0
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        offsetY: wd.readonly(0),

        //TODO: Add media property

        /**
         * Initializes the new instance of `webDoodling.ImageSource`.
         *
         * @constructor init(object, width, height, offsetX, offsetY)
         * @param  {webDoodling.DisplayObject} object The display object to be used as source.
         * @param  {number} width The width of the image source.
         * @param  {number} height The height of the image source.
         * @param  {number} offsetX The offsetX of the image source.
         * @param  {number} offsetY The offsetY of the image source.
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        init: function init(object, width, height, offsetX, offsetY) {
            var canvas = document.createElement("canvas");

            offsetX = (offsetX !== undefined) ? offsetX : 0;
            offsetY = (offsetY !== undefined) ? offsetY : 0;

            canvas.width = width;
            canvas.height = height;

            // document.body.appendChild(canvas);

            this._object = object;
            this._width = width;
            this._height = height;
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._context = canvas.getContext("2d");

            this.media = canvas;
            this.update();
        },

        /**
         * Redraws the image source with updated display object.
         *
         * @function update()
         * @returns {webDoodling.ImageSource} The currect object, useful for chaining.
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        update: function update() {
            var obj = this._object,
                x = obj.x,
                y = obj.y,
                origin = obj.absOrigin,
                width = this._width,
                height = this._height,
                offsetX = this._offsetX,
                offsetY = this._offsetY,
                context = this._context;

            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, width, height);
            context.translate(
                -x + offsetX + (width / 2) - origin.x,
                -y + offsetY + (height / 2) - origin.y
            );

            obj.onUpdate(context);
            return this;
        },

        /**
         * Returns the string representation of the current instance.
         *
         * @function toString()
         * @returns {string} Always returns [object webDoodling.ImageSource].
         *
         * @memberOf webDoodling.ImageSource
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.ImageSource]";
        }

    });

    wd.ImageSource = ImageSource;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
//AssetCore
(function (wd) {
    "use strict";

    var Point;

    /**
     * Represents the various states of assets.
     *
     * @class webDoodling.Point
     *
     * @public
     * @version 1.0
     **/
    Point = wd.Class({

        /**
         * Returns the `type` of `webDoodling.Point`, always returns 'Point'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.Point
         * @public
         * @version 1.0
         **/
        type: wd.type("Point"),

        /**
         * The id of the point.
         *
         * @field {string} id
         *
         * @memberOf webDoodling.Point
         * @public
         * @version 1.0
         **/
        id: wd.attribute(),

        /**
         * The x Position of the point.
         *
         * @field {number} x
         *
         * @memberOf webDoodling.Point
         * @public
         * @version 1.0
         **/
        x: wd.attribute(0),

        /**
         * The y Position of the point.
         *
         * @field {number} y
         *
         * @memberOf webDoodling.Point
         * @public
         * @version 1.0
         **/
        y: wd.attribute(0),

        /**
         * Initialize the x and y position.
         *
         * @param {number} x The x position of the point
         * @param {number} y The y position of the point
         *
         * @memberOf webDoodling.Point
         * @public
         * @version 1.0
         **/
        init: function init(x, y) {
            this.base();
            this.serializables("id", "x", "y");
            if (arguments.length === 1 && wd.is.plainObject(arguments[0])) {
                this.deserialize(arguments[0]);
            }
            else {
                this.x = x || 0;
                this.y = y || 0;
            }
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [webDoodling.Point]
         *
         * @memberOf webDoodling.Point
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.Point]";
        }
    }, wd.Serializable);

    wd.Point = Point;

})(window.webDoodling);
// Copyright (c) 2010 - 2013 - Maniar Technologies Private Limited - India
// The Asset Collection
(function (wd) {
    "use strict";

    var PointCollection;

    /**
     * Represent the `webDoodling.PathCollection`.
     *
     * @class webDoodling.PointCollection
     *
     * @extends webDoodling.Collection
     * @public
     * @version 1.0
     **/
    PointCollection = wd.Class({

        /**
         * Returns the `type` of `webDoodling.PointCollection`,
         * always returns 'PointCollection'.
         *
         * @field {string} type
         *
         * @memberOf webDoodling.PointCollection
         * @public
         * @version 1.0
         **/
        type: wd.type("PointCollection"),

        /**
         * Initializes the new instance of `webDoodling.PointCollection`.
         *
         * @constructor init()
         *
         * @memberOf webDoodling.PointCollection
         * @public
         * @version 1.0
         **/
        init: function init() {
            this.base();
            this.onValidate = function (obj) {
                if (obj instanceof wd.Point === false) {
                    throw new wd.Error("wd-invalid-argument", obj);
                }
                return null;
            };
        },

        /**
         * Adds a new point into the collection.
         *
         * @function addPoint(x, y)
         * @param {Number} x The x coordinate of the point.
         * @param {Number} y The y coordinate of the point.
         *
         * @memberOf webDoodling.PointCollection
         * @public
         * @version 1.0
         **/
        addPoint: function addPoint(x, y) {
            this.add(new wd.Point(x, y));
            return this;
        },

        /**
         * Returns the string representation of current instance.
         *
         * @function toString()
         * @returns {string} Always returns [webDoodling.PointCollection]
         *
         * @memberOf webDoodling.PointCollection
         * @public
         * @version 1.0
         **/
        toString: function toString() {
            return "[object webDoodling.PointCollection]";
        }

    }, wd.Collection);

    wd.PointCollection = PointCollection;

    /**
     * Returns a new `webDoodling.PointCollection` object generated
     * from an array of {x, y} point objects.
     *
     * @function fromArray(arr)
     * @param  {Array[{x, y}]} arr An array of objects having x and y coordinates.
     *
     * @memberOf webDoodling.PointCollection
     * @static
     * @return {webDoodling.PointCollection}     [description]
     */
    wd.PointCollection.fromArray = function fromArray (arr) {
        var i, iLen,
            point, points;

        if (wd.is.array(arr) === false) {
            throw new wd.Error("wd-invalid-argument", "array of points");
        }

        points = new wd.PointCollection();
        for(i = 0, iLen = arr.length; i < iLen; i += 1) {
            point = arr[i];
            if (point instanceof wd.Point) {
                points.add(point);
            }
            else {
                points.addPoint(point.x, point.y);
            }
        }

        return points;
    };

})(window.webDoodling);
(function (wd, undefined) {

    /**
     * A simple menthod to create a scene which can be used as a preloader.
     *
     * @function webDoodling.createPreloader(canvas, [size], [backgroundColor], [clockwise])
     *
     * @param  {HTMLCanvasElement} canvas   The canvas for which the scene needs to be created.
     * @param  {[number]} size                Sets the dimension of the preloader.
     * @param  {[string]} backgroundColor     Sets the background color of the preloader scene.
     * @param  {[boolean]} clockwise          If set to true, rotates preloader in clockwise direction, otherwise anticlockwise.
     *
     * @return {webDoodling.Scene}          Returns the active scene, which can immediately be used as loader.
     *
     * @example
     * wd.createDefaultLoderScene(theCanvas, 32, "black", true);
     *
     * @memberof webDoodling
     * @version 1.0
     * @public
     **/
    wd.createPreloader = function createPreloader (canvas, size, backgroundColor, clockwise) {
        var scaleX, // SVG size is 500, find scaleX and scaleY
            scaleY,
            width,
            height,
            x, y,
            scene,
            logoSVG,
            r1, r2, r3, r4;

        size = size || 32;
        // Scale logo
        scaleX = size / 500; // SVG size is 500, find scaleX and scaleY
        scaleY = size / 500;
        logoSVG = wd.logoSVG.replace(/<g>/g, "<g transform='scale(" + scaleX + ", " + scaleY + ")'>");

        // Set height and width
        width   = canvas.width;
        height  = canvas.height;

        // Setup rotation directions.
        r1 = 90;
        r2 = 180;
        r3 = 270;
        r4 = 360;
        clockwise = clockwise === undefined ? true : clockwise;
        if (!clockwise) {
            r1 = -r1;
            r2 = -r2;
            r3 = -r3;
            r4 = -r4;
        }

        // Calculate center x and y position
        x = (width - size) / 2;
        y = (height - size) / 2;

        // Define scene
        scene = new wd.Scene(canvas, {
            backgroundColor: backgroundColor || "transparent",
            children: [
                wd.Image({
                    id: "loader",
                    x: x,
                    y: y,
                    width: size,
                    height: size,
                    draggable: true,
                    opacity: 0,
                    source: new wd.SVGSource({
                        source: logoSVG,
                        height: size,
                        width: size
                    }),
                    dragstop: function () {
                        this.animate({
                            easing: "elasticOut",
                            length: 30,
                            values: {
                                x: x,
                                y: y
                            }
                        });
                    }
                })
            ],
            timeline: {
                repeat: 0,
                tweens: [
                    new wd.Tween("loader", "opacity", 1, 1, 100),
                    new wd.Tween("loader", "rotation", r1, 101, 20, "quartOut"),
                    new wd.Tween("loader", "rotation", r2, 121, 20, "quartOut"),
                    new wd.Tween("loader", "rotation", r3, 141, 20, "quartOut"),
                    new wd.Tween("loader", "rotation", r4, 161, 20, "quartOut")
                ],
                onFrame: function (frame) {
                    if (frame === 180) {
                        this.gotoAndPlay(101);
                    }
                }
            }
        });

        return scene;
    };


}) (window.webDoodling);